<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IP地址</title>
    <url>/2020/07/20/ipaddress/</url>
    <content><![CDATA[<p>localhost、127.0.0.1、0.0.0.0、本机IP的区别 - https://zhuanlan.zhihu.com/p/72988255 - https://www.cnblogs.com/operationhome/p/8681475.html - https://www.jianshu.com/p/ad7cd1d5be45</p>
]]></content>
      <tags>
        <tag>Network</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云服务器(centos7系统) 使用nginx+uwsgi 部署python+flask项目</title>
    <url>/2020/06/21/aliyun-sfim/</url>
    <content><![CDATA[<h1 id="web服务器的搭建">Web服务器的搭建</h1>
<h2 id="阿里云ecscentos7-python-flask-nginx">阿里云ECS(centos7) + python flask + Nginx</h2>
<ul>
<li><p><a href="https://blog.csdn.net/CHENYAoo/article/details/83055108">uwsgi、wsgi和nginx的区别和关系</a></p></li>
<li><p><a href="https://blog.csdn.net/u011244708/article/details/82915006">CentOS7 python2升级到python3的那些坑</a></p></li>
<li><p><a href="https://www.cnblogs.com/FZfangzheng/p/7588944.html">Centos7安装Python3的方法</a></p></li>
<li><p><a href="https://www.runoob.com/mysql/mysql-install.html">Linux/UNIX 上安装 MySQL</a></p>
<ul>
<li>选择MySQL5.7版本 8.0版本一直报错</li>
</ul></li>
<li><p><a href="https://my.oschina.net/u/2455518/blog/3039411">CentOS7安装MySql8不能启动的问题</a></p></li>
<li><p><a href="https://stackoverflow.com/questions/33326065/unable-to-access-mysql-after-it-automatically-generated-a-temporary-password">unable-to-access-mysql-after-it-automatically-generated-a-temporary-password</a></p>
<ul>
<li>mysql -uroot -p : 123456</li>
<li>mysql 修改 root 密码
<ul>
<li><p>ALTER USER 'root'@'localhost' IDENTIFIED BY 'test4321'; &gt; ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement</p></li>
<li><p>https://blog.csdn.net/vv19910825/article/details/82979563 &gt; ERROR 1819 (HY000): Your password does not satisfy the current policy</p></li>
<li><p>https://blog.csdn.net/hello_world_qwp/article/details/79551789</p></li>
</ul></li>
</ul></li>
<li><p><a href="https://blog.csdn.net/qq_41090453/article/details/83451321">在本地端使用浏览器打开该云实例的公网地址:端口</a></p></li>
<li><p><a href="https://www.jianshu.com/p/61d18009b657">nginx + uwsgi</a></p></li>
</ul>
<a id="more"></a>
<h2 id="ip端口号访问">ip+端口号访问</h2>
<h3 id="method-1---访问需ip-端口号访问">Method 1 - 访问需ip + 端口号访问</h3>
<ul>
<li>web应用是由Flask内置的web服务托管</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl stop nginx</span><br><span class="line">kill uwsgi的所有进程</span><br><span class="line">systemctl stop iptables</span><br><span class="line">systemctl stop firewalld</span><br><span class="line"></span><br><span class="line"># vi app.py</span><br><span class="line">app.run(host&#x3D;&quot;0.0.0.0&quot;,port&#x3D;5000)</span><br><span class="line"></span><br><span class="line"># app.run一定要设成 0.0.0.0 才可以访问</span><br><span class="line"></span><br><span class="line"># 以http:&#x2F;&#x2F;121.199.46.37:5000&#x2F; 访问 ip+端口号</span><br></pre></td></tr></table></figure>
<h3 id="method-2---uwsgi---访问无需端口号直接以阿里云服务器公网访问">Method 2 - uwsgi - 访问无需端口号，直接以阿里云服务器公网访问</h3>
<ul>
<li>pip install uwsgi</li>
<li><a href="https://uwsgi-docs.readthedocs.io/en/latest/WSGIquickstart.html">uwsgi官方文档</a></li>
<li><code>run.py</code>文件修改成<code>app.run()</code></li>
<li>在项目中新建文件config.ini，<code>uwsgi</code>的配置<code>/Sfim/src/config.ini</code>，编写如下配置配置如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[uwsgi]</span><br><span class="line"></span><br><span class="line"># uwsgi 启动时所使用的地址与端口</span><br><span class="line">socket &#x3D; 127.0.0.1:5000</span><br><span class="line"></span><br><span class="line"># 外网访问端口，如果直接用uWSGI外网，这里由于使用了Nginx，故注释掉</span><br><span class="line">http&#x3D; :80</span><br><span class="line"></span><br><span class="line"># 指向网站目录</span><br><span class="line">chdir &#x3D; &#x2F;root&#x2F;test&#x2F;</span><br><span class="line"></span><br><span class="line"># python 启动程序文件</span><br><span class="line">wsgi-file &#x3D; app.py</span><br><span class="line"></span><br><span class="line"># python 程序内用以启动的 application 变量名</span><br><span class="line"># app 是 app.py 程序文件内的一个变量，这个变量的类型是 Flask的 application 类</span><br><span class="line">callable &#x3D; app</span><br><span class="line"></span><br><span class="line"># 处理器数</span><br><span class="line">processes &#x3D; 4</span><br><span class="line"></span><br><span class="line"># 线程数</span><br><span class="line">threads &#x3D; 2</span><br><span class="line"></span><br><span class="line">#状态检测地址</span><br><span class="line">stats &#x3D; 127.0.0.1:9191</span><br><span class="line"></span><br><span class="line">#daemonize&#x3D;&#x2F;var&#x2F;log&#x2F;uwsgi.log</span><br></pre></td></tr></table></figure>
<ul>
<li>启动：uwsgi --ini config.ini</li>
<li>使用uwsgi之后，修改app.py -&gt; app.run()</li>
<li>一定要保证代码风格是严格按照官网的
<ul>
<li><p>即app=Flask(<strong>name</strong>)要放在<code>if __name__ = "__main__"</code>外面</p></li>
<li><p><code>if __name__ = "__main__"</code>里面只能放<code>app.run()</code></p></li>
<li><p>不然会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception: Install &#39;email_validator&#39; for email validation support.</span><br><span class="line">unable to load app 0 (mountpoint&#x3D;&#39;&#39;) (callable not found or import error)</span><br><span class="line">--- no python application found, check your startup logs for errors ---</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://segmentfault.com/q/1010000014488435">解决方法1</a></li>
<li><a href="https://segmentfault.com/q/1010000014488435">解决方法2</a></li>
</ul></li>
</ul></li>
<li>uwsgi运行相关应用时要加上-d参数使其在后台运行，否则断开ssh连接后uwsgi就停止运行了，-d后要加上项目的uwsgi.log文件，没有新建一个即可。例 -d ~/uwsgi.log</li>
</ul>
<h3 id="method-3--nginx---访问无需端口号直接以阿里云服务器公网访问">Method 3 -nginx - 访问无需端口号，直接以阿里云服务器公网访问</h3>
<ul>
<li><p>先关闭uwsgi</p></li>
<li><p>/etc/nginx/nginx.conf / 日志/var/log/nginx/error.log<br />
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#只用nginx代理的配置</span><br><span class="line">server &#123;</span><br><span class="line">     listen          80;</span><br><span class="line">     server_name     47.106.218.225;  # 阿里云公网ip</span><br><span class="line"> </span><br><span class="line">     location &#x2F; &#123;</span><br><span class="line">        proxy_pass    http:&#x2F;&#x2F;127.0.0.1:5000;      # 本机:启动端口（此处端口与项目端口一致）      </span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python app.py</span><br><span class="line">nohup python app.py &gt;&gt; app.out &amp;   将运行日志输出到app.out文件</span><br><span class="line">nohup python run.py &gt;&gt; run.out &amp; </span><br><span class="line"># nohup 加在一个命令的最前面，表示不挂断的运行命令</span><br><span class="line"># &amp; 加在一个命令的最后面，表示这个命令放在后台执行</span><br><span class="line"># ps 和 jobs</span><br><span class="line"># 区别在于 jobs 只能查看当前终端后台执行的任务，换了终端就看不见了</span><br><span class="line"># ps命令适用于查看瞬时进程的动态，可以看到别的终端的任务</span><br><span class="line"># a: 显示所有程序  u: 以用户为主的格式来显示   x: 显示所有程序，不以终端机来区分</span><br><span class="line"># fg命令 将后台中的命令调至前台继续运行</span><br><span class="line"># Ctrl + z 命令 将一个正在前台执行的命令放到后台，并且处于暂停状态</span><br><span class="line"># bg命令 将一个在后台暂停的命令，变成在后台继续执行</span><br><span class="line">tail -f app.out</span><br><span class="line">tailf app.out</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="method-4---nginx-uwsgi---访问无需端口号直接以阿里云服务器公网访问">Method 4 - nginx + uwsgi - 访问无需端口号，直接以阿里云服务器公网访问</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; config.ini</span><br><span class="line">#http &#x3D; :80</span><br><span class="line"></span><br><span class="line">&gt; &#x2F;etc&#x2F;nginx&#x2F;nginx.conf</span><br><span class="line">server &#123;</span><br><span class="line">        #ssl_protocols TLSv1.2;</span><br><span class="line">        #server_tokens off;</span><br><span class="line">        listen       80 default_server;</span><br><span class="line">        #listen       [::]:80 default_server;</span><br><span class="line">        server_name  121.199.46.37; # 阿里云公网ip</span><br><span class="line">        #root         &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include &#x2F;etc&#x2F;nginx&#x2F;default.d&#x2F;*.conf;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">           #proxy_pass http:&#x2F;&#x2F;127.0.0.1:5000; # 本机:启动端口(此处端口与项目端口一致)</span><br><span class="line">           #proxy_set_header Host $host;</span><br><span class="line">           #proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">           include uwsgi_params;</span><br><span class="line">           uwsgi_pass 127.0.0.1:5000;</span><br><span class="line">           uwsgi_param UWSGI_PYHOME &#x2F;usr&#x2F;bin&#x2F;python; # python位置</span><br><span class="line">           uwsgi_param UWSGI_CHDIR &#x2F;root&#x2F;test; # 项目根目录</span><br><span class="line">           uwsgi_param UWSGI_SCRIPT app:app;</span><br><span class="line">        &#125;</span><br><span class="line"># 跑起来</span><br><span class="line">systemctl start nginx</span><br><span class="line"></span><br><span class="line">nginx -s reload</span><br><span class="line">service nginx restart  # 重启nginx服务</span><br><span class="line">service nginx start # 启动服务</span><br><span class="line">service nginx stop # 停止服务 </span><br><span class="line"></span><br><span class="line">运行uwsgi服务（通过执行启动脚本运行项目）</span><br><span class="line">uwsgi --ini config.ini  （启动脚本存放位置）</span><br><span class="line"># 后台运行</span><br><span class="line">uwsgi --ini config.ini --daemonize uwsgi.out</span><br></pre></td></tr></table></figure>
<ul>
<li><p>错误提示 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[error] 2168#0: *19 connect() failed (111: Connection refused) while connecting to upstream</span><br></pre></td></tr></table></figure> <a href="https://segmentfault.com/q/1010000014488435">参考资料</a> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; config.ini</span><br><span class="line">[uwsgi]</span><br><span class="line">socket&#x3D;127.0.0.1:8080</span><br><span class="line">plugins &#x3D; python</span><br><span class="line">wsgi-file&#x3D;test.py</span><br><span class="line">master&#x3D;true</span><br><span class="line">processes&#x3D;4</span><br><span class="line">threads&#x3D;2</span><br><span class="line">callable&#x3D;app</span><br><span class="line">stats&#x3D;127.0.0.1:9191</span><br><span class="line"></span><br><span class="line">&gt; nginx.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name 111.230.140.182;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    client_max_body_size 75M;</span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        include uwsgi_params;</span><br><span class="line">        uwsgi_pass 127.0.0.1:8080;</span><br><span class="line">        #uwsgi_param UWSGI_PYTHON &#x2F;usr&#x2F;bin&#x2F;python;  &#x2F;&#x2F;注释掉</span><br><span class="line">        #uwsgi_param UWSGI_CHDIR &#x2F;home&#x2F;ubuntu&#x2F;project&#x2F;test;  &#x2F;&#x2F;注释掉</span><br><span class="line">        #uwsgi_param UWSGI_SCRIPT test:app ;  &#x2F;&#x2F;注释掉</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>注意点：</p>
<ul>
<li>不同的web application要更换不同的端口，否则会出错，即使停掉了所有服务只启动一个服务也是如此</li>
</ul></li>
</ul>
<h2 id="nginxuwsgiflask的参考资料">nginx+uwsgi+flask的参考资料</h2>
<table>
<thead>
<tr class="header">
<th>Name</th>
<th>Explanation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Flask</td>
<td>一个轻量级的Python Web框架</td>
</tr>
<tr class="even">
<td>Nginx</td>
<td>一个非常稳定的Web服务器</td>
</tr>
<tr class="odd">
<td>uwsgi</td>
<td>一个全站式的托管服务，它实现了应用服务器（支持多种编程语言）、代理、进程管理器、监视器</td>
</tr>
</tbody>
</table>
<ul>
<li><p>使用Nginx服务器托管Flask应用的安装、配置过程</p></li>
<li><p>Nginx是一个提供静态文件访问的web服务，然而，它不能直接执行托管Python应用程序，而uWSGI解决了这个问题？？？</p></li>
<li><p><a href="https://www.missshi.cn/api/view/blog/5b1511a213d85b1251000000">可以看看理论部分-使用Flask+uwsgi+Nginx部署Flask正式环境</a></p>
<blockquote>
<p>直接使用python run.py运行服务的方式只适合本地开发 线上运行时要保证更高的性能和稳定性，需要使用uwsgi进行部署</p>
</blockquote>
<blockquote>
<p>使用Nginx有如下一些优点： 安全：不管什么请求都要经过代理服务器，避免了外部程序直接攻击web服务器 负载均衡：根据请求情况和服务器负载情况，将请求分配给不同的web服务器，保证服务器性能 提高web服务器的IO性能：对于一些静态文件，可以直接由反向代理处理，不经过web服务器</p>
</blockquote></li>
<li><p><a href="https://www.jianshu.com/p/5b73444eb47d">只看了概念解释-新手的Flask+uwsgi+Nginx+Ubuntu部署过程</a></p></li>
<li><p><a href="https://www.jianshu.com/p/48048554f989">一篇就弄懂WSGI、uwsgi和uWSGI的区别</a></p></li>
</ul>
<h1 id="备用资料">备用资料</h1>
<ul>
<li><a href="https://yq.aliyun.com/articles/637307">最新阿里云申请免费SSL证书实现网站HTTPS化（图文教程一）</a></li>
</ul>
<blockquote>
<p>通过在阿里云服务器ECS(系统为centos7)上搭建Web服务器，能够实现不仅仅是在本地，而是在互联网的访问我们的网站。使用uWSGI和Nginx部署flask项目， 其中uWSGI一个全站式的托管服务，它实现了应用服务器(支持多种编程语言)、代理、进程管理器、监视器，帮助实现WSGI协议、Http协议等，使得开发者不再需要关注网络通信的底层实现，而花更多的时间开发上层应用。 WSGI(Web Server Gateway Interface)服务器网关接口是Python应用程序或框架和Web服务器之间的一种接口，已经被广泛接受。只要遵照这些协议，WSGI应用(Application)都可以在任何服务器(Server)上运行。通过利用uWSGI可以使我们的web应用得到更强的并发能力。 通过Nginx，一个非常稳定的Web服务器和反向代理服务器，能够进一步提高并发能力和访问效率。Nginx还有如下优点：安全，不管什么请求都要经过代理服务器，避免了外部程序直接攻击web服务器；负载均衡，根据请求情况和服务器负载情况，将请求分配给不同的web服务器，保证服务器性能；提高web服务器的IO性能，对于一些静态文件，可以直接由反向代理处理和缓存，不经过web服务器。 用户和本项目搭建的应用程序中的交互流程为：Nginx接受来自客户端的Http请求发送给uWSGI，uWSGI处理请求并将关键信息传递给web框架flask或者web应用等，应用返回Response经由uWSGI发送给Nginx，Nginx再发送给客户端。</p>
</blockquote>
<p>解决问题的实际感受：了解阿里云云服务器ECS，发现一台暴露在网络的服务器经常受到威胁和攻击，从买了他们的产品开始，每天都会有警告邮件，要按照阿里云官方的解决方法修补漏洞和加固，深入了解了Web服务器的部署，学习到了Nginx和uWSGI的知识</p>
<details>
<p><summary>代码细节</summary></p>
<h2 id="sqlalchemy的用法">sqlalchemy的用法</h2>
<h2 id="flask蓝图">flask蓝图</h2>
<h2 id="编写index.html界面">编写index.html界面</h2>
<ul>
<li>index.html出现的位置home.py</li>
</ul>
<h2 id="windows跑代码">Windows跑代码</h2>
<ul>
<li>验证邮箱的时候，服务没有开启 www.sfim.tools 改为 192.168.0.101:8080</li>
<li>models里面是和数据库有关的</li>
</ul>
<h2 id="windows-安装-mysql-8.0.19">windows 安装 mysql 8.0.19</h2>
<ul>
<li><a href="https://www.jb51.net/article/179326.htm">安装教程</a></li>
<li><a href="https://www.cnblogs.com/MrKeen/p/12575325.html">mysql front 报错</a></li>
</ul>
</details>
]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>uwsgi</tag>
        <tag>web server</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全中的二进制安全</title>
    <url>/2020/06/13/binary-safe/</url>
    <content><![CDATA[<p>二进制安全是整个软件安全中核心的内容</p>
<a id="more"></a>
<h2 id="二进制软件">二进制软件</h2>
<ul>
<li>核心：二进制是软件的最基本形态
<ul>
<li>所有的基础软件都是以二进制软件的形式存在</li>
<li>二进制软件：操作系统、浏览器、数据库、中间件、各种脚本软件的解释执行器、很多大型游戏</li>
</ul></li>
<li>二进制软件的基本特征：是CPU可以直接运行的机器指令
<ul>
<li>CPU能够运行的机器指令都是二进制的，包括了很多非ASCII的不可打印字符</li>
<li>二进制程序无法跨平台：不同平台的二进制软件是不同的，Intel架构的cpu的二进制无法在ARM架构上运行，反之也是</li>
<li>二进制形式的软件无法跨操作系统运行：二进制程序还需要操作系统的支持</li>
</ul></li>
<li>直接使用二进制或者十六进制进行编程，人进行数据阅读比较困难，效率非常低下 -&gt; 编程的时候不直接处理二进制，直接使用文本来编程
<ul>
<li>文本代码CPU无法执行，需要<strong>编译和链接</strong></li>
<li>程序员编写出来的文本形式的代码 -&gt; 源代码
<ul>
<li>首先发明的源代码是汇编形式的，是使用的和机器指令一一对应的汇编语言，是一种直接最简单的操作指令级别的翻译过程</li>
<li>汇编的编程还不是很方便，后来发明了C语言等高级语言，高级语言不止C语言一种，但是C比较成功，又发明了C++</li>
</ul></li>
<li>编译后生成的机器可运行的代码 -&gt; 目标代码</li>
</ul></li>
<li>研究二进制安全，首先需要了解的就是二进制软件和源代码，之后是脚本语言的关系</li>
</ul>
<h2 id="软件安全研究的核心问题">软件安全研究的核心问题</h2>
<ul>
<li>看表面不够，深入内部细节，需要了解的软件的具体原理，到代码级别</li>
<li>已经发现的软件安全典型的问题：栈溢出、堆溢出、格式化字符串漏洞、空指针、整形溢出等等</li>
<li>软件安全研究的两个核心问题
<ul>
<li>安全问题（也叫脆弱性，通常叫漏洞）的存在性问题 - 漏洞挖掘</li>
<li>这个安全问题的可利用性问题，安全漏洞具体有什么危害，如果达到这个危害如何防止 - 漏洞利用</li>
</ul></li>
</ul>
<h3 id="漏洞挖掘---安全问题的存在性问题">漏洞挖掘 - 安全问题的存在性问题</h3>
<ul>
<li>安全问题的脆弱性，通常叫漏洞</li>
<li>由于软件安全的漏洞都是具体的，都是由软件内部的代码的编程不慎所引起的 &gt; 所以漏洞挖掘方法就是分析代码</li>
<li>分析二进制（安全人员捕获一个攻击程序后拿不到源代码，源代码在发起攻击的人 / 黑客手上）
<ul>
<li>在了解二进制机器指令的基本原理后，通过一些辅助的工具来解读</li>
<li>通过逆向工程的一些技术，把二进制软件解构、翻译，然后就能理解其实现的原理</li>
</ul></li>
<li>漏洞挖掘技术现在是攻防双方都在使用：软件的开发人员也在采用黑客发明的漏洞挖掘技术来挖自己的漏洞，以争取在软件发布前把安全问题尽量发现和修补</li>
</ul>
<h4 id="反汇编">反汇编</h4>
<ul>
<li>反汇编以及在汇编代码上的一些解构，比如获得函数列表、获得每个函数的调用关系、获得函数内部的控制流程图</li>
<li>变量名、函数名、注释、一些数据类型是源代码层面方便程序员编程的，对于二进制软件来讲，名称信息没有用处，机器指令内部全部是使用“数据和代码的存储地址”</li>
<li>反汇编工具：基本 &gt; dumpbin &amp; objdump，高级 &gt; IDA-pro</li>
<li>所有的调试器也都有反汇编功能</li>
</ul>
<h4 id="调试器">调试器</h4>
<ul>
<li>调试器比反汇编器要高级，因为反汇编器只能在程序没有运行起来的时候去观察它，而调试器可以在程序运行起来以后，随时中断程序的运行并观察</li>
<li>运行时的信息要更丰富，比如运行时候可以看到用户输入的数据、外部读入的数据、这些数据的具体处理过程、某个变量在运行时的赋值情况等，这些信息都是静态的反汇编所没有的。但信息丰富则需要分析和处理的数据量是非常大的</li>
<li>调试器还有一个反汇编器没有的功能：能捕获<strong>程序执行的异常</strong>
<ul>
<li>异常信息：因为二进制软件的安全问题，通常会引起程序运行时的内部数据结构被破坏，比如各种溢出，其实是覆盖了正常的数据。内部数据结构被破坏以后，程序在后续执行时，可能访问这些不正常的数据，进而引起运行时错误</li>
<li>大多数运行时错误，最后都变成内存访问的异常 &gt; 虚拟内存管理方面的知识</li>
</ul></li>
</ul>
<h4 id="漏洞寻找">漏洞寻找</h4>
<p>有了调试器和反汇编器，就有了观察和了解程序内部原理的工具，这些基础工具就像医院用的心电图、X光和CT一样，是获得内部基础数据的工具。但是只有这些工具，有时候还是不能发现具体问题，我们得了解具体漏洞产生的原因，比如溢出，为什么溢出是严重的安全问题</p>
<p>寻找漏洞最直接的思路，是一行行看代码 &gt; 可行性 &amp;&amp; 巨大的麻烦(软件是一个非常复杂和庞大的事物，比如Windows，有上万名开发人员，持续开发了20年，发布了无数个版本。如果一行行看代码，还不是源代码，是二进制反汇编代码，则需要和开发人员同等数量的人员和时间，这往往是达不到的)</p>
<p><strong>所以漏洞的挖掘，极少情况下会直接人工分析源代码，安全研究人员们，更希望借助自动化的工具</strong></p>
<h4 id="两大类自动化工具模糊测试工具-程序分析工具">两大类自动化工具：模糊测试工具 &amp; 程序分析工具</h4>
<h5 id="模糊测试fuzzing">模糊测试(Fuzzing)</h5>
<ul>
<li>认为软件很复杂，干脆不要去看内部了，把软件当做一个黑盒子，只看它的外部表现，给它各种各样的输入，看它在处理过程中会不会出现异常。如果有异常就说明软件在设计的过程中，没有考虑到用户会输入这样的数据，和软件的预期不符合，则存在漏洞。程序异常通常会引起程序的崩溃，用调试器来捕获异常，能实现自动化</li>
<li>通过研究漏洞的原理，漏洞是<strong>畸形数据</strong>引起的，比如输入了一个超长的字符串，比程序员内部预留的长，则发生溢出。所以通过输入畸形数据去尝试触发崩溃的方法，理论上也是可行的
<ul>
<li>通过<strong>随机</strong>，构造畸形数据。随机并不是每次都能构造出正好合适的畸形数据，但是随即构造大量数据以后很有可能有那么一两次成功</li>
<li>软件虽然复杂，但是运行速度很快，可以<strong>不停的自动</strong>运行目标软件，让软件来处理这些随机构造的可能是畸形的数据，然后运行的时候启动调试器来捕获可能得异常，虽然不是每次都能触发异常</li>
</ul></li>
</ul>
<h5 id="模糊测试工具">模糊测试工具</h5>
<ul>
<li>深入软件的内部原理的，分析它的每一行代码</li>
<li>代表的技术：危险函数定位和符号执行等
<ul>
<li>危险函数定位的思路是，既然strcpy等能引起缓冲区溢出，那么就把全部的strcpy找出来看一看。随着研究的深入，人们发现，不是所有的漏洞都是危险函数引起的。内存操作的方法各种各样，千奇百怪，而且不是所有的危险函数都会引起安全问题。比如调用之前进行了长度判断 &gt; 所以这种方法效果很差</li>
<li>符号执行：分析方法，逐步复杂</li>
</ul></li>
</ul>
<h3 id="漏洞利用---安全问题的可利用性问题">漏洞利用 - 安全问题的可利用性问题</h3>
<ul>
<li>安全漏洞具体有什么危害 / 安全缺陷的危害，如果达到这个危害，如何防止</li>
<li>编写exp（漏洞利用程序）也是软件安全研究人员的基本功
<ul>
<li>exp一般分为攻击数据部分 + 攻击成功后的控制部分，前一部分比如一个超级长的字符串，用来溢出缓冲区；后一部分，就是shellcode</li>
<li>shellcode很多时候可以通用，但是攻击数据部分，每个漏洞都不一样。这部分的学习，比较有效的办法就是去阅读和使用别人写好的exp。kali Metasploit exploit-db上有很多这样的程序，有一些安全研究人员的个人博客上也有很多。所以大家就去找一两个公开了exp的具体的漏洞，搭建漏洞环境，解读学习exp &gt; <strong>漏洞复现</strong></li>
</ul></li>
</ul>
<h4 id="别人已经挖掘发现的漏洞">别人已经挖掘发现的漏洞</h4>
<ul>
<li>一些软件厂家，比如微软会定期升级自己的系统，打补丁。在打补丁升级系统的时候，就会同时给出安全公告说修补了那些问题</li>
<li>统一的数据库CVE：但是并不是每个软件厂家都有能力或者意愿去维护一个安全漏洞。有一些第三方的组织就来收集各种漏洞，并形成了一个统一的数据库，比如CVE
<ul>
<li>CVE给每个漏洞都编写，说明漏洞影响的软件及其版本，危害程度等等详细信息</li>
<li>少量的漏洞还会给出PoC，也就是概念验证程序。早期的漏洞很多都有PoC，因为那个时候，很多软件厂家不重视漏洞修补工作。漏洞的发现人员，或者安全厂商放出PoC也能逼迫软件厂商去修补</li>
<li>现在，软件漏洞的披露已经很规范了。国家也重视，所有美国和我们有国家安全漏洞数据库，美国有NVD，我们国家的CNVD和CNNVD。这些都是大家去找已经公开的漏洞的地方</li>
</ul></li>
</ul>
<h4 id="漏洞复现">漏洞复现</h4>
<p>如果拿到了一个漏洞的详细公告和PoC，如何去复现这个漏洞：安装一个有漏洞存在的软件版本</p>
<p>虚拟机：这个过程中，通常在<strong>虚拟机</strong>里安装配置。因为漏洞需要的环境可能和我们的工作主机的环境冲突很大，而且漏洞环境复现过程中，可能会破坏系统。如果我们要复现很多漏洞，不在虚拟机中进行，会把自己的工作环境弄得很乱</p>
<p>模拟器：模拟器和虚拟机相似又不同，他们都是在内部构造了一个“虚拟的机器”。这个虚拟的机器可以和真实的机器一样安装和运行操作系统以及各种软件。但是虚拟机，还是借助的物理CPU的虚拟化功能，而模拟器是使用软件来“实现”了一个CPU及其附属的设备 - 虚拟机的host系统和guest系统，只能是同一架构的。比如物理主机是intel架构，那么host和guest都这能是Intel 0x86架构的系统，比如Windows和Linux x86。但是模拟器就可以跨架构，host是Windows x86，guest是arm架构的安卓系统。 - 模拟器的典型代表：<a href="https://www.qemu.org/">QEMU</a> - 如果要研究安卓系统、路由器等MIPS架构的系统，就需要模拟器 - 模拟器通常也有调试、单步运行等功能，除了用于漏洞复现，也可用于漏洞挖掘。比如要挖掘一个路由器的漏洞，不能直接对着物理路由器Fuzzing，因为就是触发了异常，也无法捕获。所以通常是把固件提取出来，在模拟器中运行</p>
<h4 id="软件攻防">软件攻防</h4>
<p>黑客如果通过攻击，进入到了一个目标系统。除了要考虑窃取信息、加密硬盘（勒索软件）、破坏数据等攻击之外，还需要考虑：第一是不留痕迹，第二是不能被杀毒软件和主机中的一些防御系统识别</p>
<p>早期，安全研究人员也在想办法对抗漏洞攻击和计算机病毒（计算机病毒其实就是一个可以自我复制的漏洞利用程序）。他们想到的办法就是杀毒软件 - 杀毒软件的基本原理是把已经发现的病毒等各种恶意程序的特征值记录在数据库中，每当系统中有新的文件时就计算一下这个文件的特征值，然后和数据库中的特征值进行比较，如果匹配上了，说明这是一个恶意程序 - 特征值通常是hash值。因为恶意软件很多，不可能把整个恶意软件都作为特性，占用空间也不方便分发特征值（分发特征值就是病毒升级）。但是如果源数据稍微变化一下，hash值就变化了。比如病毒修改自己的一个无意义的常量数据，功能不变，杀毒软件就无法查杀了。所以后来有发明了动态的基于行为的检测。 - rootkit技术：恶意软件需要隐蔽自己，比如文件、进程、通讯的端口都需要隐藏起来 - rootkit技术很多是基于API hook。通过挂钩API，篡改了操作系统的行为，当防御软件在列举目录中文件时，根本就获取不到攻击程序的文件</p>
<p>防御软件和攻击软件就是一个技术博弈，此消彼长的过程，产生了非常多很有意思的技术： - 比如攻击软件为了防止被发现，根本就不产生文件。可执行程序首先是一个文件，在系统上创建进程运行。后来出现了根本不产生文件，也不修改其他文件，寄生在其他可执行程序进程中、直接从网络加载到内存就能运行的恶意程序 - 外挂：外挂程序也是通过修改正常程序的软件行为，比如直接篡改内存中的数据，或者挂钩其函数，达到修改软件行为的目的。开发和防御外挂软件的技术与软件攻防技术相似，都是需要使用逆向工程工具和调试器等、都需要大量的数据分析工作</p>
]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS攻击</title>
    <url>/2020/06/11/xss-attack/</url>
    <content><![CDATA[<h1 id="使用python内置的库开发一个基本的http服务器端">使用python内置的库开发一个基本的http服务器端</h1>
<ul>
<li><a href="#讲解代码">测试代码</a></li>
<li>使用python原生的cgi和http.server两个库运行的一个简单的http服务器程序
<ul>
<li>因为没有使用第三方库，所有不需要使用pip安装依赖</li>
<li>运行比较简单</li>
<li>公共网关接口（Common Gateway Interface，CGI）是Web 服务器运行时外部程序的规范，按 CGI 编写的程序可以扩展服务器功能</li>
</ul></li>
</ul>
<a id="more"></a>
<h2 id="讲解代码">讲解代码</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> cgi</span><br><span class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> HTTPServer, BaseHTTPRequestHandler</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHTTPRequestHandler</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></span><br><span class="line">    field_name = <span class="string">'a'</span></span><br><span class="line">    form_html = \</span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        &lt;html&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;form method='post' enctype='multipart/form-data'&gt;</span></span><br><span class="line"><span class="string">        &lt;input type='text' name='%s'&gt;</span></span><br><span class="line"><span class="string">        &lt;input type='submit'&gt;</span></span><br><span class="line"><span class="string">        &lt;/form&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;</span></span><br><span class="line"><span class="string">        &lt;/html&gt;</span></span><br><span class="line"><span class="string">        '''</span> % field_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_GET</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.send_header(<span class="string">"Content-type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            file = open(<span class="string">"."</span>+self.path, <span class="string">"rb"</span>)</span><br><span class="line">        <span class="keyword">except</span> FileNotFoundError <span class="keyword">as</span> e:</span><br><span class="line">            print(e)</span><br><span class="line">            self.wfile.write(self.form_html.encode())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            content = file.read()</span><br><span class="line">            self.wfile.write(content)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_POST</span><span class="params">(self)</span>:</span></span><br><span class="line">        form_data = cgi.FieldStorage(</span><br><span class="line">            fp=self.rfile,</span><br><span class="line">            headers=self.headers,</span><br><span class="line">            environ=&#123;</span><br><span class="line">                <span class="string">'REQUEST_METHOD'</span>: <span class="string">'POST'</span>,</span><br><span class="line">                <span class="string">'CONTENT_TYPE'</span>: self.headers[<span class="string">'Content-Type'</span>],</span><br><span class="line">            &#125;)</span><br><span class="line">        fields = form_data.keys()</span><br><span class="line">        <span class="keyword">if</span> self.field_name <span class="keyword">in</span> fields:</span><br><span class="line">            input_data = form_data[self.field_name].value</span><br><span class="line">            file = open(<span class="string">"."</span>+self.path, <span class="string">"wb"</span>)</span><br><span class="line">            file.write(input_data.encode())</span><br><span class="line"></span><br><span class="line">        self.send_response(<span class="number">200</span>)</span><br><span class="line">        self.send_header(<span class="string">"Content-type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">        self.end_headers()</span><br><span class="line">        self.wfile.write(<span class="string">b"&lt;html&gt;&lt;body&gt;OK&lt;/body&gt;&lt;/html&gt;"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHTTPServer</span><span class="params">(HTTPServer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, port)</span>:</span></span><br><span class="line">        print(<span class="string">"run app server by python!"</span>)</span><br><span class="line">        HTTPServer.__init__(self,  (host, port), MyHTTPRequestHandler)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">'__main__'</span> == __name__:</span><br><span class="line">    server_ip = <span class="string">"0.0.0.0"</span></span><br><span class="line">    server_port = <span class="number">8080</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">2</span>:</span><br><span class="line">        server_port = int(sys.argv[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">3</span>:</span><br><span class="line">        server_ip = sys.argv[<span class="number">1</span>]</span><br><span class="line">        server_port = int(sys.argv[<span class="number">2</span>])</span><br><span class="line">    print(<span class="string">"App server is running on http://%s:%s "</span> % (server_ip, server_port))</span><br><span class="line"></span><br><span class="line">    server = MyHTTPServer(server_ip, server_port)</span><br><span class="line">    server.serve_forever()</span><br></pre></td></tr></table></figure>
<h3 id="运行代码">运行代码</h3>
<ul>
<li><p>使用<code>python httpserver.py</code>或者<code>py httpserver.py</code></p>
<ul>
<li><p>使用vscode调试代码，在同目录下会自动生成一个<code>.vscode</code>的目录，目录下生成<code>launch.json</code>文件，配置如下</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Python: 当前文件"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"python"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;file&#125;"</span>,</span><br><span class="line">            <span class="attr">"console"</span>: <span class="string">"integratedTerminal"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>在浏览器的访问网址为<code>127.0.0.1:8080/a.html</code></p>
<p><img src="a-html.png" width=50%></p></li>
</ul>
<h3 id="主要的父类与子类">主要的父类与子类</h3>
<h4 id="http-methods">http methods</h4>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">http请求下的多种methods</a>
<ul>
<li>通常使用得最多的，是 GET 和 POST</li>
<li>直接在浏览器中输入链接，浏览器拿到地址以后，默认是采用 GET 方式向服务器发送请求，GET 方式最常见。</li>
<li>表单使用的 post 方法提交数据 <code>&lt;form method='post' enctype='multipart/form-data'&gt;</code></li>
<li>通常来说，从服务器获取数据，使用 get 方法，向服务器提交数据，使用 post 方法</li>
<li>其他的方法，在现在的web应用程序中，用到的很少</li>
</ul></li>
</ul>
<h4 id="myhttpserver类">MyHTTPServer类</h4>
<ul>
<li><p>MyHTTPServer类，是继承自原生的HTTPServer，重写 init 函数，增加了打印输出语言</p></li>
<li><p>然后直接调用父类 HTTPServer 的 init 函数传递了服务器运行需要的地址、端口等参数，我们的监听地址和端口是 0.0.0.0:8080</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHTTPServer</span><span class="params">(HTTPServer)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, host, port)</span>:</span></span><br><span class="line">        print(<span class="string">"run app server by python!"</span>)</span><br><span class="line">        HTTPServer.__init__(self,  (host, port), MyHTTPRequestHandler)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="myhttprequesthandler">MyHTTPRequestHandler</h4>
<ul>
<li>MyHTTPRequestHandler 类，这个是 HTTPServer 的回调，用来处理到达的请求，也就是 0.0.0.0:8080 上有任何的 HTTP 请求到达时，都会调用 MyHTTPRequestHandler来处理
<ul>
<li>MyHTTPRequestHandler 直接继承自 BaseHTTPRequestHandler</li>
<li>重写了父类的 do_GET和do_POST两个方法</li>
<li>这个HTTP请求的处理类是整个代码的主体，也是出问题的地方</li>
<li>在 python 的 BaseHTTPRequestHandler 类中 ，do_XXX函数，就是处理对应的客户端请求的函数。代码指定了 MyHTTPRequestHandler 来处理 http 请求，那么当用 GET 方法请求，就会调用 do_GET，POST 方法请求，就会调用 do_POST函数</li>
<li>浏览器所发送的数据包里包括请求类型， 在 http 的 headers里，会说明方法。</li>
<li>这是python最基本的http 服务器的方式</li>
</ul></li>
</ul>
<h3 id="其他处理">其他处理</h3>
<ul>
<li>通常，一个静态的http服务器，这里的路径就是 http 服务器根目录下的文件，动态服务器可能是文件和参数，或者是对应其他服务器后台的处理过程
<ul>
<li>self.path 是这个请求的路径</li>
<li>例如 http://127.0.0.1:8080/a.html 。其中 http://127.0.0.1:8080是协议服务器地址和端口。/a.html就是路径</li>
<li>例如 http://127.0.0.1:8080/a.php?p1=x 。指定由 a.php 来处理这个请求，参数是 p1=x 。问号后面是参数，可以有多个</li>
</ul></li>
<li>一般来说，如果读的文件不存在，应该返回404
<ul>
<li>self.send_response(200) 按照协议应该是404</li>
<li>则这里的处理为 如果指定的文件不存在，还是返回200，表示请求路径是正确的，可以处理，然后返回一个默认的页面。这个页面是 form_html的变量，在FileNotFoundError异常处理过程中写回</li>
<li>self.wfile 和 self.rfile 对应 http 响应和请求的 body 部分</li>
</ul></li>
<li>GET处理完成以后，浏览器就拿到了 200 状态的 "Content-type" 为 "text/html" 的 form_html</li>
<li>在浏览器刷新是重复上一次的POST请求，所以会提示是否要重新提交表单</li>
</ul>
<h3 id="调试运行">调试运行</h3>
<ul>
<li>在 def do_GET 下断点，刷新浏览器，代码就会断点命中中断。</li>
<li>结合浏览器，抓包看看 http 请求和响应的数据格式 （用抓包器或者浏览器的调试模式观察）</li>
</ul>
<h4 id="浏览器调试模式">浏览器调试模式</h4>
<ul>
<li><p>打开浏览器的调试模式(chrome &gt; 菜单 &gt; 更多工具 &gt; 开发者工具)</p></li>
<li><p>在sources这个标签下看到服务器向浏览器返回的数据，即 form_html 变量</p>
<ul>
<li><p>这一段 html 浏览器渲染出来，就是那个带一个编辑框的表单- 表单指定了使用post方式向服务器提交数据</p>
<p><img src="sourcetab.png"></p></li>
</ul></li>
<li><p>在network tab里可以看到完整的请求响应过程</p>
<p><img src="networktab.png"></p>
<ul>
<li><p>完整的网络数据，其中 header 里就说了 GET 或者 POST 、返回的状态码200等等</p>
<p><img src="headers.png"></p></li>
</ul></li>
<li><p>在表单中填入数据，点提交按钮，然后服务器的 do_POST 函数被调用。通过 cgi.FieldStorage解析了客户端提交的请求，原始的请求的头部在self.headers。body部分在self.rfile。解析完成以后放到 form_data变量里，其中 form_data['field_name'].value 是在编辑框中填入的数据 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">form_data = cgi.FieldStorage(</span><br><span class="line">          fp=self.rfile,</span><br><span class="line">          headers=self.headers,</span><br><span class="line">          environ=&#123;</span><br><span class="line">              <span class="string">'REQUEST_METHOD'</span>: <span class="string">'POST'</span>,</span><br><span class="line">              <span class="string">'CONTENT_TYPE'</span>: self.headers[<span class="string">'Content-Type'</span>],</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h3 id="使用场景">使用场景</h3>
<ul>
<li><p>通常，一个服务器会根据业务逻辑处理用户提交的数据，比如用户发表的商品评论，比如在线教学系统中填入的作业一般会写入数据库。但是这些数据，在某些情况下又会被显示出来，比如其他用户查看别人的商品评论的时候，比如老师查看学生的作业时。</p></li>
<li><p>为了模拟这个过程，简化了一下，没有用户系统，也没有数据库，直接写入了 path 对应的文件。</p></li>
<li><p>处理用户提交，写入文件 <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">fields = form_data.keys()</span><br><span class="line"><span class="keyword">if</span> self.field_name <span class="keyword">in</span> fields:</span><br><span class="line">    input_data = form_data[self.field_name].value</span><br><span class="line">    file = open(<span class="string">"."</span>+self.path, <span class="string">"wb"</span>)</span><br><span class="line">    file.write(input_data.encode())</span><br></pre></td></tr></table></figure></p>
<ul>
<li>fields = form_data.keys()是获取表单中的键值对，因此使用.value得到输入的值：这里获得是对应的是form中input的name <code>&lt;input type='text' name='%s'&gt;</code></li>
<li>表单以变量名变量值的方式组织，input的name相当于变量名，填入的数据就是变量值</li>
<li>python的cgi.FieldStorage将form组织为python的dict数据类型，所以可以通过 form_data['field_name'].value 获得所填入的数据</li>
</ul></li>
<li><p>如果写入成功，就返回一个 200 状态的 OK <figure class="highlight py"><table><tr><td class="code"><pre><span class="line">  self.send_response(<span class="number">200</span>)</span><br><span class="line">  self.send_header(<span class="string">"Content-type"</span>, <span class="string">"text/html"</span>)</span><br><span class="line">  self.end_headers()</span><br><span class="line">  self.wfile.write(<span class="string">b"&lt;html&gt;&lt;body&gt;OK&lt;/body&gt;&lt;/html&gt;"</span>)</span><br><span class="line">  ``` </span><br><span class="line"></span><br><span class="line"><span class="comment">## 漏洞</span></span><br><span class="line"></span><br><span class="line">- 如果向网页中填入了 <span class="number">123</span> ，那么<span class="number">123</span>被写入了a.html文件。执行完成后，同目录下会多一个a.html，内容为<span class="number">123</span>。然后下次再访问 http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8080</span>/a.html 时，在浏览器地址栏里回车。由于这个时候a.html已经存在了，所以是运行的部分是</span><br><span class="line">  ```py</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">      content = file.read()</span><br><span class="line">      self.wfile.write(content)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>会直接把文件内容会写给浏览器</li>
<li>这里是在简化模拟用户提交数据 &gt; 存入数据 &gt; 其他用户获取这个数据的过程</li>
</ul>
<p><img src="httpserver1.gif"></p></li>
<li><p>XSS漏洞</p>
<ul>
<li><p>再访问一个不存在的页面，比如b.html，又会出现那个默认的form。这时输入<code>&lt;html&gt;&lt;body&gt;&lt;script&gt;alert('XSS')&lt;/script&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code>，然后在访问b.html的时候，整个页面被载入 script 在浏览器上执行，也就是<strong>用户提交的数据被执行了</strong></p>
<p><img src="httpserver-xss.gif"></p></li>
<li><p>重新开一个页面，在c.html中填入<code>&lt;html&gt;&lt;body&gt;&lt;script&gt;window.location.href='http://by.cuc.edu.cn'&lt;/script&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code>。下次再访问c.html的时候。页面跳转了。<code>window.location.href='http://by.cuc.edu.cn'</code> 这段脚本的功能是实现了跳转</p></li>
</ul></li>
<li><p>理论上，任何的js都是可以被执行的。js可以实现非常丰富的功能。比如可以骗取用户扫码、支付，实际到黑客的账户。如果是没有基本防御措施的网站，这段会被放进服务器数据库里，然后别人提交了数据就自动跳转到这个网站。比如有一个商品A，用户在评论里输入了一段js代码。如果服务器不做处理直接保存。后面的用户访问商品A、看评论，前一个用户输入的代码就会在其他用户的页面上执行。</p></li>
</ul>
<h3 id="furthermore">Furthermore</h3>
<ul>
<li><p>如果大家在浏览器中访问 http://127.0.0.1:8080/httpserver.py ，则在sources中显示全部完整的源代码。由于服务器没有做任何过滤，只要是存在的文件，就发送给客户端</p>
<ul>
<li>现在黑客可以知道我整个后台的逻辑了。</li>
<li>如果还有一些配置文件，比如数据库地址和访问口令等。那就更严重了</li>
<li>更严重的是，黑客甚至可以注入后端代码。由于我们是回写到文件，可以构造一个http post请求，把httpserver.py文件改写了。但是构造这个请求用浏览器就不行了，需要采用curl等更基础的工具裸写post请求发送给服务器的</li>
</ul></li>
<li><p>在调试工具的 elements tab，由于后台只处理名为a的表单项写入文件，所以我们需要把input的把 name="%s" 改为 name="a" 再提交。改为以后，同时在提交框中输入‘hahaha’提交。此时httpserver.py，它变为'hahaha'，只是注入一个hahaha 服务器就挂了，再也跑不起来了。</p>
<p><img src="httpserver-xss3.gif"></p></li>
<li><p>所以，这是一个及其简单，但是漏洞百出的web服务器。这就是不做任何过滤，直接写入数据的危害。</p></li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods">http methods</a></li>
</ul>
]]></content>
      <tags>
        <tag>xss</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>软件安全概述</title>
    <url>/2020/06/09/Software-Security/</url>
    <content><![CDATA[<h1 id="三大软件安全问题">三大软件安全问题</h1>
<h2 id="有什么安全问题安全问题产生的原因">有什么安全问题，安全问题产生的原因</h2>
<h3 id="二进制方面">二进制方面</h3>
<ol type="1">
<li>内存相关问题
<ul>
<li>有明确的机制</li>
<li>例子：<strong>缓冲区溢出</strong>，空指针，格式化字符串</li>
</ul></li>
<li>逻辑错误问题
<ul>
<li>多种多样</li>
</ul></li>
</ol>
<h3 id="web方面">Web方面</h3>
<ol type="1">
<li>典型安全问题
<ul>
<li><strong>XSS</strong>，<strong>SQL</strong>注入</li>
</ul></li>
<li>非典型安全问题：很多
<ul>
<li>主要是一些代码的逻辑错误，每个漏洞都可能有不同的原理</li>
</ul></li>
</ol>
<a id="more"></a>
<h2 id="如何去发现问题-安全漏洞---漏洞挖掘技术">如何去发现<del>问题</del> (安全漏洞) -&gt; 漏洞挖掘技术</h2>
<h3 id="白盒分析">白盒分析</h3>
<ul>
<li>分析<strong>软件的源代码</strong>去寻找问题</li>
<li>方法
<ul>
<li>手工代码分析 -&gt; 软件测试技术 / 代码review。但是软件的源代码通常比较庞大，手工分析起来很费劲</li>
<li>自动化代码分析 -&gt; 典型的技术：符号执行</li>
</ul></li>
</ul>
<h3 id="黑盒分析">黑盒分析</h3>
<ul>
<li>因为白盒分析数据量大，需投入很多人工，人们寻求简单方法，和白盒分析对立的黑盒发展</li>
<li>原理：完全不管软件的内部机理 / 不看源码，把需要分析的软件当做一个黑盒子，看不见 / 根本不去看内部</li>
<li>方法：分析<strong>表面现象</strong>
<ul>
<li>软件：通过输入和输出去猜测内部机制</li>
<li>黑盒分析法，Fuzzing技术(模糊测试)</li>
</ul></li>
</ul>
<h2 id="如果有人利用这这些安全问题如何防御">如果有人利用这这些安全问题，如何防御</h2>
<h3 id="补丁">补丁</h3>
<ul>
<li>由于软件复杂性，要发现问题及时修补</li>
<li>方法
<ul>
<li>通过<strong>漏洞数据库</strong>来披露和管理各种漏洞，厂家有义务定期发布软件补丁或者更新</li>
<li>软件用户应该<strong>及时升级</strong>软件</li>
<li>第三方人员，如果发现了安全问题，应该<strong>通报</strong>给厂家，而不是在漏洞修补以前，利用漏洞搞破坏，或者不负责任的披露漏洞</li>
</ul></li>
</ul>
<h3 id="防御机制">防御机制</h3>
<ol type="1">
<li>寻找记录攻击的痕迹，然后分析这些数据
<ul>
<li>数据的来源分为了主机层面和网络层面</li>
</ul></li>
<li>攻击者可能会做哪些方面的伪装，常用的伪装技术有哪些，如何去对抗伪装
<ul>
<li>方法：加壳脱壳技术 / Rootkit技术</li>
</ul></li>
</ol>
<h1 id="研究第一大方面缓冲区溢出和xss">研究第一大方面：缓冲区溢出和XSS</h1>
<ul>
<li>代表了<strong>二进制软件</strong>和<strong>脚本软件</strong>（包括绝大多数Web软件都是脚本软件开发的）两大技术方向</li>
<li>缓冲区溢出虽然比XSS底层，但是更难。XSS虽然比较上层，但是相对比较容易理解
<ul>
<li>计算机科学的特点就是，越底层的东西，越难</li>
<li>开发操作系统比开发app难多了</li>
</ul></li>
</ul>
<h1 id="二进制软件">二进制软件</h1>
<ul>
<li>计算机的底层，是CPU直接执行在内存中的机器指令</li>
<li>C和C++这类编程语言开发的软件，通过编译链接过程，把程序变成CPU可以直接执行的二进制指令</li>
<li>这类软件的一个特点也是不可避免的一点：需要直接操作内存(指针)
<ul>
<li>内存是所有在运行态的软件及其数据保存的地方</li>
<li>内存分为细小的单元，每个单元有一个唯一的地址</li>
</ul></li>
<li>二进制软件安全问题的根源
<ul>
<li>所有要访问数据，必须知道数据的地址，要保存新的数据，就必须分配内存，获得可用的地址</li>
<li>地址也是数，如果不小心计算错误，就会访问到不该访问的数据，造成数据的泄露或者破坏。</li>
</ul></li>
<li>二进制程序的编程，有很大的难度的原因
<ul>
<li>二进制文件晦涩难懂</li>
<li>CPU只能执行二进制指令(是基于物理上的电路)，所以不可能设计得机制太复杂</li>
</ul></li>
</ul>
<h1 id="脚本软件">脚本软件</h1>
<ul>
<li>在C和C++发展成熟以后，就有人去研究如何降低编程的难度，能否避免程序员编程时直接操作内存，把需要操作内存的地方，都封装起来，屏蔽在编程语言的内部 -&gt; 发明了脚本语言</li>
<li>概念：用C和C++这样的二进制程序开一个软件来执行一种新的程序，就是用软件来模拟CPU工作
<ul>
<li>由于软件的可定制性比CPU就高多了，可以想定义什么指令就定义什么指令</li>
<li>对象与封装：把所有需要操作内存的东西，全部封闭在执行器内部，只给程序员接口，不给程序员操作内存的机会。比如把字符串封装为string<strong>对象</strong>。只能调用string.len()这样的方法来操作这个对象。这样就避免了由于编程不慎造成的内存相关问题，也降低了编程难度</li>
</ul></li>
<li>如python、java、js、web浏览器这样的脚本程序的执行器都是二进制程序。</li>
<li>解决了内存相关问题，有引出了其他的问题
<ul>
<li>用户输入问题。比如XSS出现的原因如下：web程序存在一种高交互性。web是互联网时代的软件的基本框架，所以会有用户提交数据。为了网页动态的需求，开发了网页的前端脚本，比如js，直接把脚本嵌入到网页中。浏览器只要发现了script标签，就去当做脚本来执行，把网页按照程序员的定制，变的丰富多彩，变得富于变化。但是，恰恰另外一种需求，就是UGC(User Generated Conten 用户生成内容)软件，也就是网页的内容来自于用户提交的内容，比如BBS、博客、微博，电商视频网站的用户评论，都会涉及到用户提交的内容在页面上呈现。<strong>当用户提交的内容里含有脚本</strong>，如果直接将用户提交的内容放在页面上，那么用户提交的内容中的脚本会不会被浏览器解析执行呢？那么一个用户提交了一个脚本就可以在这个页面的所有用户主机上执行呢？用户能提交程序执行了，怎么才能不保证这个程序不是恶意的呢？前端脚本，除了渲染页面元素这样的功能，还有获得用户的输入跳转页面到其他地址等等丰富的功能。</li>
</ul></li>
</ul>
<h1 id="实验">实验</h1>
<h2 id="编写一个简单的html文件">编写一个简单的html文件</h2>
<ul>
<li><p>要求只要有一个表单，用户就可以在表单中输入数据，向服务器提交。</p>
<p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>保存为index.html文件，用浏览器打开显示如下</p>
<p><img src="indexhtml.png" width=50%></p></li>
</ul>
<h2 id="搭建一个web服务器">搭建一个web服务器</h2>
<ul>
<li>如果这个html是放在web服务器上，用户输入了数据，点击提交，浏览器就会把编辑框中的数据封装为一个POST请求，发现服务器。服务器会把这个数据发给后端脚本来处理。</li>
<li>通过定义form的属性来指明需要哪个脚本文件来处理
<ul>
<li>比如PHP程序，他有一个POST超级变量，当用户提交了数据以后，对应的php脚本的post变量就是用户提交的数据</li>
<li>假设服务器现在把用户提交的数据放在user_input.html的body标签中。然后保存在服务器文件的根目录中。当有网站的用户访问 http://xxxx.com/user_input.html 的时候，就会看到刚才那个表单用户提交的内容。当然实际的情况是这两个用户可能不是同一个用户，于是A用户提交的内容B用户就访问到了。</li>
<li>当服务器脚本是原封不动的把用户输入的数据写到html里时，如果用户提交的数据中包括<code>&lt;script&gt;标签</code>，就会被执行。比如alert函数，弹出一个消息框，<code>&lt;script&gt;alert('xss attack')&lt;/script&gt;</code>；比如给window.location.href赋值，能让用户莫名其妙的跳转到另外一个网站</li>
</ul></li>
<li>最简单的实验环境
<ul>
<li>在vscode中，安装一个php插件，然后编写一个简单的php脚本，调试运行这个脚本</li>
<li>F5 vscode会自动选择脚本运行的方式，把用户的表单输入写入到html文件</li>
<li>通过浏览器访问这个文件html文件，这就是一个最简单的xss运行环境了。</li>
</ul></li>
<li>实际的XSS漏洞可能很复杂，比如还会有数据库、登录等。另外，编程语言也不限于php，java、python也可以</li>
</ul>
<h2 id="问题">问题</h2>
<ul>
<li>当编写的代码中出现中文，在网页上显示乱码
<ul>
<li>编码问题，head标签里通过meta指定</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Security</category>
      </categories>
      <tags>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>NoSQL数据库系统Hadoop-Hbase安装配置(伪分布模式)与简单使用</title>
    <url>/2020/05/15/Hadoop-Hbase/</url>
    <content><![CDATA[<style>
  /* 设置整个页面的字体 */
  html, body, .markdown-body {
    font-family: Georgia, sans, serif;
    font-size: 15px;
  }

  /* 只设置 markdown 字体 */
  .markdown-body {
    font-family: Georgia, sans, serif;
    font-size: 15px;
  }
</style>
<ul>
<li>Hbase是一种NoSQL数据库，这意味着它不像传统的RDBMS(关系数据库管理系统 Relational Database Management System)数据库那样支持SQL作为查询语言</li>
<li>Hbase是一种分布式存储的数据库，技术上来讲，它更像是分布式存储而不是分布式数据库</li>
<li>数据库量要足够多，如果有十亿及百亿行数据，那么Hbase是一个很好的选项，如果只有几百万行甚至不到的数据量，RDBMS是一个很好的选择。因为数据量小的话，真正能工作的机器量少，剩余的机器都处于空闲的状态</li>
<li>保证硬件资源足够，每个HDFS集群在少于5个节点的时候，都不能表现的很好。因为HDFS默认的复制数量是3，再加上一个NameNode</li>
</ul>
<a id="more"></a>
<h2 id="实验环境">实验环境</h2>
<ul>
<li>VMware Workstation Pro 12</li>
<li>系统为Ubuntu 16.04 Server的Linux虚拟机</li>
<li><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">jdk-8u201-linux-x64.tar.gz</a>，<a href="https://www.oracle.com/webfolder/s/digest/8u201checksum.html">校验和</a></li>
<li><a href="http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.1.2/hadoop-3.1.2.tar.gz">hadoop-3.1.2.tar.gz</a>，<a href="https://archive.apache.org/dist/hadoop/common/hadoop-3.1.2/hadoop-3.1.2.tar.gz.mds">校验和</a></li>
<li>hbase-1.2.11-bin.tar.gz，<a href="https://archive.apache.org/dist/hbase/hbase-1.2.11/hbase-1.2.11-bin.tar.gz.sha512">校验和</a></li>
<li><a href="https://hadoop.apache.org/docs/r3.2.0/hadoop-project-dist/hadoop-common/SingleCluster.html">官方教程1</a>、<a href="https://hbase.apache.org/book.html">官方教程2</a></li>
</ul>
<h2 id="hbase结构">HBase结构</h2>
<p><img src="hbase-construction.webp"></p>
<h2 id="实验过程">实验过程</h2>
<h3 id="准备阶段">准备阶段</h3>
<h4 id="创建实验用户hadoop">创建实验用户hadoop</h4>
<ul>
<li><p>[再已配置mysql cluster的基础上] 可以采用已有的mysql用户，给mysql用户做相应管理员权限赋权，后续需要用到用户名hadoop的时候，使用mysql</p></li>
<li><p>此处选择新创建hadoop用户</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo useradd -m hadoop -s &#x2F;bin&#x2F;bash  #创建hadoop用户，并使用&#x2F;bin&#x2F;bash作为shell</span><br><span class="line">$ sudo passwd hadoop  #为hadoop用户设置密码，之后需要连续输入两次密码</span><br><span class="line">$ sudo adduser hadoop sudo #为hadoop用户增加管理员权限</span><br><span class="line">$ su - hadoop            #切换当前用户为用户hadoop</span><br><span class="line">$ sudo apt-get update    #更新hadoop用户的apt,方便后面的安装</span><br></pre></td></tr></table></figure>
<p><img src="adduserhadoop.png"></p></li>
</ul>
<h4 id="ssh配置免密登录">SSH配置免密登录</h4>
<ul>
<li><p>安装SSH，设置SSH无密码登陆</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install openssh-server   #安装SSH server</span><br><span class="line">$ ssh localhost         #登陆SSH，第一次登陆输入yes</span><br><span class="line">$ exit                  #退出登录的ssh localhost</span><br></pre></td></tr></table></figure></p>
<p><img src="ssh-install.png" width=70%></p></li>
<li><p>生成密钥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~&#x2F;.ssh&#x2F;                            #如果没法进入该目录，执行一次ssh localhost</span><br><span class="line">$ ssh-keygen -t rsa　　</span><br><span class="line"># 需要连续敲击三次回车</span><br><span class="line"># 第一次回车是让KEY存于默认位置，以方便后续的命令输入</span><br><span class="line"># 第二次和第三次是确定passphrase，相关性不大</span><br></pre></td></tr></table></figure>
<p><img src="ssh-keygen.png" width=70%></p></li>
<li><p>加入授权，免密登录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .&#x2F;id_rsa.pub &gt;&gt; .&#x2F;authorized_keys  #加入授权</span><br><span class="line">$ ssh localhost  #此时已不需密码即可登录localhost</span><br></pre></td></tr></table></figure>
<p><img src="ssh-authorizedkeys.png" width=70%></p></li>
</ul>
<h3 id="安装jdk1.8">安装jdk1.8</h3>
<ul>
<li><p>在<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html">oracle官网</a>下载jdk1.8，根据个人电脑系统选择对应版本，如<code>jdk-8u201-linux-x64.tar.gz</code></p></li>
<li><p>安装过程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir &#x2F;usr&#x2F;lib&#x2F;jvm  #创建jvm文件夹</span><br><span class="line">$ sudo tar zxvf  jdk-8u201-linux-x64.tar.gz  -C &#x2F;usr&#x2F;lib&#x2F;jvm  #&#x2F; 解压到&#x2F;usr&#x2F;lib&#x2F;jvm目录下</span><br><span class="line">$ cd &#x2F;usr&#x2F;lib&#x2F;jvm  #进入该目录</span><br><span class="line">$ mv  jdk1.8.0_201 java  #重命名为java</span><br><span class="line">$ vi ~&#x2F;.bashrc  #给JDK配置环境变量</span><br></pre></td></tr></table></figure></li>
<li><p>编辑环境变量<code>vi ~/.bashrc</code>，在<code>.bashrc</code>文件添加如下指令： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib:$CLASSPATH</span><br><span class="line">export PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure></p>
<p><img src="javaenrpath.png"></p>
<ul>
<li>JAVA_HOME=/usr/lib/jvm/java</li>
</ul></li>
<li><p>使得环境变量生效，并查看是否安装成功 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ source ~&#x2F;.bashrc  #使新配置的环境变量生效</span><br><span class="line">$ java -version  #检测是否安装成功，查看java版本</span><br></pre></td></tr></table></figure></p>
<p><img src="javainstallsuccess.png"></p></li>
</ul>
<h3 id="安装hadoop-3.1.2">安装hadoop-3.1.2</h3>
<ul>
<li>下载<a href="http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.1.2/hadoop-3.1.2.tar.gz">hadoop-3.1.2.tar.gz</a>并安装 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo tar -zxvf  hadoop-3.1.2.tar.gz  -C  &#x2F;usr&#x2F;local  #解压到&#x2F;usr&#x2F;local目录下</span><br><span class="line">$ cd &#x2F;usr&#x2F;local</span><br><span class="line">$ sudo mv  hadoop-3.1.2 hadoop  #重命名为hadoop</span><br><span class="line">$ sudo chown -R hadoop .&#x2F;hadoop  #修改文件权限，根据实际情况确定用户名</span><br></pre></td></tr></table></figure></li>
<li>配置环境变量，将下面代码添加到<code>.bashrc</code>文件: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export HADOOP_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;hadoop</span><br><span class="line">export HADOOP_COMMON_LIB_NATIVE_DIR&#x3D;$HADOOP_HOME&#x2F;lib&#x2F;native</span><br><span class="line">export PATH&#x3D;$PATH:$HADOOP_HOME&#x2F;bin:$HADOOP_HOME&#x2F;sbin</span><br></pre></td></tr></table></figure></li>
<li>执行<code>source ~/.bashrc</code>使设置生效，并查看<code>hadoop</code>是否安装成功 <img src="hadoopinstallsuccess.png"></li>
</ul>
<h3 id="伪分布配置">伪分布配置</h3>
<ul>
<li><code>Hadoop</code>可以在单节点上以伪分布式的方式运行，<code>Hadoop</code>进程以分离的<code>Java</code>进程来运行，节点既作为<code>NameNode</code>也作为 <code>DataNode</code>，同时，读取的是<code>HDFS</code>中的文件</li>
<li><code>Hadoop</code>的配置文件位于<code>/usr/local/hadoop/etc/hadoop/</code>中，伪分布式需要修改2个配置文件<code>core-site.xml</code>和<code>hdfs-site.xml</code></li>
<li><code>Hadoop</code>的配置文件是<code>xml</code>格式，每个配置以声明<code>property</code> 的<code>name</code>和<code>value</code>的方式来实现</li>
</ul>
<h4 id="修改hadoop-env.sh文件">修改hadoop-env.sh文件</h4>
<ul>
<li><p>首先将jdk1.8的路径添(<code>export JAVA_HOME=/usr/lib/jvm/java</code>)加到<code>hadoop-env.sh</code>文件，路径为<code>cd /usr/local/hadoop/etc/hadoop/</code></p>
<p><img src="hadoopenv.png" width=70%></p></li>
</ul>
<h4 id="修改core-site.xml文件">修改core-site.xml文件</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  	      <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">description</span>&gt;</span>Abase for other temporary directories.<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="core-site.png"></p>
<h4 id="配置hdfs-site.xml文件">配置hdfs-site.xml文件</h4>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/tmp/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="hdfs-site.png"></p>
<ul>
<li><p><code>Hadoop</code>配置文件参数</p>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 46%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>参数</th>
<th>属性值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>fs.defaultFS</td>
<td>NameNode URI The name of the default file system. A URI whose scheme and authority determine the FileSystem implementation. The uri's scheme determines the config property (fs.SCHEME.impl) naming the FileSystem implementation class. The uri's authority is used to determine the host, port, etc. for a filesystem.</td>
<td>hdfs://host:port/</td>
</tr>
<tr class="even">
<td>dfs.namenode.name.dir</td>
<td>Determines where on the local filesystem the DFS name node should store the name table(fsimage) 在本地文件系统所在的NameNode的存储空间和持续化处理日志</td>
<td>如果这是一个以逗号分隔的目录列表，然后将名称表被复制的所有目录，以备不时需</td>
</tr>
<tr class="odd">
<td>dfs.datanode.data.dir</td>
<td>Determines where on the local filesystem an DFS data node should store its blocks 逗号分隔的一个DataNode上，它应该保存它的块的本地文件系统的路径列表</td>
<td>如果这是一个以逗号分隔的目录列表，那么数据将被存储在所有命名的目录，通常在不同的设备</td>
</tr>
</tbody>
</table></li>
<li><p><code>Hadoop</code>的运行方式是由配置文件决定的(运行<code>Hadoop</code>时会读取配置文件)</p></li>
<li><p>因此如果需要从伪分布式模式切换回非分布式模式，需要删除 <code>core-site.xml</code>中的配置项</p></li>
<li><p>伪分布式虽然只需要配置<code>fs.defaultFS</code>和<code>dfs.replication</code>就可以运行（可参考官方教程）</p></li>
<li><p>若没有配置<code>hadoop.tmp.dir</code>参数，则默认使用的临时目录为 <code>/tmp/hadoo-hadoop</code>，而这个目录在重启时有可能被系统清理掉，导致必须重新执行<code>format</code>。所以同时也指定<code>dfs.namenode.name.dir</code>和<code>dfs.datanode.data.dir</code>，否则在接下来的步骤中可能会出错。</p></li>
<li><p>配置完成后，执行 NameNode 的格式化 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;hadoop&#x2F;</span><br><span class="line">.&#x2F;bin&#x2F;hdfs namenode –format</span><br></pre></td></tr></table></figure></p>
<p><img src="namenode-format.png"></p>
<p><img src="format-success.png"></p></li>
<li><p>启动<code>namenode</code>和<code>datanode</code>进程，并查看启动结果 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;sbin&#x2F;start-dfs.sh</span><br><span class="line">$ jps</span><br></pre></td></tr></table></figure></p>
<ul>
<li>启动完成后，可以通过命令<code>jps</code>来判断是否成功启动，若成功启动则会列出如下进程: <code>NameNode</code>、<code>DataNode</code> 和 <code>SecondaryNameNode</code> <img src="start-namenode-datanode.png"></li>
</ul></li>
<li><p>Hadoop出现错误：<code>WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</code>，解决方案是在文件<code>hadoop-env.sh</code>中增加：<code>export HADOOP_OPTS="-Djava.library.path=${HADOOP_HOME}/lib/native"</code></p>
<p><img src="hadoop-warn.png"></p></li>
<li><p>出现<code>ssh: connect to host master port 22: Connection timed out</code></p>
<p><img src="hdfs-ssh-timeout.png"></p>
<ul>
<li><a href="https://www.itread01.com/content/1548390616.html">解决方法：</a>
<ul>
<li><p>查看防火墙</p></li>
<li><p>查看ssh是否开启，22端口是否监听</p></li>
<li><p><code>sudo vi /etc/hosts</code></p>
<p><img src="etc-host.png"></p>
<ul>
<li>127.0.0.1和127.0.1.1都是本地回路/回环地址（区别搜索）</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>有可能出现要求输入localhost密码的情况，如果此时明明输入的是正确的密码却仍无法登入，其原因是由于如果不输入用户名的时候默认的是root用户，但是ssh服务默认没有开root用户的ssh权限</p>
<ul>
<li>输入指令：<code>$vim /etc/ssh/sshd_config</code></li>
<li>PermitRootLogin yes</li>
<li>之后输入下列代码重启SSH服务：<code>$ /etc/init.d/sshd restart</code>，即可正常登入（免密码登录参考前文）</li>
<li>注：Ubuntu 16.04若安装openssh-server，是无法找到/etc/init.d/sshd文件的，但是可以启动/etc/init.d/ssh</li>
</ul></li>
<li><p><a href="https://blog.csdn.net/sinat_19628145/article/details/56494337">secondarynamenode没有启动</a></p></li>
<li><p><a href="https://blog.csdn.net/weixin_38750084/article/details/82856211">NameNode和SecondaryNameNode的区别</a></p></li>
</ul>
<h4 id="访问web界面">访问web界面</h4>
<ul>
<li><p>成功启动后，如果是在桌面版linux上安装的，也可以访问 Web 界面 http://localhost:9870（老版本为50070） 查看NameNode 和 Datanode 信息，还可以在线查看 HDFS 中的文件。</p></li>
<li><p>如果是在服务器版linux上安装的hadoop, 为了进行浏览器访问，需要配置一个桌面版的虚拟机来进行，输入用IP地址代替localhost）</p></li>
<li><p>此处配置了静态ip地址为<code>192.18.50.129</code>，在宿主机上输入<code>http://192.168.50.129:9870</code></p>
<p><img src="hadoopweb.png"></p></li>
</ul>
<h4 id="注意">注意</h4>
<ul>
<li>DFS文件系统格式化时，会在namenode数据文件夹（即配置文件中dfs.namenode.name.dir在本地系统的路径）中保存一个current/VERSION文件，记录clusterID，标识了所格式化的 namenode的版本</li>
<li>如果频繁的格式化namenode，那么datanode中保存（即配置文件中dfs.data.dir在本地系统的路径）的current/VERSION文件只是你第一次格式化时保存的namenode的ID，因此就会造成datanode与namenode之间的 id 不一致。可能导致datanode无法启动</li>
</ul>
<h4 id="例子">例子</h4>
<ul>
<li><p>创建执行MapReduce作业所需的 DFS 目录: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;hdfs dfs -mkdir &#x2F;user</span><br><span class="line">$ bin&#x2F;hdfs dfs -mkdir &#x2F;user&#x2F;&lt;username&gt;  #&lt;username&gt; 问用户名，如hadoop</span><br></pre></td></tr></table></figure></p></li>
<li><p>拷贝输入文件到分布式文件系统: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ bin&#x2F;hdfs dfs -put etc&#x2F;hadoop input</span><br></pre></td></tr></table></figure></p></li>
<li><p>运行一些例子 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;hadoop jar share&#x2F;hadoop&#x2F;mapreduce&#x2F;hadoop-mapreduce-examples-3.2.1.jar grep input output &#39;dfs[a-z.]+&#39;</span><br></pre></td></tr></table></figure></p></li>
<li><p>查看输出的文件(files): 从分布式文件系统中拷贝文件到本地文件系统并查看: <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;hdfs dfs -get output output</span><br><span class="line">cat output&#x2F;*</span><br></pre></td></tr></table></figure> 或者直接在分布式文件系统上查看:</p>
<p><code>$ bin/hdfs dfs -cat output/*</code></p>
<p>我也不知道对不对</p>
<p><img src="mapreduce-output.png"></p></li>
<li><p>结束运行<code>sbin/stop-dfs.sh</code></p></li>
</ul>
<h4 id="yarn单机配置">YARN单机配置</h4>
<ul>
<li><p>通过设置几个参数并运行ResourceManager daemon and NodeManager daemon，可以在YARN上以伪分布模式运行MapReduce job</p>
<p>配置mapred-site.xml(cd /usr/local/hadoop/etc/hadoop)如下:</p>
<p><img src="mapred-site.png"></p>
<p>配置yarn-site.xml如下：</p>
<p><img src="yarn-site.png"></p></li>
<li><p>启动ResourceManager daemon 和 NodeManager daemon:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;hadoop</span><br><span class="line">sbin&#x2F;start-yarn.sh</span><br><span class="line"></span><br><span class="line"># 输出如下</span><br><span class="line">Starting resourcemanager</span><br><span class="line">Starting nodemanagers</span><br><span class="line"></span><br><span class="line">sbin&#x2F;stop-yarn.sh # 关闭</span><br></pre></td></tr></table></figure></li>
<li><p>如果是在桌面版linux上安装的, 可以用浏览器打开资源管理器端口，默认为：ResourceManager - http://localhost:8088/ （如果是在服务器版linux上安装的hadoop, 为了进行浏览器访问，需要配置一个桌面版的虚拟机来进行，输入用IP地址代替localhost） - 同上 <img src="start-yarn.png"></p></li>
</ul>
<h3 id="安装hbase和简单使用">安装Hbase和简单使用</h3>
<h4 id="安装">安装</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 解压安装包hbase-1.2.11-bin.tar.gz至路径 &#x2F;usr&#x2F;local</span><br><span class="line">$ sudo tar -zxvf  hbase-1.2.11-bin.tar.gz -C &#x2F;usr&#x2F;local</span><br><span class="line"># 将解压的文件名hbase-1.2.11改为hbase，以方便使用</span><br><span class="line">$ sudo mv &#x2F;usr&#x2F;local&#x2F;hbase-1.2.11  &#x2F;usr&#x2F;local&#x2F;hbase</span><br><span class="line">cd &#x2F;usr&#x2F;local</span><br><span class="line">$ sudo chown -R hadoop .&#x2F;hbase  # 将hbase下的所有文件的所有者改为hadoop，hadoop是当前用户的用户名。</span><br></pre></td></tr></table></figure>
<h4 id="配置环境变量">配置环境变量</h4>
<ul>
<li><p>给hbase配置环境变量，将下面代码添加到.bashrc文件<code>:export PATH=$PATH:/usr/local/hbase</code></p>
<p><img src="hbase-env.png"></p></li>
<li><p>执行source ~/.bashrc使设置生效，并查看hbase是否安装成功<code>/usr/local/hbase/bin/hbase version</code>或者直接<code>hbase -version</code></p>
<p><img src="hbase-success.png"></p></li>
</ul>
<h4 id="hbase单机配置">hBase单机配置</h4>
<ul>
<li><p>单机配置（可能需要配置JAVA_HOME环境变量，由于本实验指南在HADOOP安装时已配置，故省略）</p></li>
<li><p>配置<code>/usr/local/hbase/conf/hbase-site.xml</code>如下</p>
<p><img src="hbase-site.png"></p></li>
<li><p>采用如下命令启动服务、查看进程和启动客户端 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &#x2F;usr&#x2F;local&#x2F;hbase</span><br><span class="line">$ bin&#x2F;start-hbase.sh</span><br><span class="line">$ jps</span><br><span class="line">$ bin&#x2F;hbase shell</span><br></pre></td></tr></table></figure></p>
<p><img src="hbase-start.png"></p></li>
</ul>
<h4 id="配置伪分布模式的指南">配置伪分布模式的指南</h4>
<ul>
<li>配置分布模式方法请查阅官方文档</li>
</ul>
<h5 id="配置hbase-env.sh">配置hbase-env.sh</h5>
<ul>
<li><p><code>cd /usr/local/hbase/conf</code>修改<code>hbase-site.xml</code>文件</p>
<p><img src="modify-hbase-site.png"></p>
<p>将HBase的数据存储到之前的Hadoop的HDFS上，hbase.rootdir的值便是HDFS上HBase数据存储的位置，值中的主机名和端口号要和之前Hadoop的core-site.xml中的fs.default.name的值相同</p></li>
<li><p>启动hBase <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 先stop-hbase.sh</span><br><span class="line">$ start-dfs.sh</span><br><span class="line">$ cd &#x2F;usr&#x2F;local&#x2F;hbase&#x2F;bin</span><br><span class="line">$ .&#x2F;start-hbase.sh</span><br></pre></td></tr></table></figure></p></li>
<li><p>hbase集群在启动的时候报错：JAVA_HOME is not set and Java could not be found出现这种错误，一般应该是hbase下conf文件下的hbase-env.sh文件中的java_home的环境变量没有配置或者是被注释了</p>
<p><img src="java_homeisnotset.png"></p>
<p>解决方法： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;hbase&#x2F;conf</span><br><span class="line">vi hbase-env.sh</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java</span><br></pre></td></tr></table></figure></p>
<p><img src="java_home.png"></p></li>
<li><p>正确顺序：启动Hadoop—&gt;启动HBase—&gt;关闭HBase—&gt;关闭Hadoop</p></li>
<li><p>注：执行jps命令，如果在Hadoop进程的基础上新增加了如下三个进程则表示HBase启动成功：1. HMaster，2. HRegionServer，3. HQuorumpeer</p></li>
</ul>
<h5 id="查看dfs中hbase-目录自动创建">查看DFS中Hbase 目录，自动创建</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">hdfs dfs -ls &#x2F;hbase</span><br></pre></td></tr></table></figure>
<blockquote>
<p>hadoop@zizi:~$ hdfs dfs -ls /hbase ls: Call From zizi/127.0.1.1 to localhost:9000 failed on connection exception: java.net.ConnectException: Connection refused; For more details see: http://wiki.apache.org/hadoop/ConnectionRefused 该问题一般由于没有start dfs 和 yarn造成的</p>
</blockquote>
<p><img src="hdfs-dfs.png"></p>
<ul>
<li><p>仅仅为了测试和学习，生产环境不会在一台机器上启动备份master</p></li>
<li><p>HMaster服务器控制HBase集群，图中的指令启动三个<strong>备份</strong>HMaster，体现了<strong>伪分布式</strong>(在一个机器上多个备份HMaster服务器)，一个HMaster没了，其他的还可以使用</p>
<p><img src="master-backup-start.png"></p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The HMaster server controls the HBase cluster. You can start up to 9 backup HMaster servers, which makes 10 total HMasters, counting the primary. </span><br><span class="line">To start a backup HMaster, use the local-master-backup.sh. </span><br><span class="line">For each backup master you want to start, add a parameter representing the port offset for that master. </span><br><span class="line">Each HMaster uses two ports (16000 and 16010 by default). </span><br><span class="line">The port offset is added to these ports, so using an offset of 2, the backup HMaster would use ports 16002 and 16012. </span><br><span class="line">The following command starts 3 backup servers using ports 16002&#x2F;16012, 16003&#x2F;16013, and 16005&#x2F;16015.</span><br></pre></td></tr></table></figure></p></li>
<li><p>如：start 1 <img src="master-backup-1.png"></p></li>
<li><p>http://192.168.50.129:16010/master-status可以访问，port=16000无法访问，port=16011可以访问</p>
<p><img src="master-status1.png"></p></li>
<li><p>启动和停止附加区域服务器RegionServers</p>
<p><img src="regionalserver.png"></p></li>
<li><p>关闭刚才开启的备份HMaster服务：<code>local-master-backup.sh stop 1</code></p></li>
</ul>
<h5 id="建表">建表</h5>
<ul>
<li><p>进入交互界面<code>$ hbase shell</code></p>
<p><img src="hbase-shell.png"></p></li>
<li><p>使用create命令创建一个新表，必须规定表名和列族名</p>
<p>使用list 命令可以显示表信息</p>
<p>使用 describe 命令显示表的详细信息，此时表中的VERSIONS默认设置为1</p>
<p><img src="create-list-describe.png"></p></li>
<li><p>向表中加入数据，使用 put 命令</p>
<p>使用scan命令扫描整个表取得数据</p>
<p>取一行数据，使用get指令</p>
<p><img src="put-scan-get.png"></p></li>
<li><p>修改表模式，使用alter命令，如修改存储版本数，为5个版本</p>
<p><img src="alter-version.png"></p></li>
</ul>
<h2 id="实验总结">实验总结</h2>
<ol type="1">
<li><p>请问伪分布和分布式的含义有何不同？就本实验，你是如何理解在一台计算机上做到“伪分布”的？</p>
<ul>
<li>伪分布式模式是一个相对简单的分布式模式，用来测试</li>
<li>不能把这个模式用于生产环节，也不能用于测试性能。</li>
<li>多个HMaster备份节点在一台机器上工作</li>
</ul></li>
<li><p>在1.2小节进行安装SSH并设置SSH无密码登陆，请问这个安装的目的是什么？ &gt; ssh must be installed and sshd must be running to use the Hadoop scripts that manage remote Hadoop daemons if the optional start and stop scripts are to be used. Additionally, it is recommmended that pdsh also be installed for better ssh resource management.</p>
<ul>
<li>ssh必须安装，sshd必须运行，Hadoop的脚本才可以远程操控其他的Hadoop和HBase进程</li>
<li>ssh之间必须都打通，远程登录、自动登录、免密登录</li>
</ul></li>
<li><p>如果继续向Hbase的test表中put行键为”row1”，值为其它字符串的数据，put 'test' ,'row1', 'cf:a', 'value6'，会发生什么？如果采用语句get 'test', 'row1', {COLUMN=&gt;'cf:a', VERSIONS=&gt;3} 进行查询，分析你得到的结果。put与关系数据库的插入有何不同？</p>
<p><img src="put.png"></p>
<ul>
<li>VERSIONS的作用
<ul>
<li>当想要用HBase存储历史几个版本的数据是（达到类似于git的效果时）可以设定版本号，版本号为几就是存储几个版本的数据</li>
<li>最开始，没有设定VERSION，则为VERSIONS为1，也就是说，默认情况只会存取一个版本的列数据，当再次插入的时候，后面的值会覆盖前面的值</li>
<li>后面修改表结构，让Hbase表支持存储5个VERSIONS的版本列数据 alter 'test', NAME=&gt;'cf',VERSIONS=&gt;5</li>
<li>解析：一开始row1只有一条数据，然后又插入了第二条数据，虽然scan 'test'只返回最新的数据，但是用get那条语句能够返回历史版本，所以返回两条数据 <img src="versions.png"></li>
</ul></li>
</ul></li>
</ol>
<h2 id="错误与解决">错误与解决</h2>
<ul>
<li>如何执行shell脚本！！！-牢记 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hadoop@zizi:&#x2F;usr&#x2F;local&#x2F;hbase&#x2F;bin$ local-master-backup.sh start 2 3 5</span><br><span class="line">local-master-backup.sh: command not found</span><br></pre></td></tr></table></figure></li>
<li><a href="https://blog.csdn.net/tiankong_12345/article/details/93585463">Hbase启动警告：Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize=128m;</a></li>
<li>hBase中get和scan的区别和总结</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.jianshu.com/p/6aeceb5d49cf">HBase入门精要-百闻不如一Run</a></li>
<li><a href="https://www.jianshu.com/p/b23800d9b227">入门HBase，看这一篇就够了</a></li>
</ul>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>Hadoop</tag>
        <tag>Hbase</tag>
      </tags>
  </entry>
  <entry>
    <title>Number Theory</title>
    <url>/2020/04/12/Number-Theory/</url>
    <content><![CDATA[<ul>
<li>质数</li>
<li>因子分解</li>
<li>欧拉降幂</li>
<li>RAS</li>
<li>拓展中国剩余定理</li>
</ul>
<a id="more"></a>
<h1 id="质数">质数</h1>
<h2 id="素数间隔-prime-gap">素数间隔-Prime gap</h2>
<ul>
<li>The first 60 prime gaps are: 1, 2, 2, 4, 2, 4, 2, 4, 6, 2, 6, 4, 2, 4, 6, 6, 2, 6, 4, 2, 6, 4, 6, 8, 4, 2, 4, 2, 4, 14, 4, 6, 2, 10, 2, 6, 6, 4, 6, 6, 2, 10, 2, 4, 2, 12, 12, 4, 2, 4, 6, 2, 10, 6, 6, 6, 2, 6, 4, 2</li>
<li>有无穷对素数，之间存在着一定的间隔。间隔从被证明为7000万以内，一直到如今的246。如果该常数改进到2，相当于证明孪生素数猜想</li>
<li>素数之间间隔可以有多远，<a href="https://en.wikipedia.org/wiki/Prime_gap">The 80 known maximal prime gaps</a></li>
</ul>
<h2 id="素数定理-prime-number-theorem">素数定理-Prime Number Theorem</h2>
<ul>
<li><p>质数分布密度，数的总数π(x)近似于x/ln(x)</p></li>
<li><p>π(2)=1，π(3.5)=2，π(10)=4</p>
<p><img src="https://cdn.britannica.com/14/77714-004-D28E8805/Prime-number-theorem.jpg" width=70%></p></li>
</ul>
<h2 id="素数筛法">素数筛法</h2>
<ul>
<li><p>求<span class="math inline">\(1\)</span>到<span class="math inline">\(n\)</span>之间内的所有素数</p>
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(sqrt(n)\)</span>的判别</td>
<td><span class="math inline">\(O(n*sqrt(n))\)</span></td>
</tr>
<tr class="even">
<td>普通筛 / 埃氏筛法</td>
<td><span class="math inline">\(O(nloglogn)\)</span></td>
</tr>
<tr class="odd">
<td>线性筛 / 欧拉筛法</td>
<td><span class="math inline">\(O(n)\)</span></td>
</tr>
</tbody>
</table></li>
</ul>
<h2 id="素数测试-miller-rabin">素数测试-Miller Rabin</h2>
<ul>
<li>哥德巴赫猜想：任何大于2的偶数都能够写成两个质数相加的形式</li>
<li>当题目给出的偶数达到<span class="math inline">\(10^{18}\)</span>，此时的质数可能非常大，用上述的筛法可能会超时，用Miller Rabin快速判断一个<span class="math inline">\(&lt;2^{63}\)</span>的数是不是素数</li>
<li>时间复杂度：<span class="math inline">\(O(klog_2(n))\)</span>，<span class="math inline">\(n\)</span>为检测的数值，<span class="math inline">\(k\)</span>为自己设定的检测的次数</li>
<li>不确定算法，单次测试有不超过<span class="math inline">\(\frac{1}{4}\)</span>的概率会将一个合数误判为一个素数</li>
</ul>
<hr />
<ul>
<li>依据
<ul>
<li><p>费马小定理：</p>
<p><span class="math inline">\(若p是质数，则对于任意0&lt;a&lt;p，\)</span></p>
<p><span class="math inline">\(有a^{p−1}≡1(modp)\)</span></p></li>
<li><p>二次探测定理：</p>
<p><span class="math inline">\(若p是质数，且x^2≡1(modp)，\)</span></p>
<p><span class="math inline">\(那么x≡1 (modp)和x≡p−1(modp)中有一个成立\)</span></p></li>
</ul></li>
</ul>
<hr />
<ul>
<li>算法过程
<ol type="1">
<li>偶数、0、1、2直接判断</li>
<li>假设要测试的数为<span class="math inline">\(n\)</span>，选取整数<span class="math inline">\(r\)</span>和奇数<span class="math inline">\(d\)</span>，满足<span class="math inline">\(n-1=2^rd\)</span></li>
<li>选取<span class="math inline">\(a \in (1,...,n-1)\)</span></li>
<li>如果<span class="math inline">\(a^d=1(modn)\)</span>或者<span class="math inline">\(a^d=n-1(modn)\)</span>，即满足二次探测定理，则调回Step 3继续验证</li>
<li>对于<span class="math inline">\(i=0,...,r-1\)</span>，验证<span class="math inline">\(a^{2^id}\)</span>是否满足<span class="math inline">\(a^{2^id}=n-1(modn)\)</span>，满足则跳回Step 3继续验证，不满足则<span class="math inline">\(n\)</span>为合数</li>
<li>经过<span class="math inline">\(k\)</span>次验证后，<span class="math inline">\(n\)</span>可能是素数</li>
</ol></li>
</ul>
<hr />
<p>伪码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Input #1: n &gt; 3, an odd integer to be tested for primality</span><br><span class="line">Input #2: k, the number of rounds of testing to perform</span><br><span class="line">Output: “composite” if n is found to be composite, “probably prime” otherwise</span><br><span class="line"></span><br><span class="line">write n as 2^r·d + 1 with d odd (by factoring out powers of 2 from n − 1)</span><br><span class="line">WitnessLoop: repeat k times:</span><br><span class="line">pick a random integer a in the range [2, n − 2]</span><br><span class="line">x ← a^d mod n</span><br><span class="line">if x &#x3D; 1 or x &#x3D; n − 1 then</span><br><span class="line">    continue WitnessLoop</span><br><span class="line">repeat r − 1 times:</span><br><span class="line">    x ← x^2 mod n</span><br><span class="line">    if x &#x3D; n − 1 then</span><br><span class="line">        continue WitnessLoop</span><br><span class="line">return “composite”</span><br><span class="line">return “probably prime”</span><br></pre></td></tr></table></figure>
<hr />
<p>模板</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="comment">//typedef long long ll;</span></span><br><span class="line"><span class="comment">//ll*ll可能会溢出，所以乘法化加法</span></span><br><span class="line"><span class="comment">/* *************************************************</span></span><br><span class="line"><span class="comment">* Miller_Rabin 算法进行素数测试</span></span><br><span class="line"><span class="comment">* 速度快可以判断一个 &lt; 2^63 的数是不是素数</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">**************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> S = <span class="number">8</span>; <span class="comment">//随机算法判定次数一般 8～10 就够了</span></span><br><span class="line"><span class="comment">// 计算 ret = (a*b)%c a,b,c &lt; 2^63</span></span><br><span class="line"><span class="function">ll <span class="title">mult_mod</span><span class="params">(ll a,ll b,ll c)</span></span>&#123;</span><br><span class="line">	a%=c;</span><br><span class="line">	b%=c;</span><br><span class="line">	ll ret=<span class="number">0</span>;</span><br><span class="line">	ll tmp=a;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)&#123;</span><br><span class="line">			ret+=tmp;</span><br><span class="line">			<span class="keyword">if</span>(ret&gt;c)ret-=c;<span class="comment">//直接取模慢得多 </span></span><br><span class="line">		&#125;</span><br><span class="line">		tmp&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(tmp&gt;c)tmp-=c;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算 ret = (a^n)%mod</span></span><br><span class="line"><span class="function">ll <span class="title">pow_mod</span><span class="params">(ll a,ll n,ll mod)</span></span>&#123;</span><br><span class="line">	ll ret=<span class="number">1</span>;</span><br><span class="line">	ll tmp=a%mod;</span><br><span class="line">	<span class="keyword">while</span>(n)&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&amp;<span class="number">1</span>)ret=mult_mod(ret,tmp,mod);</span><br><span class="line">		tmp=mult_mod(tmp,tmp,mod);</span><br><span class="line">		n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过 a^(n-1)=1(modn)来判断 n 是不是素数</span></span><br><span class="line"><span class="comment">// n - 1 = x * (2^t)</span></span><br><span class="line"><span class="comment">// 中间使用二次判断</span></span><br><span class="line"><span class="comment">// 是合数返回 true, 不一定是合数返回 false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(ll a,ll n,ll x,ll t)</span></span>&#123;</span><br><span class="line">	ll ret = pow_mod(a,x,n);</span><br><span class="line">	ll last = ret;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= t;i++)&#123;</span><br><span class="line">		ret = mult_mod(ret,ret,n);</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">1</span> &amp;&amp; last != <span class="number">1</span> &amp;&amp; last != n<span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//合数</span></span><br><span class="line">		last = ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ret != <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 费马小定理</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**************************************************</span></span><br><span class="line"><span class="comment">// Miller_Rabin 算法</span></span><br><span class="line"><span class="comment">// 是素数返回 true,(可能是伪素数)</span></span><br><span class="line"><span class="comment">// 不是素数返回 false</span></span><br><span class="line"><span class="comment">//**************************************************</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( n &lt; <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>( n == <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>( (n&amp;<span class="number">1</span>) == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//偶数</span></span><br><span class="line">	ll x = n - <span class="number">1</span>;</span><br><span class="line">	ll t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>( (x&amp;<span class="number">1</span>)==<span class="number">0</span> )&#123;x &gt;&gt;= <span class="number">1</span>; t++;&#125;</span><br><span class="line">	</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));<span class="comment">/* *************** */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S;i++)&#123;</span><br><span class="line">		ll a = rand()%(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>( check(a,n,x,t) )</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="大数的质因子分解-pollard-rho">大数的质因子分解-Pollard Rho</h2>
<ul>
<li><span class="math inline">\(O(n^{\frac{1}{4}})\)</span>的期望时间复杂度内计算合数<span class="math inline">\(n\)</span>的某个非平凡因子(平凡因子指<span class="math inline">\(1\)</span>和<span class="math inline">\(n\)</span>，非平凡因子指<span class="math inline">\(x \in [2,n-1]，n mod x=0\)</span>)</li>
<li>试除法：<span class="math inline">\(n\)</span>的因数对称分布，遍历区间<span class="math inline">\([1,\sqrt N]\)</span>，时间复杂度为<span class="math inline">\(O(\sqrt N)\)</span></li>
<li>不直接寻找因子，而是寻找因子的倍数，然后通过GCD找到因子本身</li>
</ul>
<h2 id="思路">思路</h2>
<ol type="1">
<li>对于<span class="math inline">\(N⩾10^{18}\)</span>，使用<strong>随机算法</strong>-猜因数</li>
<li>组合随机采样-生日悖论：满足答案的组合比单个个体要多一些。假如一个班上有<span class="math inline">\(k\)</span>个人，如果找到一个人的生日是x月x日，这个概率会相当低；如果想找两个生日相同，当<span class="math inline">\(k=23\)</span>，两个人在同一天生日的概率至少有<span class="math inline">\(50\%\)</span>，<span class="math inline">\(k=60\)</span>时，生日有重复的现象的概率<span class="math inline">\(\text{P}(k) ≈0.9999\)</span></li>
</ol>
<hr />
<ol start="3" type="1">
<li>最大公约数一定是某个数的约数。通过选择适当的<span class="math inline">\(k\)</span>使得<span class="math inline">\(\gcd(k,n)&gt;1\)</span>，则求得的<span class="math inline">\(\gcd(k,n)\)</span>是<span class="math inline">\(n\)</span>的约数。则选取一组数<span class="math inline">\(x_1,x_2,x_3,...x_n\)</span>，若有<span class="math inline">\(gcd(|x_i-x_j|,n)&gt;1\)</span>，则称<span class="math inline">\(gcd(|x_i-x_j|,n)\)</span>是<span class="math inline">\(n\)</span>的一个因子</li>
<li>构造一个<strong>伪随机数序列</strong>，然后取相邻的两项来求gcd。Pollard设计了一个函数: <span class="math inline">\(f(x)=(x^2+c)\mod N\)</span> 其中c是一个随机的常数。选取<span class="math inline">\(x_1\)</span>，令<span class="math inline">\(x_2=f(x_1),x_3=f(x_2),...,x_i=f(x_{i-1})\)</span></li>
</ol>
<hr />
<ol start="5" type="1">
<li>Floyd判圈：在一定范围内，这个数列是随机的；但也有死循环的情况。龟兔赛跑：兔子比乌龟快一倍，同起点同时开始，当兔子“追上”乌龟时，兔子一定跑了刚好一圈。</li>
</ol>
<p><img src="https://img-blog.csdn.net/20150503163841553" width=30%></p>
<ol start="6" type="1">
<li><a href="https://www.cnblogs.com/book-book/p/6349362.html">brent判环(更高效)</a></li>
</ol>
<hr />
<p>kuangbin的模板 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//**************************************************</span></span><br><span class="line"><span class="comment">// Miller_Rabin 算法</span></span><br><span class="line"><span class="comment">// 是素数返回 true,(可能是伪素数)</span></span><br><span class="line"><span class="comment">// 不是素数返回 false</span></span><br><span class="line"><span class="comment">//**************************************************</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Miller_Rabin</span><span class="params">(ll n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( n &lt; <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span>( n == <span class="number">2</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span>( (n&amp;<span class="number">1</span>) == <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//偶数</span></span><br><span class="line">	ll x = n - <span class="number">1</span>;</span><br><span class="line">	ll t = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>( (x&amp;<span class="number">1</span>)==<span class="number">0</span> )&#123;x &gt;&gt;= <span class="number">1</span>; t++;&#125;</span><br><span class="line">	</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));<span class="comment">/* *************** */</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; S;i++)&#123;</span><br><span class="line">		ll a = rand()%(n<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>( check(a,n,x,t) )</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**********************************************</span></span><br><span class="line"><span class="comment">// pollard_rho 算法进行质因素分解</span></span><br><span class="line"><span class="comment">//*********************************************</span></span><br><span class="line">ll factor[<span class="number">100</span>];<span class="comment">//质因素分解结果（刚返回时时无序的）</span></span><br><span class="line"><span class="keyword">int</span> tol;<span class="comment">//质因素的个数，编号 0～tol-1</span></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">	ll t;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		t = a;</span><br><span class="line">		a = b;</span><br><span class="line">		b = t%b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(a &gt;= <span class="number">0</span>)<span class="keyword">return</span> a;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> -a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找出一个因子</span></span><br><span class="line"><span class="function">ll <span class="title">pollard_rho</span><span class="params">(ll x,ll c)</span></span>&#123;</span><br><span class="line">	ll i = <span class="number">1</span>, k = <span class="number">2</span>;</span><br><span class="line">	srand(time(<span class="literal">NULL</span>));</span><br><span class="line">	ll x0 = rand()%(x<span class="number">-1</span>) + <span class="number">1</span>;</span><br><span class="line">	ll y = x0;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		i++;</span><br><span class="line">		x0 = (mult_mod(x0,x0,x) + c)%x;<span class="comment">//不断调整x2 </span></span><br><span class="line">		ll d = gcd(y - x0,x);</span><br><span class="line">		<span class="keyword">if</span>( d != <span class="number">1</span> &amp;&amp; d != x)<span class="keyword">return</span> d;<span class="comment">//找到因子，返回 </span></span><br><span class="line">		<span class="keyword">if</span>(y == x0)<span class="keyword">return</span> x;<span class="comment">//判圈 出现循环，返回 </span></span><br><span class="line">		<span class="keyword">if</span>(i == k)&#123;y = x0; k += k;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对 n 进行素因子分解，存入 factor. k 设置为 107 左右即可</span></span><br><span class="line"><span class="comment">// 如果n 本身就是素数，那么将 n 存放在 factor 便可结束并返回</span></span><br><span class="line"><span class="comment">// 如果 n 不是素数，那么通过 pollard_rho()函数 找到 n 的一个因子 p(不一定是素因子)，递归 findFac(p)和 findFac(n/p)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">findfac</span><span class="params">(ll n,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span>;<span class="comment">//递归出口 </span></span><br><span class="line">	<span class="keyword">if</span>(Miller_Rabin(n))</span><br><span class="line">	&#123;</span><br><span class="line">		factor[tol++] = n;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ll p = n;</span><br><span class="line">	<span class="keyword">int</span> c = k;</span><br><span class="line">	<span class="comment">//值变化，防止死循环</span></span><br><span class="line">	<span class="keyword">while</span>( p &gt;= n) <span class="comment">// 改变常数c，不断找因子，返回n说明没找到 </span></span><br><span class="line">		p = pollard_rho(p,c--);</span><br><span class="line">	findfac(p,k);</span><br><span class="line">	findfac(n/p,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><a href="https://www.luogu.com.cn/problem/P4718">洛谷 P4718【模板】Pollard-Rho算法</a> - TLE的原因</p>
<h1 id="欧拉降幂">欧拉降幂</h1>
<hr />
<p>给三个正整数，<span class="math inline">\(a,m,b\)</span>，需要求：<span class="math inline">\(a^b mod m\)</span></p>
<p><span class="math inline">\(1\le a \le 10^9，1\le b \le 10^{20000000}，1\le m \le 10^8\)</span></p>
<p><strong>指数爆炸</strong></p>
<hr />
<ul>
<li><p>欧拉定理：<span class="math inline">\(a^{\varphi(p)}≡1 \ mod \ p，a和p互质\)</span></p></li>
<li><p>拓展欧拉降幂</p>
<p><span class="math inline">\(a^b\equiv \begin{cases} a^{b\bmod\varphi(p)},&amp;\gcd(a,p)=1\\ a^b,&amp;\gcd(a,p)\ne1,b&lt;\varphi(p)\\ a^{b\bmod\varphi(p)+\varphi(p)},&amp;\gcd(a,p)\ne1,b\ge\varphi(p) \end{cases} \pmod p\)</span></p></li>
<li><p>假设<span class="math inline">\(k=\frac{b}{\varphi(p)},h=bmod\varphi(p)\)</span>，则<span class="math inline">\(a^b=a^{k*\varphi(p)+h}=(a^{\varphi(p)})^k*a^h=a^h(modp)\)</span></p></li>
<li><p><a href="https://blog.csdn.net/weixin_38686780/article/details/81272848">欧拉降幂公式的证明</a></p></li>
</ul>
<hr />
<p>求单个数的欧拉函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">eular</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i*i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">            ans -= ans/i;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)n /= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">1</span>)ans −= ans/n;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<ul>
<li>拓展欧拉函数
<ul>
<li>以字符串形式读入大数，处理得到<span class="math inline">\(bmod\varphi(p)\)</span></li>
<li>需要判断<span class="math inline">\(b\)</span>和<span class="math inline">\(\varphi(p)\)</span>的大小，否则会出错 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// char b[maxn]</span></span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line">c=eular(p);</span><br><span class="line">ll len = <span class="built_in">strlen</span>(b);</span><br><span class="line"><span class="keyword">int</span> flg=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(ll i = <span class="number">0</span>;i &lt; len; i++)&#123;</span><br><span class="line">    ans = (ans*<span class="number">10</span> + b[i]-<span class="string">'0'</span>);</span><br><span class="line">    <span class="keyword">if</span>(ans&gt;=p)&#123;</span><br><span class="line">        flg=<span class="number">1</span>;</span><br><span class="line">        ans%=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flg)ans+=p;</span><br><span class="line"><span class="comment">// 快速幂计算 a是底数，ans是指数，p是模数</span></span><br><span class="line">qPow(a,ans,p);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><a href="https://www.luogu.com.cn/problem/P5091">洛谷 P5091 模板题</a></li>
</ul>
<h2 id="欧拉函数常用性质和公式">欧拉函数常用性质和公式</h2>
<ul>
<li><span class="math inline">\(对于质数p，\varphi(p)=p-1\)</span></li>
<li><span class="math inline">\(\sum_{d|n}\varphi(d)=n\quad，包括1和n本身\)</span></li>
<li><span class="math inline">\(\sum_{gcd(d,n)==1}d=\varphi(n)*n/2\)</span></li>
<li><span class="math inline">\(\sum_{i=1}^{n-1}gcd(i,n)=\sum_{d|n}d\varphi(n|d)\)</span></li>
<li><span class="math inline">\(若p为质数，n=p^k,\varphi(n)=p^k-p^{k-1}\)</span></li>
<li><span class="math inline">\(积性性质：若m,n互质，\varphi(m*n)=\varphi(m)*\varphi(n)\)</span></li>
</ul>
<h1 id="rsa">RSA</h1>
<h2 id="算法流程">算法流程</h2>
<ul>
<li>公钥密码算法</li>
<li><span class="math inline">\(随机选择两个不相等的质数p和q\)</span></li>
<li><span class="math inline">\(计算p和q的乘积n\)</span></li>
<li><span class="math inline">\(计算n的欧拉函数φ(n)=(p-1)(q-1)\)</span></li>
<li><span class="math inline">\(随机选择一个整数e，满足1&lt;e&lt;φ(n)，且e与φ(n)互质\)</span></li>
<li><span class="math inline">\(求出整数d，使得ed ≡ 1 (mod φ(n))\)</span></li>
<li><span class="math inline">\((n,e)为公钥，d为私钥\)</span></li>
<li><span class="math inline">\(加密：明文消息m，满足0&lt;m&lt;n，密文c=m^e mod n\)</span></li>
<li><span class="math inline">\(解密：接受到密文消息为c，解密明文消息m=c^d mod n\)</span></li>
</ul>
<h2 id="知识点">知识点</h2>
<ul>
<li><p>逆元(欧拉定理)+快速幂</p>
<blockquote>
<p>若(a*x)%mod=1，则x是正整数a在模mod下的逆元</p>
</blockquote></li>
</ul>
<hr />
<table>
<thead>
<tr class="header">
<th>方法</th>
<th>限定</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>线性打表法</td>
<td>只要求mod是质数</td>
<td>O(n)</td>
</tr>
<tr class="even">
<td>费马小定理</td>
<td>mod是质数且与a互质，快速幂优化</td>
<td>O(log(n))</td>
</tr>
<tr class="odd">
<td>欧拉定理</td>
<td>只要求a与mod互质，需要欧拉函数与快速幂</td>
<td>O(sqrt(n)+log(n))</td>
</tr>
<tr class="even">
<td>拓展欧几里德</td>
<td>只要求a与mod互质</td>
<td>O(log(n))</td>
</tr>
</tbody>
</table>
<h1 id="拓展中国剩余定理">拓展中国剩余定理</h1>
<h2 id="中国剩余定理">中国剩余定理</h2>
<p>韩信点兵，三三一排少1人，五五一排少1人，七七一排少1个人</p>
<hr />
<blockquote>
<p><span class="math inline">\(对于一组同余方程\)</span></p>
<p><span class="math inline">\(x≡a_1 (mod n_1)\)</span></p>
<p><span class="math inline">\(x≡a_2 (mod n_2)\)</span></p>
<p><span class="math inline">\(...\)</span></p>
<p><span class="math inline">\(x≡a_k (mod n_k)\)</span></p>
<p><span class="math inline">\(模数n_1,n_2...n_k两两互质，求最小的x\)</span></p>
</blockquote>
<hr />
<ol type="1">
<li><p><span class="math inline">\(计算N=n_1×n_2×⋯×n_k\)</span></p></li>
<li><p><span class="math inline">\(对于i=1,2,…,k，\)</span></p>
<p><span class="math inline">\(计算y_i=\frac{N}{n_i}=n_1n_2...n_{i-1}n_{i+1}...n_k\)</span></p></li>
<li><p><span class="math inline">\(对于i=1,2,…,k，计算z_i=y_i^{-1}(modn_i)，\)</span></p>
<p><span class="math inline">\(即计算y_i在模n_i下的逆元\)</span></p></li>
<li><p><span class="math inline">\(x=\sum_{i=1}^ka_iy_iz_i，\)</span></p>
<p><span class="math inline">\(最后计算x=x(modN)得到结果\)</span></p></li>
</ol>
<h2 id="模数两两不互质">模数两两不互质</h2>
<ul>
<li><p>思路</p>
<ol type="1">
<li><span class="math inline">\(通过先解出前两个方程的解，如将前两个方程\)</span></li>
<li><span class="math inline">\(x≡a_1 (mod n_1)，x≡a_2 (mod n_2)化为x≡A(mod N)\)</span></li>
<li><span class="math inline">\(将此方程和x≡a_3 (mod n_3)\)</span></li>
<li><span class="math inline">\(继续联立求解，直到最后一个方程解完为止\)</span></li>
</ol></li>
<li><p><a href="https://www.luogu.com.cn/problem/P4777">洛谷 P4777 模板题</a></p></li>
</ul>
<hr />
<blockquote>
<p><span class="math inline">\(x≡a_1 (mod n_1)\)</span></p>
<p><span class="math inline">\(x≡a_2 (mod n_2)\)</span></p>
</blockquote>
<ul>
<li><p><span class="math inline">\(可化为 x=a_1+k_1*n_1 ①; x=a_2+k_2*n_2;\)</span></p></li>
<li><p><span class="math inline">\(消x，可得a_1+k_1*n_1=a_2+k_2*n_2\)</span></p>
<p><span class="math inline">\(移项得到k_1*n_1+(-k_2)*n_2=a_2-a_1\)</span></p></li>
<li><p><span class="math inline">\(令d=a_2-a_1, x=k_1, y=-k_2;\)</span></p>
<p><span class="math inline">\(上式化为 x*n_1+y*n_2=d ③\)</span></p></li>
<li><p><span class="math inline">\(令g=gcd(n_1,n_2),用拓展欧几里得解线性方程\)</span></p>
<p><span class="math inline">\((此处求解x_1，y_1)，x_1*n_1+y_1*n_2=g\)</span></p></li>
</ul>
<hr />
<ul>
<li><p><span class="math inline">\(③式可化为 x_1*(d/g)*n_1+y_1*(d/g)*n_2 = g*(d/g)\)</span></p></li>
<li><p><span class="math inline">\(即x=x_1*(d/g)=k_1 ; y=y_1*(d/g)=-k_2;\)</span></p>
<p><span class="math inline">\(即k_1=x_1*(d/g); k_2=-y_1*(d/g)\)</span></p></li>
<li><p><span class="math inline">\(一组通解为 k_1=k_1+(n_2/g)*T; k_2=k_2-(n_1/g)*T\)</span></p></li>
<li><p><span class="math inline">\(要求使所求得的解最小且为正整数，\)</span></p>
<p><span class="math inline">\(则可以根据 k_1的通解形式求得(消掉T的影响)\)</span></p></li>
<li><p><span class="math inline">\(k_1=(k_1 mod (n_2/g)+(n_2/g)) mod (n_2/g) ②，\)</span></p>
<p><span class="math inline">\(即k_1=((x_1*(d/g)) mod (n_2/g)+(n_2/g)) mod (n_2/g)\)</span></p></li>
</ul>
<hr />
<ul>
<li><p><span class="math inline">\(将求出的k_1带入①，可得x的解，\)</span></p>
<p><span class="math inline">\(作为下一次的A，N为lcm(n1,n2)，\)</span></p>
<p><span class="math inline">\(即A为合并后的a，N为合并后的n\)</span></p></li>
</ul>
<hr />
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span>&amp;&amp;b==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;x=<span class="number">1</span>;y=<span class="number">0</span>;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    ll d=exgcd(b,a%b,y,x);</span><br><span class="line">    y-=a/b*x;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">excrt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll a1=b[<span class="number">0</span>],n1=a[<span class="number">0</span>],a2,n2,d,x,y,gcd;<span class="comment">//余数 b[] 除数 a[]</span></span><br><span class="line">    <span class="comment">// 返回的是最小非负整数解，有些题目需要特判</span></span><br><span class="line">    <span class="comment">//若当余数为0的时候 题目要求求正整数 所以0不算在内，应该加上下面的注释，即余数等于除数，同理后面的板子</span></span><br><span class="line">    <span class="comment">//if(a1==0)a1=a[0]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        a2=b[i];n2=a[i];</span><br><span class="line">        d=a2-a1;</span><br><span class="line">        gcd=exgcd(n1,n2,x,y);</span><br><span class="line">        <span class="keyword">if</span>(d%gcd)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        x=((x*d/gcd)%(n2/gcd)+(n2/gcd))%(n2/gcd);</span><br><span class="line">        a1=x*n1+a1;</span><br><span class="line">        n1=n1*n2/gcd;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="定理猜想公式">定理&amp;猜想&amp;公式</h1>
<hr />
<ul>
<li><p>费马大定理：</p>
<p><span class="math inline">\(当整数n &gt;2时，\)</span></p>
<p><span class="math inline">\(关于x, y, z的方程 x^n + y^n = z^n 没有正整数解\)</span></p></li>
<li><p>实数域不可拆分多项式：</p>
<p><span class="math inline">\(一次多项式和二次多项式(b^2&lt;4ac)\)</span></p>
<ul>
<li>艾森斯坦因判别法：有理数域不可约，即一定要整数解</li>
</ul></li>
</ul>
<hr />
<ul>
<li>勾股数
<ul>
<li>任意大于2的整数都可以找出另外两个数构成勾股数</li>
<li>本原勾股数</li>
</ul></li>
<li>四色猜想</li>
<li>康威常数</li>
<li>日期转化成星期
<ul>
<li>蔡勒公式</li>
<li>基姆拉尔森计算公式</li>
</ul></li>
<li>斯特林公式 - 阶乘</li>
</ul>
]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>部署MySQL Cluster集群系统</title>
    <url>/2020/03/25/MySQL-Cluster-set-up-configuration/</url>
    <content><![CDATA[<blockquote>
<p>MySQL Cluster is a technology providing <strong>shared-nothing</strong> clustering and auto-sharding for the MySQL database management system. It is designed to provide high availability and high throughput with low latency, while allowing for near linear scalability A MySQL Cluster consists of one or more management nodes (ndb_mgmd) that store the cluster’s configuration and control the data nodes (ndbd), where cluster data is stored. After communicating with the management node, clients (MySQL clients, servers, or native APIs) connect directly to these data nodes. With MySQL Cluster there is typically no replication of data, but instead data node synchronization. For this purpose a special data engine must be used — NDBCluster (NDB)</p>
</blockquote>
<a id="more"></a>
<h2 id="实验环境">1 实验环境</h2>
<ul>
<li><a href="https://www.digitalocean.com/community/tutorials/how-to-create-a-multi-node-mysql-cluster-on-ubuntu-18-04">英文指南(18.04&amp;16.04)</a></li>
<li>VMware Workstation Pro 12</li>
<li>2台Linux虚拟机，Ubuntu 16.04 Server</li>
<li><a href="http://dev.mysql.com/downloads/cluster/">MySQL-Cluster的安装包</a>：mysql-cluster_8.0.19-1ubuntu16.04_amd64.deb-bundle.tar</li>
<li>设置windows主机和Linux虚拟机共享文件夹</li>
<li>方便编辑配置文件，安装vim <code>sudo apt-get install vim</code></li>
</ul>
<h2 id="实验过程">2 实验过程</h2>
<h3 id="前提">2.1 前提</h3>
<ul>
<li><a href="#%e9%9b%86%e7%be%a4%e9%85%8d%e7%bd%ae">在VMware下安装Ubuntu虚拟机</a></li>
<li>VMware的克隆，右键虚拟机-&gt;管理-&gt;克隆，创建完整克隆
<ul>
<li><p>两个不同的虚拟机如果是用同一个镜像报错内部错误 -&gt; 就像virtualbox中的多重加载</p></li>
<li><p>所以用一个iso安装好一个虚拟机后，将使用ISO映像文件去掉，选择使用物理驱动器。再用这个iso装另外的机器。克隆同理。</p>
<p><img src="iso.png"></p></li>
</ul></li>
<li><a href="https://blog.csdn.net/happysunshineguy/article/details/77158993?utm_source=copy">虚拟机与宿主机共享</a>
<ul>
<li>注意用<code>cp</code>而不是<code>mv</code>将vmware tools安装包移动到可以进行解压<code>gunzip</code>的目录，如'/root'。因为该安装包只读，所以无法在该文件夹下进行解压和<code>mv</code>命令</li>
<li>tar格式(tar是打包，不是压缩) <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打包:tar cvf 目录文件名.tar 目录文件名</span><br><span class="line">解包:tar xvf 目录文件名.tar</span><br></pre></td></tr></table></figure></li>
<li>tar.gz格式： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">压缩:tar -zcvf 目录文件名.tar.gz 目录文件名</span><br><span class="line">解压:tar -zxvf 目录文件名.tar.gz</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h3 id="设置静态ip">2.2 设置静态IP</h3>
<h4 id="vmware配置网络环境">2.2.1 VMware配置网络环境</h4>
<ul>
<li><p>按要求给一台机器设置静态ip为：192.168.50.128，另一台机器的静态ip为：192.168.50.129。</p></li>
<li><p>使用NAT，虚拟机在一个子网中，通过物理机的IP上网。</p>
<p><img src="delete-VMnet01.png" width=80%></p></li>
<li><p>去掉<code>使用本地DHCP服务将IP地址分配给虚拟机</code>，并且设置子网IP为：192.168.50.0，子网掩码为：255.255.255.0。因此，在Ubuntu中，设置IP地址的时候，可以设置为192.168.50.x，x可以为1~255。</p>
<p><img src="dhcp-ipaddress.png" width=80%></p></li>
<li><p>选择<code>NAT设置</code>，打开NAT设置面板，查看网关地址。</p>
<p><img src="gatewayaddress.png"></p></li>
<li><p>在VMWare的虚拟机管理界面，选择Ubuntu的<code>编辑虚拟机设置</code>，打开Ubuntu这个虚拟的设置界面。选择网络适配器，然后确定网络连接选中的是<code>自定义</code>中的VMnet8(NAT模式)。</p>
<p><img src="VMnet8.png"></p></li>
</ul>
<h4 id="为ubuntu设置静态ip地址">2.2.2 为Ubuntu设置静态IP地址</h4>
<h5 id="通过terminal命令行来设置ip地址">通过Terminal命令行来设置IP地址</h5>
<ul>
<li><p>在命令行输入 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;network&#x2F;interfaces </span><br><span class="line"></span><br><span class="line"># 在打开的文件中，若有内容，先全部删除</span><br><span class="line"># 然后输入如下代码</span><br><span class="line"># ip a查看网卡信息是ens33</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">auto ens33</span><br><span class="line">iface ens33 inet static</span><br><span class="line">address 192.168.50.128</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 192.168.50.2</span><br></pre></td></tr></table></figure></p>
<p><img src="configureIPaddress.png"></p></li>
<li><p>配置DNS服务器 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;resolv.conf</span><br><span class="line"></span><br><span class="line"># 在里面填入阿里的DNS：223.5.5.5</span><br><span class="line">nameserver 223.5.5.5</span><br><span class="line"></span><br><span class="line"># 在命令行中输入：</span><br><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;networking restart</span><br></pre></td></tr></table></figure></p>
<p><img src="configuredns.png"></p></li>
<li><p>重复以上步骤，配置第二个虚拟机的静态IP地址。</p></li>
</ul>
<h3 id="集群配置">2.3 集群配置</h3>
<h4 id="集群配置要求">2.3.1 集群配置要求</h4>
<ul>
<li><p>拓扑图</p>
<p><img src="MySQLCluster.png"></p></li>
<li><p>集群配置要求 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ndbd：MySQL data nodes</span><br><span class="line"># ndb_mgmd：server for the Cluster Manager</span><br><span class="line"># mysqld and mysql：MySQL server&#x2F;client</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr class="header">
<th>节点</th>
<th>IP address</th>
<th>运行实例</th>
<th>nodeID</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>数据节点1</td>
<td>192.168.50.128</td>
<td>ndbd</td>
<td>11</td>
</tr>
<tr class="even">
<td>数据节点2</td>
<td>192.168.50.129</td>
<td>ndbd</td>
<td>12</td>
</tr>
<tr class="odd">
<td>管理节点</td>
<td>192.168.50.129</td>
<td>ndb_mgmd</td>
<td>1</td>
</tr>
<tr class="even">
<td>sql节点1</td>
<td>192.168.50.129</td>
<td>mysqld</td>
<td>13</td>
</tr>
<tr class="odd">
<td>sql节点2</td>
<td>192.168.50.128</td>
<td>mysqld</td>
<td>14</td>
</tr>
</tbody>
</table>
<ul>
<li><p>一般配置，数据节点和管理节点分离(需要3台虚拟机模拟实现)。由于此处只用了2台虚拟机。</p>
<p><img src="common.png"></p></li>
</ul></li>
<li><p><a href="http://dev.mysql.com/downloads/cluster/">MySQL-Cluster的安装包下载</a>，根据linux操作系统选择正确的版本</p></li>
<li><p>若之前安装过mysql-server，需要将mysql-server卸载 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 执行以下指令卸载mysql</span><br><span class="line">sudo apt-get autoremove --purge mysql-server</span><br><span class="line">sudo apt-get remove mysql-server</span><br><span class="line">sudo apt-get autoremove mysql-server</span><br><span class="line">sudo apt-get remove mysql-common</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="准备阶段">2.3.2 准备阶段</h4>
<ul>
<li><p>针对<code>192.168.50.129</code>，安装 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在命令行下</span><br><span class="line">sudo adduser mysql</span><br><span class="line">sudo usermod -aG sudo mysql</span><br></pre></td></tr></table></figure></p>
<p><img src="adduser.png"></p>
<p><img src="usermod.png"></p></li>
<li><p>把下载的mysql-cluster_8.0.19-1ubuntu16.04_amd64.deb-bundle.tar从windows共享给虚拟机(通过共享文件夹)</p></li>
<li><p>将MySQL-Cluster的安装包放入虚拟机的指定目录install文件夹，操作如下： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在命令行的根目录下</span><br><span class="line">mkdir install</span><br><span class="line"># 通过共享文件夹</span><br><span class="line">tar -xvf &#x2F;mnt&#x2F;hgfs&#x2F;xxx&#x2F;mysql-cluster_8.0.19-1ubuntu16.04_amd64.deb-bundle.tar -C install&#x2F;</span><br><span class="line">cd install</span><br></pre></td></tr></table></figure></p>
<p><img src="install.png"></p></li>
<li><p>安装<code>MySQL server binary</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装依赖包</span><br><span class="line">sudo apt update</span><br><span class="line"># sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br><span class="line"></span><br><span class="line">sudo apt-get install libaio1 libmecab2</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="安装配置集群管理器">2.3.3 安装配置集群管理器</h4>
<ul>
<li><p>用dpkg指令在Cluster Manager 服务器(为<strong>192.168.50.129</strong>)上安装ndb_mgmd <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入install目录</span><br><span class="line">sudo dpkg -i mysql-cluster-community-management-server_8.0.19-1ubuntu16.04_amd64.deb</span><br></pre></td></tr></table></figure></p>
<p><img src="dpkg.png"></p></li>
<li><p>在第一次运行ndb_mgmd前需要对其进行配置，正确配置是保证数据节点正确同步和负载分配的前提。</p></li>
<li><p>Cluster Manager 应该是MySQL Cluster 第一个启动的组件.它需要一个配置文件来加载参数. 我门创建配置文件: /var/lib/mysql-cluster/config.ini. <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 从Windows编辑config.ini可能会报错，需要在Linux系统下编辑</span><br><span class="line"># 在Cluster Manager 所在机器上创建 &#x2F;var&#x2F;lib&#x2F;mysql-cluster目录:</span><br><span class="line">sudo mkdir &#x2F;var&#x2F;lib&#x2F;mysql-cluster</span><br><span class="line"></span><br><span class="line">sudo vim &#x2F;var&#x2F;lib&#x2F;mysql-cluster&#x2F;config.ini</span><br><span class="line"></span><br><span class="line"># 内容如下</span><br><span class="line">[ndbd default]</span><br><span class="line"># Options affecting ndbd processes on all data nodes:</span><br><span class="line">NoOfReplicas&#x3D;2  # Number of replicas</span><br><span class="line"></span><br><span class="line">[ndb_mgmd]</span><br><span class="line"># Management process options:</span><br><span class="line">hostname&#x3D;192.168.50.129  # Hostname of the manager</span><br><span class="line">NodeId&#x3D;1</span><br><span class="line">datadir&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql-cluster  # Directory for the log files</span><br><span class="line"></span><br><span class="line">[ndbd]</span><br><span class="line">hostname&#x3D;192.168.50.128 # Hostname&#x2F;IP of the first data node</span><br><span class="line">NodeId&#x3D;11            # Node ID for this data node</span><br><span class="line">datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data   # Remote directory for the data files</span><br><span class="line"></span><br><span class="line">[ndbd]</span><br><span class="line">hostname&#x3D;192.168.50.129 # Hostname&#x2F;IP of the second data node</span><br><span class="line">NodeId&#x3D;12            # Node ID for this data node</span><br><span class="line">datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data   # Remote directory for the data files</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"># SQL node options:</span><br><span class="line">hostname&#x3D;192.168.50.129 # MySQL server&#x2F;client i manager</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line"># SQL node options:</span><br><span class="line">hostname&#x3D;192.168.50.128 # MySQL server&#x2F;client i manager</span><br></pre></td></tr></table></figure></p>
<ul>
<li>[NDB_MGMD] 表示管理节点的配置，只能有一个</li>
<li>[NDBD DEFAULT] 表示每个数据节点的默认配置，在每个节点的[NDBD]中不用再写这些选项，只能有一个</li>
<li>[NDBD] 表示每个数据节点的配置，可以有多个</li>
<li>[MYSQLD] 表示SQL节点的配置，可以有多个，分别写上不同的SQL节点的ip地址；如不写，只保留一个空节点，表示任意一个ip地址都可以进行访问。此节点的个数表明了可以用来连接数据节点的SQL节点总数</li>
<li>每个节点都有一个独立的id号，可以填写，比如nodeid=2，老版本使用id，新版本已经不使用id标识了。不填写，系统会按照配置文件的填写顺序自动分配</li>
</ul>
<p><img src="config-ini.png"></p></li>
<li><p>如果是生产环境，应该根据实际情况调整配置参数，参考MySQL Cluster. 你还可以增加 data nodes (ndbd) 或 MySQL server nodes (mysqld).</p></li>
<li><p>启动管理器 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看是否有正在运行的服务进程</span><br><span class="line">ps -aux | grep ndb_mgmd</span><br><span class="line"></span><br><span class="line"># 在启动服务前，可能需要杀掉正在运行的服务:</span><br><span class="line">sudo pkill -f ndb_mgmd</span><br><span class="line"></span><br><span class="line"># 启动服务</span><br><span class="line">sudo ndb_mgmd -f &#x2F;var&#x2F;lib&#x2F;mysql-cluster&#x2F;config.ini</span><br><span class="line"></span><br><span class="line">#检查ndb_mgmd 使用的端口 1186</span><br><span class="line">sudo netstat -plntu</span><br></pre></td></tr></table></figure></p>
<p><img src="startndb_mgmd.png"></p></li>
<li><p>配置<strong>自动加载服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 在Ubuntu虚拟机下</span><br><span class="line"># 打开并编辑下面 systemd Unit 文件</span><br><span class="line">sudo vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;ndb_mgmd.service</span><br><span class="line"></span><br><span class="line"># 键入以下内容，保存并关闭</span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;MySQL NDB Cluster Management Server</span><br><span class="line">After&#x3D;network.target auditd.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;ndb_mgmd -f &#x2F;var&#x2F;lib&#x2F;mysql-cluster&#x2F;config.ini</span><br><span class="line">ExecReload&#x3D;&#x2F;bin&#x2F;kill -HUP $MAINPID</span><br><span class="line">KillMode&#x3D;process</span><br><span class="line">Restart&#x3D;on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line"></span><br><span class="line"># 上面只是加入了如何启动、停止和重启动ndb_mgmd进程的最小选项集合</span><br><span class="line"># more information，参阅[systemd manual](https:&#x2F;&#x2F;www.freedesktop.org&#x2F;software&#x2F;systemd&#x2F;man&#x2F;systemd.service.html).</span><br></pre></td></tr></table></figure>
<p><img src="ndbmgmdservice.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># reload systemd’s manager configuration using daemon-reload</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># enable the service we just created</span><br><span class="line"># MySQL Cluster Manager starts on reboot</span><br><span class="line">sudo systemctl enable ndb_mgmd</span><br><span class="line"></span><br><span class="line"># start the service</span><br><span class="line">sudo systemctl start ndb_mgmd</span><br><span class="line"></span><br><span class="line"># verify that the NDB Cluster Management service is running</span><br><span class="line">sudo systemctl status ndb_mgmd</span><br></pre></td></tr></table></figure>
<ul>
<li><code>ndb_mgmd</code>MySQL Cluster Management server作为一个系统服务正在运行</li>
</ul>
<p><img src="systemctlenablendbmgmd.png"></p></li>
<li><p>设置<code>Cluster Manager</code>允许其它<code>MySQL Cluster</code>节点连入</p>
<ul>
<li>如果出现连接问题，则需要设置<code>ufw</code>防火墙，添加允许数据节点连入的规则 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw allow from 192.168.50.128</span><br><span class="line">sudo ufw allow from 192.168.50.129</span><br></pre></td></tr></table></figure></li>
<li>会见到如下输出。此时<code>Cluster Manager</code>应该启动运行了，并且能够通过局域网与集群其它节点通信了。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rule added</span><br><span class="line"></span><br><span class="line"># 因为我之前配置过，所以会显示</span><br><span class="line">Rule updated</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="配置数据节点">2.3.4 配置数据节点</h4>
<ul>
<li><p>假定在192.168.50.129上进行(同理另一个节点)</p></li>
<li><p>安装依赖包 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修复损坏的软件包，尝试卸载出错的包，重新安装正确版本的</span><br><span class="line">sudo apt-get –f install </span><br><span class="line">sudo apt install libclass-methodmaker-perl</span><br></pre></td></tr></table></figure></p></li>
<li><p>安装数据节点包 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 进入install文件夹</span><br><span class="line">sudo dpkg -i mysql-cluster-community-data-node_8.0.19-1ubuntu16.04_amd64.deb</span><br></pre></td></tr></table></figure></p>
<p><img src="dpkg-data.png"></p></li>
<li><p>数据节点将从固定位置/etc/my.cnf获取配置文件.创建文件并编辑 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo vim &#x2F;etc&#x2F;my.cnf</span><br><span class="line"></span><br><span class="line"># 写入以下内容 两个虚拟机都一样</span><br><span class="line">[mysql_cluster]</span><br><span class="line"># Options for NDB Cluster processes:</span><br><span class="line">ndb-connectstring&#x3D;192.168.50.129  # location of cluster manager</span><br></pre></td></tr></table></figure></p>
<p><img src="myconf.png"></p></li>
<li><p>本配置设定在管理器配置数据目录为<code>/usr/local/mysql/data</code>。运行服务前要创建相关目录<code>sudo mkdir -p /usr/local/mysql/data</code>。在成功启动数据节点的时候，会向该文件夹中写入数据，如下图所示。</p>
<p><img src="data.png"></p></li>
<li><p>启动服务<code>sudo ndbd</code>，NDB 数据节点守护程序成功启动</p>
<p><img src="ndbstartsuccess.png"></p>
<p>同理见<code>192.168.50.128</code>(192.168.50.129机器上的管理器服务要打开)</p>
<p><img src="ndbstartsuccess1.png"></p></li>
<li><p>如果出现连接问题，请打开防火墙： <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ufw allow from 192.168.50.129</span><br><span class="line">sudo ufw allow from 192.168.50.128</span><br></pre></td></tr></table></figure></p></li>
<li><p>同配置集群管理器类似，配置数据节点服务自启动 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打开并编辑如下 systemd Unit 文件</span><br><span class="line">sudo vim &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;ndbd.service</span><br><span class="line"></span><br><span class="line"># 内容如下：</span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;MySQL NDB Data Node Daemon</span><br><span class="line">After&#x3D;network.target auditd.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;ndbd</span><br><span class="line">ExecReload&#x3D;&#x2F;bin&#x2F;kill -HUP $MAINPID</span><br><span class="line">KillMode&#x3D;process</span><br><span class="line">Restart&#x3D;on-failure</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line"></span><br><span class="line"># 采用daemon-reload重新加载systemd’s manager配置</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 让我们刚创建的服务生效，使data node daemon可以开机执行</span><br><span class="line">sudo systemctl enable ndbd</span><br><span class="line"></span><br><span class="line"># 启动服务</span><br><span class="line">sudo systemctl start ndbd</span><br><span class="line"></span><br><span class="line"># 禁止服务</span><br><span class="line">sudo systemctl stop ndbd</span><br><span class="line"></span><br><span class="line"># 验证NDB Cluster Management service服务正在执行</span><br><span class="line">sudo systemctl status ndbd</span><br></pre></td></tr></table></figure></p>
<p><img src="systemctlenablendbd.png"></p></li>
</ul>
<h4 id="配置并运行mysql-server和client">2.3.5 配置并运行MySQL Server和Client</h4>
<ul>
<li><p>标准的MySQL server不支持 MySQL Cluster 引擎 NDB。这意味着我们需要安装含有定制的SQL服务器 MySQL Cluster软件。</p></li>
<li><p><code>192.168.50.129</code>和<code>192.168.50.128</code>都作为<code>MySQL Server node</code></p></li>
<li><p>进入包含MySQL Cluster组件的目录<code>cd install</code></p></li>
<li><p>在安装MySQL server 前，需要安装两个依赖库（如果已经安装过可忽略） <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install libaio1 libmecab2</span><br></pre></td></tr></table></figure></p></li>
<li><p>安装解压在install目录的软件包中的一些MySQL Cluster依赖包 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;install&#x2F;</span><br><span class="line">sudo dpkg -i mysql-common_8.0.19-1ubuntu16.04_amd64.deb</span><br><span class="line">sudo dpkg -i mysql-cluster-community-client-core_8.0.19-1ubuntu16.04_amd64.deb</span><br><span class="line">sudo dpkg -i mysql-cluster-community-client_8.0.19-1ubuntu16.04_amd64.deb</span><br><span class="line">sudo dpkg -i mysql-client_8.0.19-1ubuntu16.04_amd64.deb</span><br><span class="line">sudo dpkg -i mysql-cluster-community-server-core_8.0.19-1ubuntu16.04_amd64.deb</span><br><span class="line">sudo dpkg -i mysql-cluster-community-server_8.0.19-1ubuntu16.04_amd64.deb</span><br><span class="line"></span><br><span class="line"># 此处若是出现依赖问题，输入以下命令，再重新执行一遍上面语句 </span><br><span class="line">sudo apt-get -f install</span><br><span class="line"># 或者把依赖包删除 重装一遍</span><br><span class="line">sudo apt-get purge libaio1 </span><br><span class="line">sudo apt-get purge libmecab2</span><br></pre></td></tr></table></figure></p></li>
<li><p>当安装mysql-cluster-community-server时，会出现配置提示，请求为mysql数据库root用户设置密码。在后面选项选择使用<strong>强安全密码</strong></p>
<p><img src="password.png"></p>
<p><img src="strongpw.png"></p></li>
<li><p>安装MySQL server:<code>sudo dpkg -i mysql-server_8.0.19-1ubuntu16.04_amd64.deb</code></p>
<p><img src="installmysqlserver.png"></p></li>
<li><p>配置MySQL server <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打开MySQL Server 配置文件默认</span><br><span class="line">sudo vim &#x2F;etc&#x2F;mysql&#x2F;my.cnf</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>可看到下列文本</p>
<p><img src="mycnf.png"></p></li>
<li><p>往文本后追加(192.168.50.128填写的相同)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line"># Options for mysqld process:</span><br><span class="line">ndbcluster  # run NDB storage engine</span><br><span class="line"></span><br><span class="line">[mysql_cluster]</span><br><span class="line"># Options for NDB Cluster processes:</span><br><span class="line">ndb-connectstring&#x3D;192.168.50.129  # location of management server</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>重启MySQL server，使上面的变化生效:<code>sudo systemctl restart mysql</code></p></li>
<li><p>MySQL默认开机自动启动。如果不能启动，下述命令可以修复:<code>sudo systemctl enable mysql</code></p></li>
</ul>
<h4 id="验证mysql-cluster安装">2.3.6 验证MySQL Cluster安装</h4>
<ul>
<li><p>为了验证MySQL Cluster正确安装, 登陆Cluster Manager / SQL Server节点，为192.168.50.129/192.168.50.128。</p></li>
<li><p>打开MySQL客户端连接到root账号：<code>mysql -u root -p</code></p>
<p><img src="startmysql.png"></p></li>
<li><p>在MySQL客户端中, 运行下列命令: <code>SHOW ENGINE NDB STATUS \G</code>，系统会显示NDB引擎的相关信息，表示成功连入MySQL Cluster</p>
<p><img src="NDB.png"></p></li>
<li><p><code>number of ready_data_nodes= 2</code></p>
<ul>
<li>如果一个数据节点挂了（本例中必须是那个没有安装MySQL Cluster管理器的节点），MySQL cluster还是可以继续工作</li>
<li>测试cluster的稳定性
<ul>
<li><p>shutting down非管理器节点（192.168.50.128），在整个过程中看到<code>number_of_ready_data_nodes</code>从2变为1。</p>
<p><img src="numberofreadydatanodes.gif"></p></li>
<li><p>再次开启服务，又由1变为2(这个变化过程有延迟，需要等待一会)。同理停止管理器节点上的ndbd服务。</p>
<p><img src="fullprocess.gif"></p></li>
</ul></li>
</ul></li>
<li><p>在集群管理器控制台上查看集群信息，命令为：<code>ndb_mgm</code>。然后在集群管理器控制台输入<code>SHOW</code>，输出信息如下：</p>
<ul>
<li><p>192.168.50.128的数据节点ndbd断开连接的情况</p>
<p><img src="ndbmgm.png"></p></li>
<li><p>192.168.50.128的数据节点ndbd未断开连接的情况</p>
<p><img src="ndbmgm1.png"></p>
<p>192.168.50.128的mysql服务器启动</p>
<p><img src="mysqldallconnect.png"></p></li>
</ul></li>
<li><p>退出MySQL客户端，使用quit或按CTRL-D</p></li>
<li><p>管理控制台功能很多，有很多其他的管理命令来管理集群和数据, 包括创建在线备份. 更多信息参考官方<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster-management.html">official MySQL documentation</a></p></li>
</ul>
<h4 id="向mysql集群插入数据">2.3.7 向MySQL集群插入数据</h4>
<ul>
<li><p>注意为了使用集群功能, 必须使用NDB数据库引擎。如果使用InnoDB (default)或其他引擎,将不能使用集群。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打开MySQL客户端连接到root账号</span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line"># 首先, 创建数据库clustertest:</span><br><span class="line">CREATE DATABASE clustertest;</span><br><span class="line"></span><br><span class="line"># 其次转到新数据库:</span><br><span class="line">USE clustertest;</span><br><span class="line"></span><br><span class="line"># 再次，创建表test_table:</span><br><span class="line"># 需要显式规定ndbcluster引擎</span><br><span class="line">CREATE TABLE test_table (name VARCHAR(20), value VARCHAR(20)) ENGINE&#x3D;ndbcluster;</span><br><span class="line"></span><br><span class="line"># 现在可以插入数据了:</span><br><span class="line">INSERT INTO test_table (name,value) VALUES(&#39;some_name&#39;,&#39;some_value&#39;);</span><br><span class="line"></span><br><span class="line"># 最后验证数据插入：</span><br><span class="line">SELECT * FROM test_table;</span><br><span class="line"></span><br><span class="line"># show databases</span><br></pre></td></tr></table></figure></p>
<p><img src="insertdata.png"></p></li>
<li><p><strong><a href="#251-ndb%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e6%b5%8b%e8%af%95">思考：在本例中，数据被插入到了哪个机器？</a></strong></p>
<ul>
<li>我认为数据应该被插入了本地机器</li>
<li>在此处数据备份为2的话，则另一个数据节点有一份相同的备份</li>
</ul></li>
<li><p>可以在my.cnf文件中设定默认数据存储引擎为ndbcluster，这样创建表时就不再规定引擎了。更多信息参考<a href="https://dev.mysql.com/doc/refman/5.7/en/storage-engine-setting.html">MySQL Reference Manual</a></p></li>
</ul>
<h3 id="结语">2.4 结语</h3>
<p>至此我们在Ubuntu 16.04 servers上安装和配置了a MySQL Cluster。需要注意的是这是一个很小的简化体系结构来说明配置过程，部署一个生产环境，还有许多其他的选项和特征需要去学习.。更多信息请参阅 <a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-cluster.html">MySQL Cluster documentation</a></p>
<h3 id="验证可靠性">2.5 验证可靠性</h3>
<h4 id="ndb存储引擎测试">2.5.1 NDB存储引擎测试</h4>
<ul>
<li><p>在192.168.50.129的SQL节点创建数据库并且插入数据(一定要设置存储引擎为NDB)，在192.168.50.128的SQL节点可以查询到，<strong>两个SQL节点查询的数据时一致的，能够同步</strong></p>
<p><img src="databaseposition.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use clustertest</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="单点故障测试">2.5.2 单点故障测试</h4>
<h5 id="sql节点发生单点故障">SQL节点发生单点故障</h5>
<ul>
<li><p>将SQL节点192.168.50.128上的MySQL服务停止 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;mysqld stop</span><br><span class="line"># sudo systemctl stop mysql</span><br></pre></td></tr></table></figure></p></li>
<li><p>ndb_mgm查看cluster状态</p>
<p><img src="sqlnotonnect.png"></p></li>
<li><p>从SQL节点192.168.50.129上查看数据，正常</p>
<p><img src="onesqlfailed.png"></p>
<p><img src="onesqlfailed.gif"></p></li>
<li><p>SQL节点的单点故障并没有引起数据查询的故障。对于应用来说，需要改变的就是将以前对故障节点的访问改为对非故障节点的访问</p></li>
</ul>
<h5 id="ndb数据节点单点故障">NDB(数据节点)单点故障</h5>
<ul>
<li><p>在这个测试环境中，数据节点也是两个，那么他们对数据的存储是互相镜像还是一份数据分成几块存储呢？这个答案关键在于配置文件中[NDBD DEFAULT]组中的<strong>NoOfReplicas参数</strong>，如果这个参数等于1，表示只有一份数据，但是分成N块分别存储在N个数据节点上，如果该值等于2，则表示数据被分成N/2,每块数据都有两个备份，这样即使有任意一个节点发生故障，只要它的备份节点正常，数据就可以正常查询</p></li>
<li><p>将NDB节点192.168.50.129上的ndbd服务停止 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep ndbd</span><br><span class="line">pkill -9 ndbd</span><br></pre></td></tr></table></figure></p></li>
<li><p>ndb_mgm查看cluster状态，NDB节点192.168.50.129上已经挂掉</p>
<p><img src="onendbfailed.png"></p></li>
<li><p>从SQL节点192.168.50.128和SQL节点192.168.50.129上查看数据，正常</p>
<p><img src="onenbdfailed.gif"></p></li>
<li><p>在此样例中，挂掉一个NDB节点不影响正常的数据查询，数据节点的冗余同样防止了NDB单点故障</p></li>
<li><p>如果该测试中，NoOfReplicas=1，如果有一个数据节点挂了，则无法正常访问完整数据</p></li>
</ul>
<h4 id="集群的关闭">2.5.3 集群的关闭</h4>
<ul>
<li>关闭顺序：SQL节点-&gt;数据节点-&gt;管理节点</li>
<li>NDB节点和管理节点的关闭都可以在管理节点的管理程序中完成，也可以分节点关闭</li>
<li>关闭Cluster节点不会停止sql节点数据库服务</li>
<li>但在关闭整个MySQL Cluster环境(内部关闭：ndb_mgm&gt; shutdown)或者关闭某个SQL节点的时候，首先必须到SQL节点主机上来关闭SQL节点程序</li>
</ul>
<h3 id="思考问题">2.6 思考问题</h3>
<ol type="1">
<li>通过实验，你对一个分布式数据库系统有何理解？分布式数据库系统预计有何优越性？
<ul>
<li>理解：分布在同一个网络；逻辑上属于同一个系统；物理上分布在不同的节点上</li>
<li>优越性：
<ul>
<li>适合分布式数据管理，能有效地提高系统性能，吞吐率和响应速度提高</li>
<li>分布式数据库系统可利用现有的设备和系统，省时、省力、投资少</li>
<li>提高了系统的可用性、可靠性和并行执行度，并允许存储数据副本</li>
<li>根据实际需要，可增减某一场地，系统具有可扩展性</li>
<li>分布式数据库系统资源和数据分布在物理上不同的场地上，为系统所有用户共享</li>
</ul></li>
</ul></li>
<li><a href="#25-%e9%aa%8c%e8%af%81%e5%8f%af%e9%9d%a0%e6%80%a7">你能设计一个方案验证集群系统在可靠性上优于集中式数据库系统吗？</a>
<ul>
<li>集中式数据库，单点，崩了就完了</li>
</ul></li>
<li>同样是插入数据，你觉得MySQL Cluster和myCAT在实体完整性保持方面是否可能会有不同？为什么？ &gt; Entity Integrity ensures that there are no duplicate records within the table and that the field that identifies each record within the table is unique and never null.
<ul>
<li>实体完整性要求每个数据表都必须有<strong>主键</strong>，而作为主键的所有字段，其属性必须是<strong>独一及非空值</strong></li>
<li>MySQL Cluster：auto-sharding，需要内存很大(被诟病)</li>
<li>myCAT: 分表分库，即将一个大表水平分割为 N个小表，存储在后端MySQL服务器里或者其他数据库里。早期myCAT没有检测，不同数据库的完整性无法保证，现在未知。</li>
</ul></li>
</ol>
<h2 id="问题与解决">3 问题与解决</h2>
<ul>
<li><p>无法连接虚拟设备sata0:1</p>
<p><img src="cannotconnect.png"></p>
<p>解决：修改虚拟机 -&gt; 右键设置硬件 -&gt; CD/DVD(SATA) -&gt; 使用 ISO 映像文件</p>
<p>但我认为这不影响虚拟机的使用所以就没深入解决</p></li>
<li><p>提供此类问题<code>temporary failure resolving cn.archive.ubuntu.com</code>的解决思路</p>
<p><img src="cannotresolve.png"></p>
<ul>
<li><p>原因：无法解析该域名</p></li>
<li><p>试试<code>nslookup www.baidu.com</code></p></li>
<li><p>如果发现服务器的DNS没有配，则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打开配置文件</span><br><span class="line">vi &#x2F;etc&#x2F;resolv.conf</span><br><span class="line"></span><br><span class="line"># 添加</span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 223.5.5.5</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p>报错：该虚拟机似乎正在使用中。如果该虚拟机未在使用，请按"获取所有权(T)"按钮获取。获取所有权失败。原因:VM异常关闭导致。</p>
<p><img src="usingnow.png"></p>
<p>解决：进入VM虚拟机的存放目录，删除后缀为.lck的文件</p></li>
<li><p><a href="https://www.cnblogs.com/Komorebi-john/p/11381053.html">VMware-以独占方式锁定此配置文件失败.另一个正在运行</a></p>
<ul>
<li>上述的方法都没有成功，通过<a href="https://blog.csdn.net/qq_34418601/article/details/91041411">在Windows程序与功能-&gt;修复vmware解决</a></li>
</ul></li>
<li><p><a href="https://www.linuxidc.com/Linux/2015-06/119021.htm">每次重启虚拟机后，<code>/etc/resolv.conf</code>文件就要重新配置，之前的都被抹去</a> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># resolv.conf文件其实是一个Link文件</span><br><span class="line"># 在Ubuntu中有一个 resolvconf的服务，这个服务用来控制&#x2F;etc&#x2F;resolv.conf的内容</span><br><span class="line"># 一旦我们重启了系统或者该服务，那么&#x2F;etc&#x2F;resolv.conf文件中的内容将被还原为原来的内容</span><br><span class="line"></span><br><span class="line">sudo vi &#x2F;etc&#x2F;resolvconf&#x2F;resolv.conf.d&#x2F;base</span><br><span class="line"># [应用更改](https:&#x2F;&#x2F;www.zhoushangren.com&#x2F;archives&#x2F;779)</span><br><span class="line">sudo resolvconf -u</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>ping: unknown host www.baidu.com</code>的解决方法 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ping 网关</span><br><span class="line">auto ens33</span><br><span class="line">iface ens33 inet dhcp</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="实验总结">4 实验总结</h2>
<ul>
<li>VMware挂起
<ul>
<li>相当于物理机中的休眠，会将内存中的数据全部存放到对应的休眠文件中，占用的空间为内存大小，并且会对虚拟机执行关机操作</li>
<li>休眠后的虚拟机不占任何CPU、内存</li>
<li>相对于关机，只多了一个和内存大小相同的休眠文件</li>
</ul></li>
<li>VMware不像virtualbox可以从外部将虚拟机强行终止，VMware的虚拟机若是不正常关机，下一次启动会出现很多莫名其妙的问题。</li>
<li><code>sudo apt-get update</code>总是出问题的时候，通过科学上网、修改dns服务器、更改镜像源等操作后未果，可以不要选择大晚上执行命令，<del>太闹心，再也不做这种傻逼事</del>，放一放，换个时间可能会顺利很多。输入该命令之前可添加<code>sudo apt-get clean</code>，若是文件被锁住，则<code>ps -aux | grep apt*</code>获取有关进程的PID，然后<code>sudo kill PID</code>。</li>
<li>update和upgrade的区别：update是更新软件列表，upgrade是更新软件。在执行<code>upgrade</code>之前要先<code>update</code> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update: 同步 &#x2F;etc&#x2F;apt&#x2F;sources.list 和 &#x2F;etc&#x2F;apt&#x2F;sources.list.d 中列出的源的索引</span><br><span class="line">upgrade：升级已安装的所有软件包，升级之后的版本就是本地索引里的</span><br></pre></td></tr></table></figure></li>
<li>apt和apt-get的区别 &gt; apt = apt-get、apt-cache 和 apt-config 中最常用命令选项的集合 &gt; &gt; 用 apt 替换部分 apt-get 系列命令，但不是全部</li>
</ul>
<h2 id="参考资料">5 参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/huozf/p/9780747.html">在VMware Workstation中安装Ubuntu Server 16.04.5图解教程</a></li>
<li><a href="https://www.linuxidc.com/Linux/2017-04/143102.htm">为VMware虚拟机内安装的Ubuntu 16.04设置静态IP地址</a></li>
<li><a href="https://blog.csdn.net/qq_31454611/article/details/80566002">SSH远程连接安装在VMware的Ubuntu16.0.4</a> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看虚拟机是否能够ping外网</span><br><span class="line"># 不行，配置DNS服务器 &#96;sudo vi &#x2F;etc&#x2F;resolv.conf&#96;</span><br><span class="line"># 重启网络sudo &#x2F;etc&#x2F;init.d&#x2F;networking restart</span><br><span class="line"># 检查当前的ssh开启情况</span><br><span class="line"># 如果有sshd，则ssh-server已经启动；若仅有agent，则尚未启动</span><br><span class="line">ps -e |grep ssh</span><br><span class="line"></span><br><span class="line"># 查看端口情况</span><br><span class="line">sudo netstat -plntu</span><br><span class="line"></span><br><span class="line"># 开启ssh服务</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;ssh start</span><br><span class="line"></span><br><span class="line"># 重启ssh</span><br><span class="line">sudo &#x2F;etc&#x2F;init.d&#x2F;ssh restart</span><br><span class="line"></span><br><span class="line"># 当主机ssh连接虚拟机出现ssh: connect to host 192.168.50.129 port 22: Connection timed out</span><br><span class="line"># 解决1:测试虚拟机是否能访问外网</span><br></pre></td></tr></table></figure></li>
<li><a href="https://www.cnblogs.com/gomysql/p/3664783.html">MySQL Cluster搭建与测试</a></li>
<li><a href="https://blog.csdn.net/JesseYoung/article/details/38726561">MySQL Cluster技术详解</a></li>
</ul>
]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>Cluster</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows下git clone慢的尝试解决方法</title>
    <url>/2020/03/21/Windows-git-clone-slow/</url>
    <content><![CDATA[<div class="notification is-success">
<p><strong>重启大法?!</strong> 重启网络，重启机器 </div></p>
<div class="notification is-success">
<p>科学上网 </div></p>
<div class="notification is-warning">
<p>STILL SLOW </div></p>
<div class="notification is-danger">
<p>ERROR: PRC fail </div></p>
<a id="more"></a>
<p><img src="prc-fail.png" /></p>
<h1 id="git使用太多内存"><a href="#git%e4%bd%bf%e7%94%a8%e5%a4%aa%e5%a4%9a%e5%86%85%e5%ad%98">git使用太多内存</a></h1>
<ul>
<li>git使用太多内存，需要先<code>git gc</code></li>
</ul>
<h1 id="源代码过于庞大"><a href="#%e6%ba%90%e4%bb%a3%e7%a0%81%e8%bf%87%e4%ba%8e%e5%ba%9e%e5%a4%a7">源代码过于庞大</a></h1>
<ul>
<li><p>http方式不行，可以用ssh的方式(<a href="https://blog.csdn.net/lqlqlq007/article/details/78983879">首先要进行git ssh的配置</a>)</p></li>
<li><p>需要修改git的http.postBuffer，加大git传输字节，仅对http形式有效</p>
<figure class="highlight plain"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">% 查看当前的配置</span><br><span class="line">git config -l</span><br><span class="line">% 加大httpbuffer</span><br><span class="line">git config --global http.postBuffer 524288000</span><br><span class="line">git config --global http.sslVerify false</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="修改host文件"><a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99">修改host文件</a></h1>
<ul>
<li><p>通过<a href="https://www.ipaddress.com/">查询ip地址</a></p>
<ul>
<li><code>github.global.ssl.fastly.net</code></li>
<li><code>github.com</code></li>
<li><code>assets-cdn.github.com</code></li>
</ul></li>
<li><p>位于<code>C:\Windows\System32\drivers\etc</code>目录下的<code>hosts</code>文件</p></li>
<li><p>按如下格式，在文件末尾写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">151.101.185.194 global-ssl.fastly.net</span><br><span class="line">140.82.113.3  github.com</span><br></pre></td></tr></table></figure></li>
<li><p>刷新系统dns缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 可在windows的cmd下</span><br><span class="line">ipconfig &#x2F;flushdns</span><br></pre></td></tr></table></figure></li>
<li><p>ip经常会变，如发现速度又下降了，及时去更换ip</p></li>
</ul>
<h1 id="git设置和取消代理"><a href="#git%e8%ae%be%e7%bd%ae%e5%92%8c%e5%8f%96%e6%b6%88%e4%bb%a3%e7%90%86">git设置和取消代理</a></h1>
<h2 id="vpn的情况下"><a href="#vpn%e7%9a%84%e6%83%85%e5%86%b5%e4%b8%8b">vpn的情况下</a></h2>
<ul>
<li>开全局代理的情况下，利用代理进行下载，对https有效，ssh无效 <figure class="highlight plain"><figcaption><span>bash</span></figcaption><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http:&#x2F;&#x2F;127.0.0.1:自己的端口号</span><br><span class="line">git config --global https.proxy https:&#x2F;&#x2F;127.0.0.1:自己的端口号</span><br><span class="line"></span><br><span class="line"># 可以在计算机的设置-&gt;代理查看</span><br><span class="line"></span><br><span class="line"># 取消方式</span><br><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br><span class="line"></span><br><span class="line"># 查看目前所有的配置</span><br><span class="line">git config --global list</span><br></pre></td></tr></table></figure></li>
<li>使用全局代理，clone国内仓库慢，改进：只对github进行代理，对国内的仓库不影响 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 先取消全局代理，通过上面的取消方法</span><br><span class="line"></span><br><span class="line">git config --global http.https:&#x2F;&#x2F;github.com.proxy https:&#x2F;&#x2F;127.0.0.1:自己的端口号</span><br><span class="line">git config --global https.https:&#x2F;&#x2F;github.com.proxy https:&#x2F;&#x2F;127.0.0.1:自己的端口号</span><br><span class="line"></span><br><span class="line"># 取消</span><br><span class="line">git config --global --unset http.https:&#x2F;&#x2F;github.com.proxy</span><br><span class="line">git config --global --unset https.https:&#x2F;&#x2F;github.com.proxy</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="关于git其他问题"><a href="#关于git其他问题">关于git其他问题</a></h1>
<ul>
<li><a href="https://stackoverflow.com/questions/49067062/fatal-httprequestexception-encountered-error-with-github-bitbucket-repositor">“fatal: HttpRequestException encountered.” Error with GitHub/Bitbucket Repositories due to dropping TLS-1.0 support</a></li>
</ul>
<h1 id="参考资料"><a href="#%e5%8f%82%e8%80%83%e8%b5%84%e6%96%99">参考资料</a></h1>
<ul>
<li><p><a href="https://www.cnblogs.com/rockbean/p/12017010.html">git设置和取消代理</a></p></li>
<li><p><a href="https://github.com/hexojs/hexo/issues/4172">谜之问题</a></p>
<p><img src="ERROR.png" /></p>
<p>可能是：短时间过多请求api造成的</p>
<p>解决： <code>hexo\themes\next\scripts\events\index.js</code></p>
<p>将<a href="https://github.com/theme-next/hexo-theme-next/commit/9b543ddacf21a59f2daa52b0ae64075aed62fca2">作者修改的部分</a>做注释</p>
<p><img src="error-fix.png" /></p></li>
</ul>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>MkDocs+Github+Travis搭建博客</title>
    <url>/2020/03/21/MkDocs-Github-Travis/</url>
    <content><![CDATA[<blockquote>
<p>最近是不是玩博客玩疯了 大概逻辑：通过Travis CI部署的MkDocs环境生成静态页面并且发布到GitHub上 能够通过https://xxx.github.io/<仓库名>访问 MkDocs 官网 1. https://squidfunk.github.io/mkdocs-material/ 2. https://www.mkdocs.org/</p>
<p>Travis 官网 https://travis-ci.org</p>
</blockquote>
<a id="more"></a>
<h1 id="github">Github</h1>
<ul>
<li>建立仓库后，<code>git clone</code>仓库到本地</li>
</ul>
<h1 id="mkdocs">MkDocs</h1>
<h2 id="使用简介-最好看文档">使用简介 [最好看文档]</h2>
<h3 id="安装">安装</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 查看python和pip版本</span><br><span class="line">python --version</span><br><span class="line">pip --version</span><br><span class="line"># Installing and verifying MkDocs </span><br><span class="line"># Material requires MkDocs &gt;&#x3D; 1.0.0.</span><br><span class="line">pip install mkdocs &amp;&amp; mkdocs --version</span><br><span class="line"># install material</span><br><span class="line">pip install mkdocs-material</span><br></pre></td></tr></table></figure>
<h3 id="使用">使用</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建文档库</span><br><span class="line"># xxx是目录名称 会生成docs文件夹和mkdocs.yml</span><br><span class="line">mkdocs new xxx</span><br><span class="line"># 启用服务</span><br><span class="line">mkdocs serve</span><br><span class="line"># 编译构建站点</span><br><span class="line">mkdocs build</span><br></pre></td></tr></table></figure>
<p><strong>至于页面的样式，看文档更改mkdocs.yml文件</strong></p>
<h2 id="部署到github">部署到Github</h2>
<ul>
<li>将克隆下来的仓库切到<code>master</code>主分支</li>
<li>将上述产生的<code>docs文件夹和mkdocs.yml</code>放入该git目录下</li>
<li>自动编译并发布至<code>Github gh-pages</code>分支 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdocs gh-deploy --clean</span><br><span class="line"># 可以 mkdocs serve 看看是否能够正常显示</span><br></pre></td></tr></table></figure></li>
<li>将本地的仓库同步远程 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git push</span><br></pre></td></tr></table></figure></li>
<li>通过<code>https:xxx.github.io/仓库名称</code>访问</li>
</ul>
<h1 id="travis">Travis</h1>
<ul>
<li>持续集成服务 <del>看起来像是监控每一次的提交修改的情况</del></li>
<li><a href="https://flc.io/more/github-travis-mkdocs-document/">直接附上教程</a></li>
</ul>
<h1 id="references">References</h1>
<ul>
<li><a href="https://www.jianshu.com/p/b07dc1fd4f9e">使用MKdocs搭建个人博客并发布在Github Pages上</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1468110">基于mkdocs-material搭建个人静态博客</a></li>
</ul>
]]></content>
      <categories>
        <category>Blogs</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>MkDocs</tag>
        <tag>github</tag>
        <tag>Travis</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github搭建博客</title>
    <url>/2020/03/21/hexo-github/</url>
    <content><![CDATA[<blockquote>
<p>Hexo是一个基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题 github：https://github.com/hexojs/hexo 官网：http://hexo.io</p>
</blockquote>
<a id="more"></a>
<h1 id="hexo-一些命令-用法">hexo 一些命令 &amp; 用法</h1>
<ul>
<li><p>一般下载的主题的位置位于<code>hexo/themes</code>，切换主题的时候需要修改<code>hexo/_config.yml</code>中的<code>theme</code></p></li>
<li><p>一般生成的文章的位置位于<code>hexo/source/_posts</code></p></li>
<li><p>所有的命令都在<code>git bash</code>下进行，一些<code>hexo</code>的命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo generate 生成静态文件 </span><br><span class="line">hexo g</span><br><span class="line"># hexo server 启动服务，在本地预览</span><br><span class="line">hexo s </span><br><span class="line"># hexo deploy 部署网站</span><br><span class="line"># 上传到github，无需通过git add和git push，但需要配置</span><br><span class="line">hexo d</span><br><span class="line"># 新建文章</span><br><span class="line">hexo new &quot;name&quot;</span><br><span class="line"># 新建页面</span><br><span class="line">hexo new page &quot;pageName&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>插入图片 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo&#x2F;_config.yml </span><br><span class="line">post_asset_folder: true</span><br><span class="line"># hexo n 生成md博文时，&#x2F;source&#x2F;_posts文件夹内除了md文件还有一个同名的文件夹，不再赘述</span><br><span class="line"></span><br><span class="line"># 在hexo目录下，安装上传本地图片的插件，我装了会出错</span><br><span class="line">npm install hexo-asset-image --save</span><br><span class="line"># 卸载</span><br><span class="line">npm uninstall hexo-asset-image</span><br></pre></td></tr></table></figure></p></li>
<li><p><a href="https://github.com/theme-next/hexo-symbols-count-time/issues/53">The symbols count is undefined and reading time is NaN:aN</a></p></li>
</ul>
<h1 id="github">Github</h1>
<ul>
<li><p>部署到github上，通过hexo直接更新github仓库 如果要通过<code>hexo d</code>直接上传，需要配置</p>
<ul>
<li><code>ssh key</code></li>
<li>修改<code>hexo/_config.yml</code>中有关<code>deploy</code>的部分</li>
</ul>
<p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:purplezi/purplezi.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>安装插件<code>npm install hexo-deployer-git --save</code></li>
</ul></li>
</ul>
<h1 id="其他主题">其他主题</h1>
<blockquote>
<ol type="1">
<li>Fluid，基于 Hexo 的一款 Material Design 风格的主题 github：https://github.com/fluid-dev/hexo-theme-fluid 官网：https://hexo.fluid-dev.com/docs 配置指南：https://hexo.fluid-dev.com/docs</li>
<li>https://github.com/blinkfox/hexo-theme-matery</li>
<li>https://github.com/litten/hexo-theme-yilia 推荐用yilia-plus</li>
<li>https://www.zhihu.com/question/24422335?utm_source=qq&amp;utm_medium=social&amp;utm_oi=868617446326681600</li>
<li>http://ppoffice.github.io/hexo-theme-icarus dark mode change: https://blog.sbx0.cn/2020/04/07/icarus-3-night-mode/</li>
</ol>
</blockquote>
<ul>
<li>更换主题后出现文章的图片加载不出，找不到原因
<ul>
<li>解决方法：对每篇文章进行微修改，就可以马上加载出来了</li>
</ul></li>
<li>如果是配置gitee的Gitee Pages，不是Pro，则需要手动到Gitee Pages上更新</li>
</ul>
<h1 id="参考资料">参考资料</h1>
<ul>
<li><a href="https://io-oi.me/tech/hexo-next-optimization/">hexo+Github超深度优化</a></li>
<li><a href="http://chant00.com/2015/11/04/%E5%9C%A8hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%EF%BC%8C%E9%9F%B3%E4%B9%90%EF%BC%8C%E8%A7%86%E5%B1%8F%EF%BC%8C%E5%85%AC%E5%BC%8F/">在hexo中加入图片、音频、视频</a></li>
</ul>
]]></content>
      <categories>
        <category>Blogs</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
